{"version":3,"sources":["DragNDrop/index.tsx","AppFooter.tsx","App.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","index.tsx","DragNDrop/KubeflowPipelines.tsx","DragNDrop/DebugScratch.tsx","componentStore.ts","componentSpec.ts","DragNDrop/samplePipelines.ts","DragNDrop/ArgumentsEditorDialog.tsx","DragNDrop/ComponentTaskNode.tsx","DragNDrop/GraphComponentSpecFlow.tsx","github.ts","cacheUtils.ts","DragNDrop/DraggableComponent.tsx","DragNDrop/ArgumentsEditor.tsx","appSettings.ts","DragNDrop/vertexPipelineSpec.ts","DragNDrop/vertexAiCompiler.ts","DragNDrop/Sidebar.tsx","DragNDrop/ComponentLibrary.tsx","DragNDrop/ComponentSearch.tsx","DragNDrop/GraphComponentExporter.tsx","DragNDrop/GoogleCloud.tsx","DragNDrop/VertexAiExporter.tsx","DragNDrop/UserComponentLibrary.tsx","DragNDrop/GraphComponentLink.tsx","DragNDrop/SamplePipelineLibrary.tsx","DragNDrop/PipelineLibrary.tsx"],"names":["SAVED_COMPONENT_SPEC_KEY","ComponentSpecAutoSaver","componentSpec","nodes","useStoreState","store","undefined","length","console","warn","augmentComponentSpec","componentText","componentSpecToYaml","window","sessionStorage","setItem","err","message","startsWith","error","saveComponentSpec","isAppleOS","navigator","platform","DnDFlow","useState","setComponentSpec","restoredComponentSpec","getItem","loadedYaml","yaml","load","loadComponentSpec","loadComponentFromUrl","XGBOOST_PIPELINE_URL","then","className","GraphComponentSpecFlow","deleteKeyCode","multiSelectionKeyCode","snapToGrid","snapGrid","gap","Sidebar","AppFooter","style","width","height","padding","textAlign","backgroundColor","display","Link","href","underline","target","rel","App","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","log","onUpdate","onSuccess","catch","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","URL","process","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration","KubeflowPipelinesSubmitter","setMessage","onClick","e","a","Headers","text","responseText","DebugScratch","isDialogOpen","setIsDialogOpen","KubeflowPipelines","Accordion","AccordionSummary","Dialog","open","aria-labelledby","aria-describedby","DialogTitle","id","DialogContent","DialogContentText","DialogActions","Button","color","autoFocus","DB_NAME","DIGEST_TO_DATA_DB_TABLE_NAME","DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME","URL_TO_DIGEST_DB_TABLE_NAME","DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME","FILE_STORE_DB_TABLE_NAME_PREFIX","calculateHashDigestHex","data","dataBytes","TextEncoder","encode","crypto","subtle","digest","hashBuffer","hashArray","Array","from","Uint8Array","hashHex","map","b","toString","padStart","join","storeComponentSpec","digestToComponentSpecDb","localForage","createInstance","name","storeName","digestToComponentNameDb","loadComponentAsRefFromText","componentString","TextDecoder","decode","componentBytes","loadedObj","Error","isValidComponentSpec","componentRefPlusData","componentRef","spec","storeComponentText","digestToComponentTextDb","storeComponentFromUrl","url","setUrlAsCanonical","urlToDigestDb","digestToDataDb","existingDigest","componentData","arrayBuffer","digestToCanonicalUrlDb","existingCanonicalUrl","debug","makeNameUniqueByAddingIndex","existingNames","finalName","index","has","writeComponentRefPlusDataToFile","listName","fileName","upgradeSingleComponentListDb","tableName","componentListDb","existingFile","currentTime","Date","fileEntry","creationTime","modificationTime","addComponentRefPlusDataToList","Set","keys","uniqueFileName","addComponentToListByUrl","defaultFileName","addComponentToListByText","writeComponentToFileListFromText","getAllComponentFilesFromList","componentFiles","Map","iterate","iterationNumber","set","getComponentFileFromList","deleteComponentFileFromList","removeItem","dump","lineWidth","componentListVersionKey","componentStoreSettingsDb","componentListTableName","listFormatVersion","includes","componentRefListsDb","componentRefList","emptyNameReplacement","add","fileNames","newDigest","newFileEntry","obj","isContainerImplementation","implementation","isGraphImplementation","DATA_PASSING_PIPELINE_URL","GOOGLE_CLOUD_OPTIMIZER_PIPELINE_URL","PRELOADED_PIPELINE_URLS","preloadComponentReferences","componentMap","Object","values","graph","tasks","taskSpec","componentUrl","taskComponentSpec","downloadComponentDataWithCache","preloadChildComponentSpecs","ArgumentsEditorDialog","closeEditor","setArguments","arguments","currentArguments","setCurrentArguments","onSubmit","preventDefault","position","background","border","borderRadius","ArgumentsEditor","componentArguments","setComponentArguments","type","inputHandlePosition","Position","Top","outputHandlePosition","Bottom","isComponentTaskNode","node","generateHandles","ioSpecs","handleType","idPrefix","inputsWithMissingArguments","handleComponents","numHandles","i","ioSpec","positionPercentString","String","left","top","ioTypeName","classNames","replace","push","generateLabelStyle","labelClasses","labelStyle","isConnectable","title","maxLabelWidthPx","maxWidth","ComponentTaskNode","isArgumentsEditorOpen","setIsArgumentsEditorOpen","label","inputsWithInvalidArguments","inputs","filter","inputSpec","optional","default","inputHandles","inputSpecs","generateInputHandles","outputHandles","outputs","concat","onDoubleClick","taskId","SDK_ANNOTATION_VALUE","taskIdToNodeId","inputNameToNodeId","outputNameToNodeId","nodeIdToTaskId","nodeIdToInputName","nodeIdToOutputName","includeSpecs","includePositions","getNodePositionAnnotation","JSON","stringify","x","__rf","y","nodeXPositionComparer","n1","n2","deltaX","deltaY","nodeYPositionComparer","inputNodes","sort","outputNodes","taskNodes","inputPositionMap","inputOrderMap","inputOrderComparer","Infinity","outputPositionMap","outputOrderMap","outputOrderComparer","taskPositionMap","taskOrderMap","taskOrderComparer","pairA","pairB","newAnnotations","annotations","NODE_LAYOUT_ANNOTATION_KEY","newInputSpec","outputSpec","newOutputSpec","graphSpec","newTasks","fromEntries","entries","newTaskSpec","rebuildComponentSpec","description","metadata","rest","nodeTypes","task","memo","children","reactFlowInstance","setReactFlowInstance","layoutAnnotation","decodedPosition","parse","args","setTaskArguments","edges","flatMap","inputName","argument","taskOutput","outputName","source","sourceHandle","targetHandle","arrowHeadType","ArrowHeadType","ArrowClosed","graphInput","outputEdges","outputValues","elements","replaceComponentSpec","newComponentSpec","replaceGraphSpec","newGraphSpec","taskArguments","setTaskArgument","oldTaskSpecArguments","newTaskSpecArguments","removeTaskArgument","setGraphOutputValue","outputValue","newGraphOutputValues","removeGraphOutputValue","addConnection","connection","targetTaskInputName","sourceTaskOutputName","taskOutputArgument","graphInputArgument","removeEdge","edge","removeNode","inputNameToRemove","newInputs","removeComponentInput","outputNameToRemove","newOutputs","removeComponentOutput","taskIdToRemove","removeTask","onConnect","params","onDragOver","event","dataTransfer","dropEffect","onDrop","droppedData","getData","droppedDataObject","nodeType","nodeData","dragOffsetX","dragOffsetY","dragStartOffsetData","dragStartOffset","offsetX","offsetY","project","clientX","clientY","nodePosition","positionAnnotations","mergedAnnotations","taskSpecWithAnnotation","getUniqueTaskName","getUniqueInputName","getUniqueOutputName","onEdgeUpdate","oldEdge","newConnection","onElementsRemove","elementsToRemove","element","isEdge","isNode","onLoad","_reactFlowInstance","SEARCH_CACHE_NAME","BLOB_CACHE_NAME","HASH_TO_CONTENT_DB_TABLE_NAME","HASH_TO_COMPONENT_NAME_DB_TABLE_NAME","URL_TO_HASH_DB_TABLE_NAME","HASH_TO_URL_DB_TABLE_NAME","URL_PROCESSING_VERSION_TABLE_NAME","BAD_HASHES_TABLE_NAME","searchGitHubCodeWithCache","query","page","order","encodedQuery","encodeURIComponent","encodedSort","encodedOrder","searchUrl","httpGetWithCache","json","githubHtmlUrlToDownloadUrl","htmlUrl","getComponentUrlsAndHashes","searchLocations","urlsAndHashes","queryParts","searchResults","items","item","html_url","hash","sha","Promise","resolve","setTimeout","blob","componentSpecObj","cacheAllComponents","urlsAndHashesIterator","urlToHashDb","hashToUrlDb","hashToContentDb","hashToComponentNameDb","urlProcessingVersionDb","badHashesDb","toLowerCase","badHashReason","downloadUrl","endsWith","cachedHash","urlVersion","Number","parseInt","isComponentFeedEntry","isComponentFeed","isArray","every","isComponentFeedEntryArray","notUndefined","calculateGitBlobSha1HashHex","dataString","gitDataString","gitDataBytes","importComponentsFromFeed","componentFeedUrl","componentFeedCandidateBlob","componentFeedCandidateText","componentFeedCandidateObject","componentFeed","all","components","entry","urlsHashesAndData","error_message","refreshComponentDb","componentSearchConfig","ComponentFeedUrls","GitHubSearchLocations","getAllComponentsAsRefs","hashToComponentRef","componentRefs","forEach","isComponentDbEmpty","searchComponentsByName","ref","urlOrRequest","cacheName","updateIfInCache","caches","cache","response2","reject","DraggableComponent","componentReference","props","draggable","onDragStart","setData","nativeEvent","effectAllowed","shrinkToWidth","borderSpacing","tableLayout","value","placeholder","typeSpec","argumentIsRequiredButMissing","typeSpecString","whiteSpace","overflow","textOverflow","verticalAlign","borderWidth","minWidth","required","pattern","onChange","disabled","componentLibraryUrl","PrimitiveTypeEnum","TriggerStrategy","sanitizePipelineInfoName","pipelineContextName","typeSpecToVertexPrimitiveTypeEnum","vertex","INT","DOUBLE","STRING","typeSpecToVertexParameterSpec","stringToMlmdValue","constantString","primitiveType","stringValue","intValue","doubleValue","parseFloat","MAKE_ARTIFACT_COMPONENT_ID","MAKE_ARTIFACT_EXECUTOR_ID","MAKE_ARTIFACT_INPUT_NAME","MAKE_ARTIFACT_OUTPUT_NAME","buildMakeArtifactTaskSpec","parameterArgumentSpec","taskInfo","parameters","cachingOptions","enableCache","makeArtifactComponentSpec","executorLabel","inputDefinitions","outputDefinitions","artifacts","artifactType","schemaTitle","makeArtifactExecutorSpec","container","image","command","buildVertexParameterArgumentSpec","taskArgument","runtimeValue","constantValue","componentInputParameter","taskOutputParameter","producerTask","outputParameterKey","buildVertexArtifactArgumentSpec","upstreamCannotBeArtifact","addMakeArtifactTaskAndGetArtifactArgumentSpec","result","componentInputArtifact","taskOutputArtifact","outputArtifactKey","assertDefined","TypeError","buildVertexComponentSpecFromContainerComponentSpec","inputsThatHaveParameterArguments","addExecutorAndGetId","containerSpec","resolvedCommandLine","inputsConsumedAsParameter","inputsConsumedAsArtifact","convertArg","arg","inputValue","inputPath","outputPath","if","cond","else","ifCond","ifThen","ifElse","condEvaluatesToTrue","isPresent","unresolvedArgs","resolveCommandLine","vertexExecutorId","inputMap","buildVertexComponentSpecFromGraphComponentSpec","addComponentAndGetId","vertexTasks","taskStringToTaskId","addTaskAndGetId","namePrefix","serializedSpec","existingId","usedIds","makeArtifactExecutorId","makeArtifactComponentSpecCopy","makeArtifactComponentsId","makeArtifactTaskSpec","artifactArgumentSpec","vertexTaskSpec","buildVertexTaskSpecFromTaskSpec","inputNamesThatAreUsedBothAsParameterAndArtifact","inputNamesThatAreParametersButAreConsumedAsArtifacts","record","transform","dagOutputArtifactSpecs","artifactSelectors","producerSubtask","key","dag","buildVertexComponentSpecFromComponentSpec","graphInputsWithParameterArguments","vertexComponentSpec","vertexComponentId","vertexTaskParameterArguments","vertexTaskArtifactArguments","graphComponentSpecToVertexPipelineSpec","vertexExecutors","executorStringToExecutorId","vertexComponents","componentStringToComponentId","executor","component","pipelineArguments","pipelineComponentSpec","vertexPipelineSpec","pipelineInfo","sdkVersion","schemaVersion","deploymentSpec","executors","root","generateVertexPipelineJobFromGraphComponent","gcsOutputDirectory","pipelineSpec","inputParameterDefinitions","convertedPipelineArguments","pipelineJob","displayName","runtimeConfig","DebugScratchElement","NODE_ENV","require","fontWeight","input","output","DraggableComponentRow","useEffect","SingleFolderVis","folder","isOpen","paddingLeft","folders","componentFolder","ComponentLibraryVisFromStruct","componentLibraryStruct","loadComponentLibraryStruct","componentLibrary","ComponentLibraryVisFromUrl","setComponentLibraryStruct","loadedComponentLibrary","SearchPanel","setError","firstTime","setFirstTime","isLoaded","setIsLoaded","setQuery","setItems","results","componentElements","fetchData","gtag","GraphComponentExporter","graphComponent","componentTextBlob","Blob","downloadLink","createObjectURL","download","LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY","LOCAL_STORAGE_PROJECT_ID_KEY","LOCAL_STORAGE_REGION_KEY","LOCAL_STORAGE_PROJECT_IDS_KEY","CLIENT_ID","VERTEX_AI_PIPELINES_REGIONS","authorizeGoogleCloudClient","scopes","immediate","clientId","gapi","auth","authorize","client_id","scope","authResult","receivedScopesString","receivedScopes","split","errorMessage","ensureGoogleCloudAuthorizesScopes","cloudresourcemanagerListProjects","client","request","path","aiplatformCreatePipelineJob","projectId","region","method","body","GoogleCloudSubmitter","localStorage","projects","setProjects","setProject","setRegion","setGcsOutputDirectory","pipelineJobWebUrl","setPipelineJobWebUrl","compilationError","setCompilationError","vertexPipelineJobJson","vertexPipelineJob","defaultInputValues","pipelineArgumentMap","pair","labels","vertexPipelineJobUrl","readyToSubmit","pipelineJobName","pipelineJobId","slice","margin","htmlFor","list","projectIds","projectInfo","VertexAiExporter","vertexPipelineSpecText","vertexPipelineSpecTextBlob","vertexPipelineSpecTextBlobUrl","USER_COMPONENTS_LIST_NAME","UserComponentLibrary","setErrorMessage","setComponentFiles","contextMenuFileName","setContextMenuFileName","contextMenuAnchor","setContextMenuAnchor","isImportComponentDialogOpen","setIsImportComponentDialogOpen","refreshComponents","useCallback","acceptedFiles","file","reader","FileReader","onabort","onerror","onload","binaryStr","readAsArrayBuffer","onImportFromUrl","componentFileEntry","handleContextMenuDelete","useDropzone","accept","getRootProps","getInputProps","isDragActive","marginBottom","minHeight","onContextMenu","currentTarget","anchorEl","onClose","dense","ImportComponentFromUrlDialog","onCancel","initialValue","onImport","urlInputRef","useRef","fullWidth","current","inputRef","GraphComponentLink","downloadFileName","linkText","linkRef","SamplePipelineLibrary","setComponentRefs","loadedComponentRefs","marginLeft","USER_PIPELINES_LIST_NAME","removeSuffixes","s","suffixes","suffix","substring","SavePipelineAsDialog","onPipelineSave","initialName","setFileName","isOverwriteDialogOpen","setIsOverwriteDialogOpen","handleSave","onSave","inputLabel","okButtonText","onOk","OkCancelDialog","cancelButtonText","SaveAsDialog","nameInputRef","TextField","defaultValue","PipelineLibrary","pipelineFile","setPipelineFile","saveAsDialogIsOpen","setSaveAsDialogIsOpen","refreshPipelines","openPipelineFile","componentRefPlusData1","componentRef1","openSaveAsDialog","closeSaveAsDialog","handlePipelineSave","handleContextMenuOpen","fileInput","componentLink","files","click","textDecoration","Menu","MenuItem"],"mappings":"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","file":"static/js/main.32a576ed.chunk.js","sourcesContent":["/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useState } from 'react';\r\nimport {\r\n  ReactFlowProvider,\r\n  Controls,\r\n  Background,\r\n  MiniMap,\r\n  Node,\r\n  useStoreState,\r\n} from 'react-flow-renderer';\r\nimport yaml from \"js-yaml\";\r\n\r\nimport { ComponentSpec } from '../componentSpec';\r\nimport { componentSpecToYaml } from '../componentStore';\r\nimport GraphComponentSpecFlow, { augmentComponentSpec } from './GraphComponentSpecFlow';\r\nimport Sidebar from './Sidebar';\r\nimport { loadComponentFromUrl, XGBOOST_PIPELINE_URL } from \"./samplePipelines\";\r\n//import MainAppBar from \"./MainAppBar\"\r\n\r\nimport './dnd.css';\r\n\r\nconst GRID_SIZE = 10;\r\nconst SAVED_COMPONENT_SPEC_KEY = \"autosaved.component.yaml\";\r\n\r\nconst saveComponentSpec = (componentSpec: ComponentSpec, nodes?: Node[]) => {\r\n  try {\r\n    if (nodes !== undefined) {\r\n      if (nodes.length === 0) {\r\n        console.warn(\"saveComponentSpec: nodes.length === 0\");\r\n      }\r\n      componentSpec = augmentComponentSpec(componentSpec, nodes, true, true);\r\n    }\r\n    const componentText = componentSpecToYaml(componentSpec);\r\n    window.sessionStorage.setItem(SAVED_COMPONENT_SPEC_KEY, componentText);\r\n  } catch(err) {\r\n    // TODO: Find a way to avoid the React/Redux race conditions causing this error.\r\n    if (err?.message?.startsWith(\"The nodes array does not\") !== true) {\r\n      console.error(err);\r\n    }\r\n  }\r\n}\r\n\r\nconst loadComponentSpec = () => {\r\n  try {\r\n    const componentText = window.sessionStorage.getItem(SAVED_COMPONENT_SPEC_KEY);\r\n    if (componentText !== null) {\r\n      const loadedYaml = yaml.load(componentText);\r\n      if (loadedYaml !== null && typeof loadedYaml === \"object\") {\r\n        //TODO: Validate that the spec is valid\r\n        const savedComponentSpec = loadedYaml as ComponentSpec;\r\n        return savedComponentSpec;\r\n      }\r\n    }\r\n  } catch(err) {\r\n    console.error(err);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n// Auto-saver is extracted to its own child component since useStoreState in the parent causes infinite re-rendering\r\n// (each render of GraphComponentSpecFlow seems to change the Redux store).\r\n// This component seems to be triggered for every node movement, so even pure layout changes are saved.\r\nconst ComponentSpecAutoSaver = ({\r\n  componentSpec,\r\n}: {\r\n  componentSpec: ComponentSpec;\r\n}) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n  // Fixing issue where a React error would cause all node positions to be recorded as undefined (`!<tag:yaml.org,2002:js/undefined>`)\r\n  // nodes should never be undefined in normal situation.\r\n  if (nodes !== undefined && nodes.length > 0) {\r\n    saveComponentSpec(componentSpec, nodes);\r\n  }\r\n  return null;\r\n};\r\n\r\nconst isAppleOS = () =>\r\n  window.navigator.platform.startsWith(\"Mac\") ||\r\n  window.navigator.platform.startsWith(\"iPhone\") ||\r\n  window.navigator.platform.startsWith(\"iPad\") ||\r\n  window.navigator.platform.startsWith(\"iPod\");\r\n\r\nconst DnDFlow = () => {\r\n  const [componentSpec, setComponentSpec] = useState<ComponentSpec | undefined>();\r\n\r\n  if (componentSpec === undefined) {\r\n    const restoredComponentSpec = loadComponentSpec();\r\n    if (restoredComponentSpec === undefined) {\r\n      loadComponentFromUrl(XGBOOST_PIPELINE_URL).then(setComponentSpec);\r\n    } else {\r\n      setComponentSpec(restoredComponentSpec);\r\n    }\r\n  };\r\n\r\n  if (componentSpec === undefined) {\r\n    return (<></>);\r\n  }\r\n\r\n  return (<>\r\n    {/* <MainAppBar/> */}\r\n    <div className=\"dndflow\">\r\n      <ReactFlowProvider>\r\n        <div className=\"reactflow-wrapper\">\r\n          <GraphComponentSpecFlow\r\n            componentSpec={componentSpec}\r\n            setComponentSpec={setComponentSpec}\r\n            deleteKeyCode={isAppleOS() ? \"Backspace\" : \"Delete\"}\r\n            multiSelectionKeyCode={isAppleOS() ? \"Command\" : \"Control\"}\r\n            snapToGrid={true}\r\n            snapGrid={[GRID_SIZE, GRID_SIZE]}\r\n          >\r\n            <MiniMap/>\r\n            <Controls />\r\n            <Background gap={GRID_SIZE}/>\r\n          </GraphComponentSpecFlow>\r\n        </div>\r\n        <Sidebar\r\n          componentSpec={componentSpec}\r\n          setComponentSpec={setComponentSpec}\r\n        />\r\n        <ComponentSpecAutoSaver componentSpec={componentSpec}/>\r\n      </ReactFlowProvider>\r\n    </div>\r\n  </>);\r\n};\r\n\r\nexport default DnDFlow;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { Link } from \"@material-ui/core\";\r\n\r\nfunction AppFooter() {\r\n  return (\r\n    <footer\r\n      className=\"footer\"\r\n      style={{\r\n        width: \"100%\",\r\n        height: \"30px\",\r\n        padding: \"4px\",\r\n        textAlign: \"center\",\r\n        backgroundColor: \"ghostwhite\",\r\n      }}\r\n    >\r\n      <div style={{ display: \"inline-block\" }}>\r\n        <Link\r\n          href=\"https://github.com/Cloud-Pipelines/pipeline-editor/issues\"\r\n          underline=\"hover\"\r\n          target=\"_blank\"\r\n          rel=\"noopener\"\r\n        >\r\n          Give feedback\r\n        </Link>\r\n      </div>\r\n    </footer>\r\n  );\r\n}\r\n\r\nexport default AppFooter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport './App.css';\r\nimport DnDFlow from './DragNDrop/index';\r\nimport AppFooter from \"./AppFooter\"\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\" style={{ width: \"100%\", height: \"calc(100% - 30px)\" }}>\r\n      <DnDFlow />\r\n      <AppFooter />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://cra.link/PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://cra.link/PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then((registration) => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://cra.link/PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then((response) => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then((registration) => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log('No internet connection found. App is running in offline mode.');\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then((registration) => {\r\n        registration.unregister();\r\n      })\r\n      .catch((error) => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\r\nimport reportWebVitals from './reportWebVitals';\r\n//import { migrateUserData } from \"./userDataMigration\"\r\n\r\n// Migration is now disabled.\r\n// After 2 months of auto-migration, the redirect from cloud-pipelines.github.io\r\n// to cloud-pipelines.net was changed to hard redirect.\r\n// Accessing the data stored for cloud-pipelines.github.io is now impossible.\r\n// try {\r\n//   migrateUserData();\r\n// } catch (err) {\r\n//   console.error(err);\r\n// }\r\n\r\nReactDOM.render(\r\n  // Strict mode causes every component to be rendered twice in dev environment\r\n  //<App />,\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://cra.link/PWA\r\nserviceWorkerRegistration.register();\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useState } from \"react\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\n\r\ninterface KubeflowPipelinesSubmitterProps {\r\n  componentSpec?: ComponentSpec;\r\n}\r\n\r\nconst KubeflowPipelinesSubmitter = ({\r\n  componentSpec,\r\n}: KubeflowPipelinesSubmitterProps) => {\r\n  const [message, setMessage] = useState(\"\");\r\n\r\n  //npm install axios\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={async (e) => {\r\n          // ! Works !\r\n          const response = await fetch(\r\n            \"https://addr-dot-us-central2.pipelines.googleusercontent.com/apis/v1beta1/runs\",\r\n            {\r\n              headers: new Headers({\r\n                \"Authorization\": \"Bearer \"\r\n              }),\r\n            }\r\n          );\r\n          const responseText = await response.text();\r\n          setMessage(responseText);\r\n        }}\r\n      >\r\n        List KFP runs\r\n      </button>\r\n      <button\r\n        onClick={async (e) => {\r\n          // Error: net::ERR_CERT_AUTHORITY_INVALID\r\n          const response = await fetch(\r\n            \"https://IP/api/v1/pods/\",\r\n            {\r\n              headers: new Headers({\r\n                \"Authorization\": \"Bearer \",\r\n                \"Content-Type\": \"application/json; charset=utf-8\"\r\n              }),\r\n            }\r\n          );\r\n          const responseText = await response.text();\r\n          setMessage(responseText);\r\n        }}\r\n      >\r\n        List K8s cluster objects\r\n      </button>\r\n      <span>{message}</span>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default KubeflowPipelinesSubmitter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport KubeflowPipelinesSubmitter from \"./KubeflowPipelines\";\r\nimport {\r\n  Accordion,\r\n  AccordionSummary,\r\n  Button,\r\n  Dialog,\r\n  DialogActions,\r\n  DialogContent,\r\n  DialogContentText,\r\n  DialogTitle,\r\n} from \"@material-ui/core\";\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { useState } from \"react\";\r\n\r\ninterface DebugScratchProps {\r\n  componentSpec?: ComponentSpec;\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void;\r\n}\r\n\r\nconst DebugScratch = ({\r\n  componentSpec,\r\n  setComponentSpec,\r\n}: DebugScratchProps) => {\r\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\r\n\r\n\r\n  return (\r\n    <>\r\n      <KubeflowPipelinesSubmitter componentSpec={componentSpec} />\r\n      <Accordion>\r\n        <AccordionSummary>Summary</AccordionSummary>\r\n      </Accordion>\r\n      <button onClick={(e) => {setIsDialogOpen(true)}}>Show dialog</button>\r\n      <Dialog\r\n        //open={open}\r\n        open={isDialogOpen}\r\n        //onClose={handleClose}\r\n        aria-labelledby=\"alert-dialog-title\"\r\n        aria-describedby=\"alert-dialog-description\"\r\n      >\r\n        <DialogTitle id=\"alert-dialog-title\">\r\n          {\"Do something?\"}\r\n        </DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText id=\"alert-dialog-description\">\r\n              foo bar\r\n          </DialogContentText>\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button color=\"primary\" onClick={(e) => setIsDialogOpen(false)}>Disagree</Button>\r\n          <Button color=\"primary\" onClick={(e) => setIsDialogOpen(false)} autoFocus>\r\n            Agree\r\n          </Button>\r\n        </DialogActions>\r\n      </Dialog>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default DebugScratch;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport yaml from \"js-yaml\";\r\nimport localForage from \"localforage\";\r\n\r\nimport {\r\n  ComponentSpec,\r\n  ComponentReference,\r\n  isValidComponentSpec,\r\n} from \"./componentSpec\";\r\n\r\n// IndexedDB: DB and table names\r\nconst DB_NAME = \"components\";\r\nconst DIGEST_TO_DATA_DB_TABLE_NAME = \"digest_to_component_data\";\r\nconst DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME = \"digest_to_component_spec\";\r\nconst DIGEST_TO_COMPONENT_NAME_DB_TABLE_NAME = \"digest_to_component_name\";\r\nconst URL_TO_DIGEST_DB_TABLE_NAME = \"url_to_digest\";\r\nconst DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME = \"digest_to_canonical_url\";\r\nconst COMPONENT_REF_LISTS_DB_TABLE_NAME = \"component_ref_lists\";\r\nconst COMPONENT_STORE_SETTINGS_DB_TABLE_NAME = \"component_store_settings\";\r\nconst FILE_STORE_DB_TABLE_NAME_PREFIX = \"file_store_\";\r\n\r\nexport interface ComponentReferenceWithSpec extends ComponentReference {\r\n  spec: ComponentSpec;\r\n  digest: string;\r\n}\r\n\r\nexport interface ComponentReferenceWithSpecPlusData {\r\n  componentRef: ComponentReferenceWithSpec;\r\n  data: ArrayBuffer;\r\n}\r\n\r\nconst calculateHashDigestHex = async (data: string | ArrayBuffer) => {\r\n  const dataBytes =\r\n    typeof data === \"string\" ? new TextEncoder().encode(data) : data;\r\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", dataBytes);\r\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n  const hashHex = hashArray\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\");\r\n  return hashHex;\r\n};\r\n\r\nconst storeComponentSpec = async (\r\n  digest: string,\r\n  componentSpec: ComponentSpec\r\n) => {\r\n  const digestToComponentSpecDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME,\r\n  });\r\n  const digestToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  await digestToComponentSpecDb.setItem(digest, componentSpec);\r\n  if (componentSpec.name !== undefined) {\r\n    await digestToComponentNameDb.setItem(digest, componentSpec.name);\r\n  }\r\n};\r\n\r\nexport const loadComponentAsRefFromText = async (\r\n  componentText: string | ArrayBuffer\r\n) => {\r\n  const componentString =\r\n    typeof componentText === \"string\"\r\n      ? componentText\r\n      : new TextDecoder().decode(componentText);\r\n  const componentBytes =\r\n    typeof componentText === \"string\"\r\n      ? new TextEncoder().encode(componentText)\r\n      : componentText;\r\n\r\n  const loadedObj = yaml.load(componentString);\r\n  if (typeof loadedObj !== \"object\" || loadedObj === null) {\r\n    throw Error(`componentText is not a YAML-encoded object: ${loadedObj}`);\r\n  }\r\n  if (!isValidComponentSpec(loadedObj)) {\r\n    throw Error(\r\n      `componentText does not encode a valid pipeline component: ${loadedObj}`\r\n    );\r\n  }\r\n  const componentSpec: ComponentSpec = loadedObj;\r\n\r\n  const digest = await calculateHashDigestHex(componentBytes);\r\n  const componentRef: ComponentReferenceWithSpec = {\r\n    spec: componentSpec,\r\n    digest: digest,\r\n  };\r\n  const componentRefPlusData: ComponentReferenceWithSpecPlusData = {\r\n    componentRef: componentRef,\r\n    data: componentBytes,\r\n  };\r\n  return componentRefPlusData;\r\n};\r\n\r\nexport const loadComponentAsRefFromUrl = async (url: string) => {\r\n  const response = await fetch(url);\r\n  const componentData = await response.arrayBuffer();\r\n  let componentRefPlusData = await loadComponentAsRefFromText(componentData);\r\n  componentRefPlusData.componentRef.url = url;\r\n  return componentRefPlusData;\r\n};\r\n\r\nexport const storeComponentText = async (\r\n  componentText: string | ArrayBuffer\r\n) => {\r\n  const componentBytes =\r\n    typeof componentText === \"string\"\r\n      ? new TextEncoder().encode(componentText)\r\n      : componentText;\r\n  const componentRefPlusData = await loadComponentAsRefFromText(componentText);\r\n  const digestToComponentTextDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_DATA_DB_TABLE_NAME,\r\n  });\r\n  const componentRef = componentRefPlusData.componentRef;\r\n  await digestToComponentTextDb.setItem(\r\n    componentRefPlusData.componentRef.digest,\r\n    componentBytes\r\n  );\r\n  await storeComponentSpec(componentRef.digest, componentRef.spec);\r\n\r\n  return componentRefPlusData;\r\n};\r\n\r\nexport const getAllComponentsAsRefs = async () => {\r\n  const digestToComponentSpecDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME,\r\n  });\r\n\r\n  // TODO: Rewrite as async generator\r\n  let digestToComponentRef = new Map<string, ComponentReferenceWithSpec>();\r\n  await digestToComponentSpecDb.iterate<ComponentSpec, void>(\r\n    (componentSpec, digest, iterationNumber) => {\r\n      const componentRef: ComponentReferenceWithSpec = {\r\n        spec: componentSpec,\r\n        digest: digest,\r\n      };\r\n      digestToComponentRef.set(digest, componentRef);\r\n    }\r\n  );\r\n  await addCanonicalUrlsToComponentReferences(digestToComponentRef);\r\n\r\n  const componentRefs = Array.from(digestToComponentRef.values());\r\n  return componentRefs;\r\n};\r\n\r\nconst addCanonicalUrlsToComponentReferences = async (\r\n  digestToComponentRef: Map<string, ComponentReference>\r\n) => {\r\n  const digestToCanonicalUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME,\r\n  });\r\n  await digestToCanonicalUrlDb.iterate<string, void>(\r\n    (url, digest, iterationNumber) => {\r\n      let componentRef = digestToComponentRef.get(digest);\r\n      if (componentRef === undefined) {\r\n        console.error(\r\n          `Component db corrupted: Component with url ${url} and digest ${digest} has no content in the DB.`\r\n        );\r\n      } else {\r\n        componentRef.url = url;\r\n      }\r\n    }\r\n  );\r\n};\r\n\r\nexport const searchComponentsByName = async (name: string) => {\r\n  const componentRefs = await getAllComponentsAsRefs();\r\n  return componentRefs.filter(\r\n    (ref) => ref.spec.name?.toLowerCase().includes(name.toLowerCase()) ?? false\r\n  );\r\n};\r\n\r\nexport const storeComponentFromUrl = async (\r\n  url: string,\r\n  setUrlAsCanonical = false\r\n) => {\r\n  const urlToDigestDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_TO_DIGEST_DB_TABLE_NAME,\r\n  });\r\n  const digestToComponentSpecDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME,\r\n  });\r\n  const digestToDataDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_DATA_DB_TABLE_NAME,\r\n  });\r\n\r\n  const existingDigest = await urlToDigestDb.getItem<string>(url);\r\n  if (existingDigest !== null) {\r\n    const componentSpec = await digestToComponentSpecDb.getItem<ComponentSpec>(\r\n      existingDigest\r\n    );\r\n    const componentData = await digestToDataDb.getItem<ArrayBuffer>(\r\n      existingDigest\r\n    );\r\n    if (componentSpec !== null && componentData !== null) {\r\n      const componentRef: ComponentReferenceWithSpec = {\r\n        url: url,\r\n        digest: existingDigest,\r\n        spec: componentSpec,\r\n      };\r\n      const componentRefPlusData: ComponentReferenceWithSpecPlusData = {\r\n        componentRef: componentRef,\r\n        data: componentData,\r\n      };\r\n      return componentRefPlusData;\r\n    } else {\r\n      console.error(\r\n        `Component db is corrupted: Component with url ${url} was added before with digest ${existingDigest} but now has no content in the DB.`\r\n      );\r\n    }\r\n  }\r\n\r\n  const response = await fetch(url);\r\n  const componentData = await response.arrayBuffer();\r\n  let componentRefPlusData = await storeComponentText(componentData);\r\n  let componentRef = componentRefPlusData.componentRef;\r\n  componentRef.url = url;\r\n  const digest = componentRef.digest;\r\n  if (digest === undefined) {\r\n    console.error(\r\n      `Cannot happen: storeComponentText has returned componentReference with digest === undefined.`\r\n    );\r\n    return componentRefPlusData;\r\n  }\r\n  if (existingDigest !== null && digest !== existingDigest) {\r\n    console.error(\r\n      `Component db is corrupted: Component with url ${url} previously had digest ${existingDigest} but now has digest ${digest}.`\r\n    );\r\n  }\r\n  const digestToCanonicalUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME,\r\n  });\r\n  const existingCanonicalUrl = await digestToCanonicalUrlDb.getItem<string>(\r\n    digest\r\n  );\r\n  if (existingCanonicalUrl === null) {\r\n    await digestToCanonicalUrlDb.setItem(digest, url);\r\n  } else {\r\n    if (url !== existingCanonicalUrl) {\r\n      console.debug(\r\n        `The component with digest \"${digest}\" is being loaded from \"${url}\", but was previously loaded from \"${existingCanonicalUrl}\".` +\r\n          (setUrlAsCanonical ? \" Changing the canonical url.\" : \"\")\r\n      );\r\n      if (setUrlAsCanonical) {\r\n        await digestToCanonicalUrlDb.setItem(digest, url);\r\n      }\r\n    }\r\n  }\r\n  // Updating the urlToDigestDb last, because it's used to check for cached entries.\r\n  // So we need to be sure that everything has been updated correctly.\r\n  await urlToDigestDb.setItem(url, digest);\r\n  return componentRefPlusData;\r\n};\r\n\r\ninterface ComponentFileEntryV2 {\r\n  componentRef: ComponentReferenceWithSpec;\r\n}\r\n\r\ninterface FileEntry {\r\n  name: string;\r\n  creationTime: Date;\r\n  modificationTime: Date;\r\n  data: ArrayBuffer;\r\n}\r\n\r\ninterface ComponentFileEntryV3\r\n  extends FileEntry,\r\n    ComponentReferenceWithSpecPlusData {}\r\n\r\nexport type ComponentFileEntry = ComponentFileEntryV3;\r\n\r\nconst makeNameUniqueByAddingIndex = (\r\n  name: string,\r\n  existingNames: Set<string>\r\n): string => {\r\n  let finalName = name;\r\n  let index = 1;\r\n  while (existingNames.has(finalName)) {\r\n    index++;\r\n    finalName = name + \" \" + index.toString();\r\n  }\r\n  return finalName;\r\n};\r\n\r\nconst writeComponentRefPlusDataToFile = async (\r\n  listName: string,\r\n  fileName: string,\r\n  componentRefPlusData: ComponentReferenceWithSpecPlusData\r\n) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  const existingFile = await componentListDb.getItem<ComponentFileEntry>(\r\n    fileName\r\n  );\r\n  const currentTime = new Date();\r\n  let fileEntry: ComponentFileEntry;\r\n  if (existingFile === null) {\r\n    fileEntry = {\r\n      componentRef: componentRefPlusData.componentRef,\r\n      name: fileName,\r\n      creationTime: currentTime,\r\n      modificationTime: currentTime,\r\n      data: componentRefPlusData.data,\r\n    };\r\n  } else {\r\n    fileEntry = {\r\n      ...existingFile,\r\n      name: fileName,\r\n      modificationTime: currentTime,\r\n      data: componentRefPlusData.data,\r\n      componentRef: componentRefPlusData.componentRef,\r\n    };\r\n  }\r\n  await componentListDb.setItem(fileName, fileEntry);\r\n  return fileEntry;\r\n};\r\n\r\nconst addComponentRefPlusDataToList = async (\r\n  listName: string,\r\n  componentRefPlusData: ComponentReferenceWithSpecPlusData,\r\n  fileName: string = \"Component\"\r\n) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  const existingNames = new Set<string>(await componentListDb.keys());\r\n  const uniqueFileName = makeNameUniqueByAddingIndex(fileName, existingNames);\r\n  return writeComponentRefPlusDataToFile(\r\n    listName,\r\n    uniqueFileName,\r\n    componentRefPlusData\r\n  );\r\n};\r\n\r\nexport const addComponentToListByUrl = async (\r\n  listName: string,\r\n  url: string,\r\n  defaultFileName: string = \"Component\"\r\n) => {\r\n  const componentRefPlusData = await storeComponentFromUrl(url);\r\n  return addComponentRefPlusDataToList(\r\n    listName,\r\n    componentRefPlusData,\r\n    componentRefPlusData.componentRef.spec.name ?? defaultFileName\r\n  );\r\n};\r\n\r\nexport const addComponentToListByText = async (\r\n  listName: string,\r\n  componentText: string | ArrayBuffer,\r\n  fileName?: string,\r\n  defaultFileName: string = \"Component\"\r\n) => {\r\n  const componentRefPlusData = await storeComponentText(componentText);\r\n  return addComponentRefPlusDataToList(\r\n    listName,\r\n    componentRefPlusData,\r\n    fileName ?? componentRefPlusData.componentRef.spec.name ?? defaultFileName\r\n  );\r\n};\r\n\r\nexport const writeComponentToFileListFromText = async (\r\n  listName: string,\r\n  fileName: string,\r\n  componentText: string | ArrayBuffer\r\n) => {\r\n  const componentRefPlusData = await storeComponentText(componentText);\r\n  return writeComponentRefPlusDataToFile(\r\n    listName,\r\n    fileName,\r\n    componentRefPlusData\r\n  );\r\n};\r\n\r\nexport const getAllComponentsFromList = async (listName: string) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  let componentRefs: ComponentReferenceWithSpec[] = [];\r\n  await componentListDb.iterate<ComponentFileEntry, void>(\r\n    (fileEntry, fileName, iterationNumber) => {\r\n      componentRefs.push(fileEntry.componentRef);\r\n    }\r\n  );\r\n  return componentRefs;\r\n};\r\n\r\nexport const getAllComponentFilesFromList = async (listName: string) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  let componentFiles = new Map<string, ComponentFileEntry>();\r\n  await componentListDb.iterate<ComponentFileEntry, void>(\r\n    (fileEntry, fileName, iterationNumber) => {\r\n      componentFiles.set(fileName, fileEntry);\r\n    }\r\n  );\r\n  return componentFiles;\r\n};\r\n\r\nexport const getComponentFileFromList = async (\r\n  listName: string,\r\n  fileName: string\r\n) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  return componentListDb.getItem<ComponentFileEntry>(fileName);\r\n};\r\n\r\nexport const deleteComponentFileFromList = async (\r\n  listName: string,\r\n  fileName: string\r\n) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  return componentListDb.removeItem(fileName);\r\n};\r\n\r\nexport const unsafeWriteFilesToList = async (listName: string, files: ComponentFileEntry[]) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  for (const file of files) {\r\n    await componentListDb.setItem(file.name, file);\r\n  }\r\n};\r\n\r\nexport const componentSpecToYaml = (componentSpec: ComponentSpec) => {\r\n  return yaml.dump(componentSpec, { lineWidth: 10000 });\r\n};\r\n\r\n// TODO: Remove the upgrade code in several weeks.\r\nconst upgradeSingleComponentListDb = async (listName: string) => {\r\n  const componentListVersionKey = \"component_list_format_version_\" + listName;\r\n  const componentStoreSettingsDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: COMPONENT_STORE_SETTINGS_DB_TABLE_NAME,\r\n  });\r\n  const componentListTableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: componentListTableName,\r\n  });\r\n  let listFormatVersion =\r\n    (await componentStoreSettingsDb.getItem<number>(componentListVersionKey)) ??\r\n    1;\r\n  if (![1, 2, 3].includes(listFormatVersion)) {\r\n    throw Error(\r\n      `upgradeComponentListDb: Unknown component list version \"${listFormatVersion}\" for the list ${listName}`\r\n    );\r\n  }\r\n  if (listFormatVersion === 1) {\r\n    console.log(`componentStore: Upgrading the component list DB ${listName}`);\r\n    const componentRefListsDb = localForage.createInstance({\r\n      name: DB_NAME,\r\n      storeName: COMPONENT_REF_LISTS_DB_TABLE_NAME,\r\n    });\r\n    const componentRefList: ComponentReferenceWithSpec[] =\r\n      (await componentRefListsDb.getItem(listName)) ?? [];\r\n\r\n    let existingNames = new Set<string>();\r\n    const emptyNameReplacement =\r\n      listName === \"user_pipelines\" ? \"Pipeline\" : \"Component\";\r\n    for (const componentRef of componentRefList) {\r\n      const fileName = componentRef.spec.name ?? emptyNameReplacement;\r\n      const uniqueFileName = makeNameUniqueByAddingIndex(\r\n        fileName,\r\n        existingNames\r\n      );\r\n      const fileEntry: ComponentFileEntryV2 = {\r\n        componentRef: componentRef,\r\n      };\r\n      await componentListDb.setItem(uniqueFileName, fileEntry);\r\n      existingNames.add(uniqueFileName);\r\n    }\r\n    await componentStoreSettingsDb.setItem(componentListVersionKey, 2);\r\n    listFormatVersion = 2;\r\n    console.log(\r\n      `componentStore: Upgraded the component list DB ${listName} to version ${listFormatVersion}`\r\n    );\r\n  }\r\n  if (listFormatVersion === 2) {\r\n    const digestToDataDb = localForage.createInstance({\r\n      name: DB_NAME,\r\n      storeName: DIGEST_TO_DATA_DB_TABLE_NAME,\r\n    });\r\n    const fileNames = await componentListDb.keys();\r\n    for (const fileName of fileNames) {\r\n      const fileEntry = await componentListDb.getItem<ComponentFileEntryV2>(\r\n        fileName\r\n      );\r\n      if (fileEntry === null) {\r\n        throw Error(`File \"${fileName}\" has disappeared during upgrade`);\r\n      }\r\n      let componentRef = fileEntry.componentRef;\r\n      let data = await digestToDataDb.getItem<ArrayBuffer>(\r\n        fileEntry.componentRef.digest\r\n      );\r\n      if (data === null) {\r\n        console.error(\r\n          `Db is corrupted: Could not find data for file \"${fileName}\" with digest ${fileEntry.componentRef.digest}.`\r\n        );\r\n        const componentText = componentSpecToYaml(fileEntry.componentRef.spec);\r\n        data = new TextEncoder().encode(componentText);\r\n        const newDigest = await calculateHashDigestHex(data);\r\n        componentRef.digest = newDigest;\r\n        console.warn(\r\n          `The component \"${fileName}\" was re-serialized. Old digest: ${fileEntry.componentRef.digest}. New digest ${newDigest}.`\r\n        );\r\n        // This case should not happen. Let's throw error for now.\r\n        throw Error(\r\n          `Db is corrupted: Could not find data for file \"${fileName}\" with digest ${fileEntry.componentRef.digest}.`\r\n        );\r\n      }\r\n      const currentTime = new Date();\r\n      const newFileEntry: ComponentFileEntryV3 = {\r\n        name: fileName,\r\n        creationTime: currentTime,\r\n        modificationTime: currentTime,\r\n        data: data,\r\n        componentRef: componentRef,\r\n      };\r\n      await componentListDb.setItem(fileName, newFileEntry);\r\n    }\r\n    listFormatVersion = 3;\r\n    await componentStoreSettingsDb.setItem(\r\n      componentListVersionKey,\r\n      listFormatVersion\r\n    );\r\n    console.log(\r\n      `componentStore: Upgraded the component list DB ${listName} to version ${listFormatVersion}`\r\n    );\r\n  }\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nexport type MySchema = ComponentSpec;\r\nexport type TypeSpecType =\r\n  | string\r\n  | {\r\n      [k: string]: TypeSpecType;\r\n    };\r\nexport interface InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the component input specification\r\n */\r\nexport interface InputSpec extends InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  default?: string;\r\n  optional?: boolean;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the component output specification\r\n */\r\nexport interface OutputSpec extends InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by the input argument value.\r\n */\r\nexport interface InputValuePlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  inputValue: string;\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a local file path pointing to a file containing the input argument value.\r\n */\r\nexport interface InputPathPlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  inputPath: string;\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a local file path pointing to a file where the program should write its output data.\r\n */\r\nexport interface OutputPathPlaceholder {\r\n  /**\r\n   * Name of the output.\r\n   */\r\n  outputPath: string;\r\n}\r\nexport type StringOrPlaceholder =\r\n  | string\r\n  | InputValuePlaceholder\r\n  | InputPathPlaceholder\r\n  | OutputPathPlaceholder\r\n  | ConcatPlaceholder\r\n  | IfPlaceholder;\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by the concatenated values of its items.\r\n */\r\nexport interface ConcatPlaceholder {\r\n  /**\r\n   * Items to concatenate\r\n   */\r\n  concat: StringOrPlaceholder[];\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a boolean value specifying whether the caller has passed an argument for the specified optional input.\r\n */\r\nexport interface IsPresentPlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  isPresent: string;\r\n}\r\nexport type IfConditionArgumentType =\r\n  | IsPresentPlaceholder\r\n  | boolean\r\n  | string\r\n  | InputValuePlaceholder;\r\nexport type ListOfStringsOrPlaceholders = StringOrPlaceholder[];\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a boolean value specifying whether the caller has passed an argument for the specified optional input.\r\n */\r\nexport interface IfPlaceholder {\r\n  if: {\r\n    cond: IfConditionArgumentType;\r\n    then: ListOfStringsOrPlaceholders;\r\n    else?: ListOfStringsOrPlaceholders;\r\n  };\r\n}\r\nexport interface ContainerSpec {\r\n  /**\r\n   * Docker image name.\r\n   */\r\n  image: string;\r\n  /**\r\n   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided.\r\n   */\r\n  command?: StringOrPlaceholder[];\r\n  /**\r\n   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided.\r\n   */\r\n  args?: StringOrPlaceholder[];\r\n  /**\r\n   * List of environment variables to set in the container.\r\n   */\r\n  env?: {\r\n    [k: string]: StringOrPlaceholder;\r\n  };\r\n}\r\n/**\r\n * Represents the container component implementation.\r\n */\r\nexport interface ContainerImplementation {\r\n  container: ContainerSpec;\r\n}\r\nexport type ImplementationType = ContainerImplementation | GraphImplementation;\r\nexport interface MetadataSpec {\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Component specification. Describes the metadata (name, description, source), the interface (inputs and outputs) and the implementation of the component.\r\n */\r\nexport interface ComponentSpec {\r\n  name?: string;\r\n  description?: string;\r\n  inputs?: InputSpec[];\r\n  outputs?: OutputSpec[];\r\n  implementation: ImplementationType;\r\n  metadata?: MetadataSpec;\r\n}\r\n/**\r\n * Component reference. Contains information that can be used to locate and load a component by name, digest or URL\r\n */\r\nexport interface ComponentReference {\r\n  name?: string;\r\n  digest?: string;\r\n  tag?: string;\r\n  url?: string;\r\n  spec?: ComponentSpec;\r\n}\r\n/**\r\n * Represents the component argument value that comes from the graph component input.\r\n */\r\nexport interface GraphInputArgument {\r\n  /**\r\n   * References the input of the graph/pipeline.\r\n   */\r\n  graphInput: {\r\n    inputName: string;\r\n    type?: TypeSpecType;\r\n  };\r\n}\r\n/**\r\n * Represents the component argument value that comes from the output of a sibling task.\r\n */\r\nexport interface TaskOutputArgument {\r\n  /**\r\n   * References the output of a sibling task.\r\n   */\r\n  taskOutput: {\r\n    taskId: string;\r\n    outputName: string;\r\n    type?: TypeSpecType;\r\n  };\r\n}\r\nexport type ArgumentType = string | GraphInputArgument | TaskOutputArgument;\r\n/**\r\n * Pair of operands for a binary operation.\r\n */\r\nexport interface TwoArgumentOperands {\r\n  op1: ArgumentType;\r\n  op2: ArgumentType;\r\n}\r\n/**\r\n * Pair of operands for a binary logical operation.\r\n */\r\nexport interface TwoLogicalOperands {\r\n  op1: PredicateType;\r\n  op2: PredicateType;\r\n}\r\n/**\r\n * Optional configuration that specifies how the task should be executed. Can be used to set some platform-specific options.\r\n */\r\nexport type PredicateType =\r\n  | {\r\n      \"==\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"!=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \">\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \">=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"<\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"<=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      and: TwoLogicalOperands;\r\n    }\r\n  | {\r\n      or: TwoLogicalOperands;\r\n    }\r\n  | {\r\n      not: PredicateType;\r\n    };\r\n\r\n/**\r\n * Optional configuration that specifies how the task should be retried if it fails.\r\n */\r\nexport interface RetryStrategySpec {\r\n  maxRetries?: number;\r\n}\r\n/**\r\n * Optional configuration that specifies how the task execution may be skipped if the output data exist in cache.\r\n */\r\nexport interface CachingStrategySpec {\r\n  maxCacheStaleness?: string;\r\n}\r\n\r\nexport interface ExecutionOptionsSpec {\r\n  retryStrategy?: RetryStrategySpec;\r\n  cachingStrategy?: CachingStrategySpec;\r\n}\r\n/**\r\n * 'Task specification. Task is a configured component - a component supplied with arguments and other applied configuration changes.\r\n */\r\nexport interface TaskSpec {\r\n  componentRef: ComponentReference;\r\n  arguments?: {\r\n    [k: string]: ArgumentType;\r\n  };\r\n  isEnabled?: PredicateType;\r\n  executionOptions?: ExecutionOptionsSpec;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the graph component implementation. It represents a graph of component tasks connected to the upstream sources of data using the argument specifications. It also describes the sources of graph output values.\r\n */\r\nexport interface GraphSpec {\r\n  tasks: {\r\n    [k: string]: TaskSpec;\r\n  };\r\n  outputValues?: {\r\n    [k: string]: TaskOutputArgument;\r\n  };\r\n}\r\n/**\r\n * Represents the graph component implementation.\r\n */\r\nexport interface GraphImplementation {\r\n  graph: GraphSpec;\r\n}\r\n\r\n// Type guards\r\nexport const isValidComponentSpec = (obj: any): obj is ComponentSpec =>\r\n  typeof obj === \"object\" && \"implementation\" in obj;\r\n\r\nexport const isContainerImplementation = (\r\n  implementation: ImplementationType\r\n): implementation is ContainerImplementation => \"container\" in implementation;\r\n\r\nexport const isGraphImplementation = (\r\n  implementation: ImplementationType\r\n): implementation is GraphImplementation => \"graph\" in implementation;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { downloadComponentDataWithCache } from \"../github\";\r\n\r\nconst TFX_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipelines/2765b13699ac28de523f499eeaa9eb2ed9b8798a/components/deprecated/tfx/_samples/TFX.pipeline.component.yaml\"\r\nconst XGBOOST_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipelines/2edfd25b5ee3a4aa149c24a225a50041fbd3662d/components/XGBoost/_samples/sample_pipeline.pipeline.component.yaml\"\r\nconst PYTORCH_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipelines/237cd6bc0b6db26f615c22897be20aad77270b50/components/PyTorch/_samples/Train_fully-connected_network.pipeline.component.yaml\"\r\nconst VERTEX_AI_AUTOML_TABLES_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipeline_components/44b0543525ab6149ce995a411f88997e7131a53d/components/google-cloud/Vertex_AI/AutoML/Tables/_samples/VertexAI.AutoML.Tables.pipeline.component.yaml\"\r\nexport const DATA_PASSING_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipelines/b45c82e42588ee0a86b8875d1908d972275bfd2f/samples/test/data_passing.pipeline.component.yaml\"\r\nexport const GOOGLE_CLOUD_OPTIMIZER_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipeline_components/84e782224ff79a0690e84e7d66c93cec5089e041/components/google-cloud/Optimizer/_samples/Optimization.pipeline.component.yaml\"\r\n\r\nexport const PRELOADED_PIPELINE_URLS = [\r\n  XGBOOST_PIPELINE_URL,\r\n  PYTORCH_PIPELINE_URL,\r\n  VERTEX_AI_AUTOML_TABLES_PIPELINE_URL,\r\n  TFX_PIPELINE_URL,\r\n];\r\n\r\nconst preloadComponentReferences = async (\r\n  componentSpec: ComponentSpec,\r\n  componentMap?: Map<string, ComponentSpec>\r\n) => {\r\n  // This map is needed to improve efficiency and handle recursive components.\r\n  if (componentMap === undefined) {\r\n    componentMap = new Map<string, ComponentSpec>();\r\n  }\r\n  if (\"graph\" in componentSpec.implementation) {\r\n    for (const taskSpec of Object.values(\r\n      componentSpec.implementation.graph.tasks\r\n    )) {\r\n      const componentUrl = taskSpec.componentRef.url;\r\n      if (\r\n        taskSpec.componentRef.spec === undefined &&\r\n        componentUrl !== undefined\r\n      ) {\r\n        let taskComponentSpec = componentMap.get(componentUrl);\r\n        if (taskComponentSpec === undefined) {\r\n          taskComponentSpec = await downloadComponentDataWithCache(\r\n            componentUrl\r\n          );\r\n          componentMap.set(componentUrl, taskComponentSpec);\r\n        }\r\n        taskSpec.componentRef.spec = taskComponentSpec;\r\n        await preloadComponentReferences(taskComponentSpec, componentMap);\r\n      }\r\n    }\r\n  }\r\n  return componentSpec;\r\n};\r\n\r\nconst loadComponentFromUrl = async (\r\n  url: string,\r\n  preloadChildComponentSpecs = true\r\n) => {\r\n  let componentSpec = await downloadComponentDataWithCache(url);\r\n  if (preloadChildComponentSpecs) {\r\n    componentSpec = await preloadComponentReferences(componentSpec);\r\n  }\r\n  return componentSpec;\r\n};\r\n\r\nexport { loadComponentFromUrl, preloadComponentReferences, XGBOOST_PIPELINE_URL, PYTORCH_PIPELINE_URL, TFX_PIPELINE_URL };\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useState } from \"react\";\r\nimport { ArgumentType, TaskSpec } from \"../componentSpec\";\r\nimport ArgumentsEditor from \"./ArgumentsEditor\";\r\n\r\ninterface ArgumentsEditorDialogProps {\r\n  taskSpec: TaskSpec;\r\n  closeEditor?: () => void;\r\n  setArguments?: (args: Record<string, ArgumentType>) => void;\r\n}\r\n\r\nconst ArgumentsEditorDialog = ({\r\n  taskSpec,\r\n  closeEditor,\r\n  setArguments,\r\n}: ArgumentsEditorDialogProps) => {\r\n  const [currentArguments, setCurrentArguments] = useState<\r\n    Record<string, ArgumentType>\r\n  >({ ...taskSpec.arguments });\r\n\r\n  const componentSpec = taskSpec.componentRef.spec;\r\n  if (componentSpec === undefined) {\r\n    console.error(\r\n      \"ArgumentsEditor called with missing taskSpec.componentRef.spec\",\r\n      taskSpec\r\n    );\r\n    return <></>;\r\n  }\r\n\r\n  return (\r\n    <form\r\n      onSubmit={async (e) => {\r\n        e.preventDefault();\r\n      }}\r\n      // Does not work\r\n      // draggable={false}\r\n      style={{\r\n        position: \"fixed\",\r\n        background: \"white\",\r\n        border: \"1px solid black\",\r\n        borderRadius: \"4px\",\r\n        padding: \"15px\",\r\n        // Does not work\r\n        // zIndex: 11,\r\n      }}\r\n    >\r\n      <legend>Input arguments for {componentSpec.name}</legend>\r\n      <ArgumentsEditor\r\n        componentSpec={componentSpec}\r\n        componentArguments={currentArguments}\r\n        setComponentArguments={setCurrentArguments}\r\n      />\r\n      <button type=\"button\" onClick={closeEditor}>\r\n        Close\r\n      </button>\r\n      <button\r\n        type=\"button\"\r\n        onClick={(e) => {\r\n          setArguments?.(currentArguments);\r\n          closeEditor?.();\r\n        }}\r\n      >\r\n        Apply\r\n      </button>\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default ArgumentsEditorDialog;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { CSSProperties, memo, useState } from 'react';\r\nimport {\r\n  ArgumentType,\r\n  InputSpec,\r\n  OutputSpec,\r\n  TaskSpec,\r\n} from '../componentSpec';\r\n\r\nimport { Handle, Position, Node, NodeProps, HandleType } from 'react-flow-renderer';\r\n\r\nimport ArgumentsEditorDialog from './ArgumentsEditorDialog';\r\n\r\nconst inputHandlePosition = Position.Top;\r\nconst outputHandlePosition = Position.Bottom;\r\n\r\ntype InputOrOutputSpec = InputSpec | OutputSpec;\r\n\r\nconst MISSING_ARGUMENT_CLASS_NAME = \"missing-argument\";\r\n\r\nconst NODE_WIDTH_IN_PX = 180;\r\n\r\nexport const isComponentTaskNode = (node: Node): node is Node<ComponentTaskNodeProps> =>\r\n  node.type === \"task\" && node.data !== undefined && \"taskSpec\" in node.data;\r\n\r\nfunction generateHandles(\r\n  ioSpecs: InputOrOutputSpec[],\r\n  handleType: HandleType,\r\n  position: Position,\r\n  idPrefix: string,\r\n  inputsWithMissingArguments?: string[],\r\n): JSX.Element[] {\r\n  let handleComponents = [];\r\n  const numHandles = ioSpecs.length;\r\n  for (let i = 0; i < numHandles; i++) {\r\n    const ioSpec = ioSpecs[i];\r\n    const id = idPrefix + ioSpec.name;\r\n    const relativePosition = (i + 1) / (numHandles + 1);\r\n    const positionPercentString = String(100 * relativePosition) + \"%\";\r\n    const style =\r\n      position === Position.Top || position === Position.Bottom\r\n        ? { left: positionPercentString }\r\n        : { top: positionPercentString };\r\n    // TODO: Handle complex type specs\r\n    const ioTypeName = ioSpec.type?.toString() ?? \"Any\";\r\n    let classNames = [`handle_${idPrefix}${ioTypeName}`.replace(\" \", \"_\")];\r\n    const isInvalid = (inputsWithMissingArguments ?? []).includes(ioSpec.name);\r\n    if (isInvalid) {\r\n      classNames.push(MISSING_ARGUMENT_CLASS_NAME);\r\n    }\r\n    classNames = classNames.map((className) => className.replace(\" \", \"_\"));\r\n\r\n    const [labelClasses, labelStyle] = generateLabelStyle(position, numHandles);\r\n    handleComponents.push(\r\n      <Handle\r\n        key={id}\r\n        type={handleType}\r\n        position={position}\r\n        id={id}\r\n        style={style}\r\n        isConnectable={true}\r\n        title={ioSpec.name + \" : \" + ioTypeName}\r\n        className={classNames.join(\" \")}\r\n      >\r\n        <div className={labelClasses} style={labelStyle}>\r\n          {ioSpec.name}\r\n        </div>\r\n      </Handle>\r\n    );\r\n  }\r\n  return handleComponents;\r\n}\r\n\r\n\r\nfunction generateLabelStyle(\r\n  position: Position,\r\n  numHandles: number\r\n): [string, CSSProperties] {\r\n  let maxLabelWidthPx = NODE_WIDTH_IN_PX;\r\n  // By default, we want to place the label on the same side of the handle as the handle is on the side of the node.\r\n  let labelClasses = \"label\";\r\n  // When there are too many inputs/outputs, we need to move the label so it starts from the handle.\r\n  // Based on my tests, we always want this for >4 handles (top/bottom), so the rotated default placement is never used at all.\r\n\r\n  if (position === Position.Top || position === Position.Bottom) {\r\n    if (numHandles > 1) {\r\n      // For single handle max width is the node width, while the formula would give half of that\r\n      maxLabelWidthPx = NODE_WIDTH_IN_PX / (numHandles + 1);\r\n    }\r\n    //if (numHandles > 4) {\r\n    if (maxLabelWidthPx < 35) {\r\n      maxLabelWidthPx = 50;\r\n      labelClasses += \" label-angled\";\r\n    }\r\n  } else {\r\n    maxLabelWidthPx = 60;\r\n  }\r\n\r\n  const labelStyle: CSSProperties = { maxWidth: `${maxLabelWidthPx}px` };\r\n  return [labelClasses, labelStyle];\r\n}\r\n\r\nfunction generateInputHandles(inputSpecs: InputSpec[], inputsWithInvalidArguments?: string[]): JSX.Element[] {\r\n  return generateHandles(inputSpecs, \"target\", inputHandlePosition, \"input_\", inputsWithInvalidArguments);\r\n}\r\n\r\nfunction generateOutputHandles(outputSpecs: OutputSpec[]): JSX.Element[] {\r\n  return generateHandles(outputSpecs, \"source\", outputHandlePosition, \"output_\");\r\n}\r\n\r\nexport interface ComponentTaskNodeProps {\r\n  taskSpec: TaskSpec,\r\n  taskId?: string,\r\n  setArguments?: (args: Record<string, ArgumentType>) => void;\r\n};\r\n\r\nconst ComponentTaskNode = ({ data }: NodeProps<ComponentTaskNodeProps>) => {\r\n  const [isArgumentsEditorOpen, setIsArgumentsEditorOpen] = useState(false);\r\n\r\n  const taskSpec = data.taskSpec;\r\n  const componentSpec = taskSpec.componentRef.spec;\r\n  if (componentSpec === undefined) {\r\n    return (<></>);\r\n  }\r\n\r\n  const label = componentSpec.name ?? \"<component>\";\r\n  const inputsWithInvalidArguments = (componentSpec.inputs ?? [])\r\n    .filter(\r\n      (inputSpec) =>\r\n        inputSpec.optional !== true &&\r\n        inputSpec.default === undefined &&\r\n        !(inputSpec.name in (taskSpec.arguments ?? {}))\r\n    )\r\n    .map((inputSpec) => inputSpec.name);\r\n  const inputHandles = generateInputHandles(componentSpec.inputs ?? [], inputsWithInvalidArguments);\r\n  const outputHandles = generateOutputHandles(componentSpec.outputs ?? []);\r\n  const handleComponents = inputHandles.concat(outputHandles);\r\n\r\n  const closeArgumentsEditor = () => {\r\n    setIsArgumentsEditorOpen(false);\r\n  }\r\n\r\n  return (\r\n    <div\r\n      onDoubleClick={() => {\r\n        setIsArgumentsEditorOpen(!isArgumentsEditorOpen);\r\n      }}\r\n      title={data.taskId}\r\n    >\r\n      {label}\r\n      {handleComponents}\r\n      {isArgumentsEditorOpen && (\r\n        <ArgumentsEditorDialog\r\n          taskSpec={taskSpec}\r\n          closeEditor={closeArgumentsEditor}\r\n          setArguments={data.setArguments}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default memo(ComponentTaskNode);\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport React, { DragEvent, useState } from \"react\";\r\nimport ReactFlow, {\r\n  ArrowHeadType,\r\n  Connection,\r\n  Edge,\r\n  ElementId,\r\n  Elements,\r\n  isEdge,\r\n  isNode,\r\n  Node,\r\n  OnLoadParams,\r\n  ReactFlowProps,\r\n  XYPosition,\r\n} from \"react-flow-renderer\";\r\n\r\nimport {\r\n  ArgumentType,\r\n  ComponentSpec,\r\n  GraphInputArgument,\r\n  GraphSpec,\r\n  InputSpec,\r\n  OutputSpec,\r\n  TaskOutputArgument,\r\n  TaskSpec,\r\n  isGraphImplementation,\r\n} from \"../componentSpec\";\r\nimport ComponentTaskNode, { ComponentTaskNodeProps, isComponentTaskNode } from \"./ComponentTaskNode\";\r\n\r\n\r\nconst NODE_LAYOUT_ANNOTATION_KEY = \"editor.position\";\r\nconst SDK_ANNOTATION_KEY = \"sdk\";\r\nconst SDK_ANNOTATION_VALUE = \"https://cloud-pipelines.net/pipeline-editor/\";\r\n\r\nconst taskIdToNodeId = (id: string) => \"task_\" + id;\r\nconst inputNameToNodeId = (name: string) => \"input_\" + name;\r\nconst outputNameToNodeId = (name: string) => \"output_\" + name;\r\n\r\nconst nodeIdToTaskId = (id: string) => id.replace(/^task_/, \"\");\r\nconst nodeIdToInputName = (id: string) => id.replace(/^input_/, \"\");\r\nconst nodeIdToOutputName = (id: string) => id.replace(/^output_/, \"\");\r\n\r\nexport const augmentComponentSpec = (\r\n  componentSpec: ComponentSpec,\r\n  nodes: Node[],\r\n  includeSpecs = false,\r\n  includePositions = true\r\n) => {\r\n  componentSpec = { ...componentSpec };\r\n\r\n  const getNodePositionAnnotation = (node: Node) =>\r\n    JSON.stringify({\r\n      // node.position cannot be used since set at 1st drop and never updated\r\n      x: node.__rf.position.x,\r\n      y: node.__rf.position.y,\r\n      width: node.__rf.width,\r\n      height: node.__rf.height,\r\n    });\r\n\r\n  const nodeXPositionComparer = (n1: Node, n2: Node) => {\r\n    const deltaX = n1.__rf.position.x - n2.__rf.position.x;\r\n    const deltaY = n1.__rf.position.y - n2.__rf.position.y;\r\n    return deltaX !== 0 ? deltaX : deltaY;\r\n  };\r\n  const nodeYPositionComparer = (n1: Node, n2: Node) => {\r\n    const deltaX = n1.__rf.position.x - n2.__rf.position.x;\r\n    const deltaY = n1.__rf.position.y - n2.__rf.position.y;\r\n    return deltaY !== 0 ? deltaY : deltaX;\r\n  };\r\n\r\n  // Input and output nodes\r\n  // Sorting them by horizontal position to make reordering inputs and outputs easy.\r\n  const inputNodes = nodes\r\n    .filter((node) => node.type === \"input\")\r\n    .sort(nodeXPositionComparer);\r\n  const outputNodes = nodes\r\n    .filter((node) => node.type === \"output\")\r\n    .sort(nodeXPositionComparer);\r\n  const taskNodes = nodes\r\n    .filter(isComponentTaskNode)\r\n    .sort(nodeYPositionComparer);\r\n\r\n  const inputPositionMap = new Map<string, string>(\r\n    inputNodes.map((node) => [\r\n      nodeIdToInputName(node.id),\r\n      getNodePositionAnnotation(node),\r\n    ])\r\n  );\r\n  const inputOrderMap = new Map<string, number>(\r\n    inputNodes.map((node, index) => [nodeIdToInputName(node.id), index])\r\n  );\r\n  const inputOrderComparer = (a: InputSpec, b: InputSpec) =>\r\n    (inputOrderMap.get(a.name) ?? Infinity) -\r\n    (inputOrderMap.get(b.name) ?? Infinity);\r\n  const outputPositionMap = new Map<string, string>(\r\n    outputNodes.map((node) => [\r\n      nodeIdToOutputName(node.id),\r\n      getNodePositionAnnotation(node),\r\n    ])\r\n  );\r\n  const outputOrderMap = new Map<string, number>(\r\n    outputNodes.map((node, index) => [nodeIdToOutputName(node.id), index])\r\n  );\r\n  const outputOrderComparer = (a: OutputSpec, b: OutputSpec) =>\r\n    (outputOrderMap.get(a.name) ?? Infinity) -\r\n    (outputOrderMap.get(b.name) ?? Infinity);\r\n  const taskPositionMap = new Map<string, string>(\r\n    taskNodes.map((node) => [\r\n      nodeIdToTaskId(node.id),\r\n      getNodePositionAnnotation(node),\r\n    ])\r\n  );\r\n  const taskOrderMap = new Map<string, number>(\r\n    taskNodes.map((node, index) => [nodeIdToTaskId(node.id), index])\r\n  );\r\n  const taskOrderComparer = (\r\n    pairA: [string, TaskSpec],\r\n    pairB: [string, TaskSpec]\r\n  ) =>\r\n    (taskOrderMap.get(pairA[0]) ?? Infinity) -\r\n    (taskOrderMap.get(pairB[0]) ?? Infinity);\r\n\r\n  componentSpec.inputs = componentSpec.inputs\r\n    ?.map((inputSpec) => {\r\n      if (!inputPositionMap.has(inputSpec.name) || !inputOrderMap.has(inputSpec.name)) {\r\n        throw Error(`The nodes array does not have input node ${inputSpec.name}`);\r\n      }\r\n      let newAnnotations = { ...inputSpec.annotations };\r\n      if (includePositions) {\r\n        newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] = inputPositionMap.get(\r\n          inputSpec.name\r\n        );\r\n      } else {\r\n        delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n      }\r\n      let newInputSpec: InputSpec = {\r\n        ...inputSpec,\r\n        annotations: newAnnotations,\r\n      };\r\n      if (Object.keys(newAnnotations).length === 0) {\r\n        delete newInputSpec.annotations;\r\n      }\r\n      return newInputSpec;\r\n    })\r\n    .sort(inputOrderComparer);\r\n\r\n  componentSpec.outputs = componentSpec.outputs\r\n    ?.map((outputSpec) => {\r\n      if (!outputPositionMap.has(outputSpec.name) || !outputOrderMap.has(outputSpec.name)) {\r\n        throw Error(`The nodes array does not have output node ${outputSpec.name}`);\r\n      }\r\n      let newAnnotations = { ...outputSpec.annotations };\r\n      if (includePositions) {\r\n        newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] = outputPositionMap.get(\r\n          outputSpec.name\r\n        );\r\n      } else {\r\n        delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n      }\r\n      let newOutputSpec: OutputSpec = {\r\n        ...outputSpec,\r\n        annotations: newAnnotations,\r\n      };\r\n      if (\r\n        newAnnotations === undefined ||\r\n        Object.keys(newAnnotations).length === 0\r\n      ) {\r\n        delete newOutputSpec.annotations;\r\n      }\r\n      return newOutputSpec;\r\n    })\r\n    .sort(outputOrderComparer);\r\n\r\n  if (!isGraphImplementation(componentSpec.implementation)) {\r\n    return componentSpec;\r\n  }\r\n\r\n  let graphSpec: GraphSpec = { ...componentSpec.implementation.graph };\r\n  const newTasks = Object.fromEntries(\r\n    Object.entries(graphSpec.tasks || {})\r\n      .map(([taskId, taskSpec]) => {\r\n        if (!taskPositionMap.has(taskId) || !taskOrderMap.has(taskId)) {\r\n          throw Error(`The nodes array does not have task node ${taskId}`);\r\n        }\r\n        let newAnnotations = { ...taskSpec.annotations };\r\n        if (includePositions) {\r\n          newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] =\r\n            taskPositionMap.get(taskId);\r\n        } else {\r\n          delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n        }\r\n        let newTaskSpec: TaskSpec = {\r\n          ...taskSpec,\r\n          annotations: newAnnotations,\r\n        };\r\n        if (\r\n          newAnnotations === undefined ||\r\n          Object.keys(newAnnotations).length === 0\r\n        ) {\r\n          delete newTaskSpec.annotations;\r\n        }\r\n        // TODO: Sort the arguments based on the ordering of the component inputs.\r\n        if (\r\n          !includeSpecs &&\r\n          newTaskSpec.componentRef.spec !== undefined &&\r\n          newTaskSpec.componentRef.url !== undefined\r\n        ) {\r\n          newTaskSpec.componentRef = { ...newTaskSpec.componentRef };\r\n          delete newTaskSpec.componentRef.spec;\r\n        }\r\n        return [taskId, newTaskSpec] as [string, TaskSpec];\r\n      })\r\n      .sort(taskOrderComparer)\r\n  );\r\n  if (newTasks !== undefined) {\r\n    graphSpec.tasks = newTasks;\r\n  }\r\n  componentSpec = {\r\n    ...componentSpec,\r\n    implementation: { ...componentSpec.implementation, graph: graphSpec },\r\n  };\r\n\r\n  componentSpec = {\r\n    ...componentSpec,\r\n    metadata: {\r\n      ...componentSpec.metadata,\r\n      annotations: {\r\n        ...componentSpec.metadata?.annotations,\r\n        [SDK_ANNOTATION_KEY]: SDK_ANNOTATION_VALUE\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reordering the attributes and removing the undefined ones\r\n  const rebuildComponentSpec = ({\r\n    name,\r\n    description,\r\n    metadata,\r\n    inputs,\r\n    outputs,\r\n    implementation,\r\n    ...rest\r\n  }: ComponentSpec): ComponentSpec => ({\r\n    ...(name && { name: name }),\r\n    ...(description && { description: description }),\r\n    ...(metadata && { metadata: metadata }),\r\n    ...(inputs && { inputs: inputs }),\r\n    ...(outputs && { outputs: outputs }),\r\n    implementation: implementation,\r\n    ...rest,\r\n  });\r\n  componentSpec = rebuildComponentSpec(componentSpec);\r\n\r\n  return componentSpec;\r\n};\r\n\r\nexport interface GraphComponentSpecFlowProps\r\n  extends Omit<ReactFlowProps, \"elements\"> {\r\n  componentSpec: ComponentSpec,\r\n  setComponentSpec: (componentSpec: ComponentSpec) => void,\r\n}\r\n\r\nconst nodeTypes = {\r\n  task: ComponentTaskNode,\r\n};\r\n\r\nconst GraphComponentSpecFlow = ({\r\n  children,\r\n  componentSpec = { implementation: { graph: { tasks: {} } } },\r\n  setComponentSpec,\r\n  ...rest\r\n}: GraphComponentSpecFlowProps) => {\r\n  const [reactFlowInstance, setReactFlowInstance] = useState<OnLoadParams>();\r\n\r\n  if (! ('graph' in componentSpec.implementation)) {\r\n    // Only graph components are supported\r\n    return <></>;\r\n  }\r\n  let graphSpec = componentSpec.implementation.graph;\r\n\r\n  const nodes = Object.entries(graphSpec.tasks).map<Node<ComponentTaskNodeProps>>(\r\n    ([taskId, taskSpec]) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (taskSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = taskSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n\r\n      return {\r\n        id: taskIdToNodeId(taskId),\r\n        data: {\r\n          taskSpec: taskSpec,\r\n          taskId: taskId,\r\n          setArguments: (args) => setTaskArguments(taskId, args),\r\n        },\r\n        position: position,\r\n        type: \"task\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const inputNodes = (componentSpec.inputs ?? []).map<Node>(\r\n    (inputSpec) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (inputSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = inputSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n      return {\r\n        id: inputNameToNodeId(inputSpec.name),\r\n        data: { label: inputSpec.name },\r\n        position: position,\r\n        type: \"input\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const outputNodes = (componentSpec.outputs ?? []).map<Node>(\r\n    (outputSpec) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (outputSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = outputSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n      return {\r\n        id: outputNameToNodeId(outputSpec.name),\r\n        data: { label: outputSpec.name },\r\n        position: position,\r\n        type: \"output\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const edges: Edge[] = Object.entries(graphSpec.tasks).flatMap(\r\n    ([taskId, taskSpec]) => {\r\n      return Object.entries(taskSpec.arguments ?? {}).flatMap(\r\n        ([inputName, argument]) => {\r\n          if (typeof argument === \"string\") {\r\n            return [];\r\n          }\r\n          if (\"taskOutput\" in argument) {\r\n            const taskOutput = argument.taskOutput;\r\n            const edge: Edge = {\r\n              id: `${taskOutput.taskId}_${taskOutput.outputName}-${taskId}_${inputName}`,\r\n              source: taskIdToNodeId(taskOutput.taskId),\r\n              sourceHandle: `output_${taskOutput.outputName}`,\r\n              target: taskIdToNodeId(taskId),\r\n              targetHandle: `input_${inputName}`,\r\n              arrowHeadType: ArrowHeadType.ArrowClosed,\r\n            };\r\n            return [edge];\r\n          } else if (\"graphInput\" in argument) {\r\n            const graphInput = argument.graphInput;\r\n            const edge: Edge = {\r\n              id: `Input_${graphInput.inputName}-${taskId}_${inputName}`,\r\n              source: inputNameToNodeId(graphInput.inputName),\r\n              //sourceHandle: undefined,\r\n              //sourceHandle: \"Input\",\r\n              sourceHandle: null,\r\n              target: taskIdToNodeId(taskId),\r\n              targetHandle: `input_${inputName}`,\r\n              arrowHeadType: ArrowHeadType.ArrowClosed,\r\n            };\r\n            return [edge];\r\n          } else {\r\n            console.error(\"Impossible task input argument kind: \", argument);\r\n            return [];\r\n          }\r\n        }\r\n      );\r\n    }\r\n  );\r\n\r\n  const outputEdges: Edge[] = Object.entries(graphSpec.outputValues ?? {}).map(\r\n    ([outputName, argument]) => {\r\n      const taskOutput = argument.taskOutput;\r\n      const edge: Edge = {\r\n        id: `${taskOutput.taskId}_${taskOutput.outputName}-Output_${outputName}`,\r\n        source: taskIdToNodeId(taskOutput.taskId),\r\n        sourceHandle: `output_${taskOutput.outputName}`,\r\n        target: outputNameToNodeId(outputName),\r\n        //targetHandle: undefined,\r\n        //targetHandle: \"Output\",\r\n        targetHandle: null,\r\n        arrowHeadType: ArrowHeadType.ArrowClosed,\r\n      };\r\n      return edge;\r\n    }\r\n  );\r\n\r\n  const elements = (nodes as Elements).concat(inputNodes).concat(outputNodes).concat(edges).concat(outputEdges);\r\n  \r\n  const replaceComponentSpec = (newComponentSpec: ComponentSpec) => {\r\n    componentSpec = newComponentSpec;\r\n    setComponentSpec(newComponentSpec);\r\n  };\r\n\r\n  const replaceGraphSpec = (newGraphSpec: GraphSpec) => {\r\n    graphSpec = newGraphSpec;\r\n    replaceComponentSpec({ ...componentSpec, implementation: { graph: graphSpec } });\r\n  };\r\n\r\n  const setTaskArguments = (\r\n    taskId: string,\r\n    taskArguments?: Record<string, ArgumentType>,\r\n  ) => {\r\n    let newGraphSpec: GraphSpec = {\r\n      ...graphSpec,\r\n      tasks: { ...graphSpec.tasks },\r\n    };\r\n    newGraphSpec.tasks[taskId] = {\r\n      ...graphSpec.tasks[taskId],\r\n      arguments: taskArguments,\r\n    };\r\n    replaceGraphSpec(newGraphSpec);\r\n  };\r\n\r\n  const setTaskArgument = (\r\n    taskId: string,\r\n    inputName: string,\r\n    argument?: ArgumentType\r\n  ) => {\r\n    const oldTaskSpec = graphSpec.tasks[taskId];\r\n    const oldTaskSpecArguments = oldTaskSpec.arguments;\r\n    let newTaskSpecArguments: Record<string, ArgumentType> = {\r\n      ...oldTaskSpecArguments,\r\n    };\r\n    if (argument === undefined) {\r\n      delete newTaskSpecArguments[inputName];\r\n    } else {\r\n      newTaskSpecArguments[inputName] = argument;\r\n    }\r\n    setTaskArguments(taskId, newTaskSpecArguments);\r\n  };\r\n\r\n  const removeTaskArgument = (taskId: string, inputName: string) =>\r\n    setTaskArgument(taskId, inputName, undefined);\r\n\r\n  const setGraphOutputValue = (\r\n    outputName: string,\r\n    outputValue?: TaskOutputArgument\r\n  ) => {\r\n    let newGraphOutputValues = { ...graphSpec.outputValues };\r\n    if (outputValue === undefined) {\r\n      delete newGraphOutputValues[outputName];\r\n    } else {\r\n      newGraphOutputValues[outputName] = outputValue;\r\n    }\r\n    graphSpec = { ...graphSpec, outputValues: newGraphOutputValues };\r\n    replaceGraphSpec(graphSpec);\r\n  };\r\n\r\n  const removeGraphOutputValue = (outputName: string) =>\r\n    setGraphOutputValue(outputName);\r\n\r\n  const addConnection = (connection: Connection | Edge) => {\r\n    if (connection.source === null || connection.target === null) {\r\n      console.error(\r\n        \"addConnection called with missing source or target: \",\r\n        connection\r\n      );\r\n      return;\r\n    }\r\n\r\n    const targetTaskInputName = connection.targetHandle?.replace(/^input_/, \"\");\r\n    const sourceTaskOutputName = connection.sourceHandle?.replace(/^output_/, \"\");\r\n\r\n    if (sourceTaskOutputName !== undefined) {\r\n      // Source is task output\r\n      const taskOutputArgument: TaskOutputArgument = {\r\n        taskOutput: {\r\n          taskId: nodeIdToTaskId(connection.source),\r\n          outputName: sourceTaskOutputName,\r\n        },\r\n      };\r\n\r\n      if (targetTaskInputName !== undefined) {\r\n        // Target is task input\r\n        setTaskArgument(\r\n          nodeIdToTaskId(connection.target),\r\n          targetTaskInputName,\r\n          taskOutputArgument\r\n        );\r\n      } else {\r\n        // Target is graph output\r\n        setGraphOutputValue(\r\n          nodeIdToOutputName(connection.target),\r\n          taskOutputArgument\r\n        );\r\n        // TODO: Perhaps propagate type information\r\n      }\r\n    } else {\r\n      // Source is graph input\r\n      const graphInputName = nodeIdToInputName(connection.source);\r\n      const graphInputArgument: GraphInputArgument = {\r\n        graphInput: {\r\n          inputName: graphInputName,\r\n        },\r\n      };\r\n      if (targetTaskInputName !== undefined) {\r\n        // Target is task input\r\n        setTaskArgument(\r\n          nodeIdToTaskId(connection.target),\r\n          targetTaskInputName,\r\n          graphInputArgument\r\n        );\r\n        // TODO: Perhaps propagate type information\r\n      } else {\r\n        // Target is graph output\r\n        console.error(\r\n          \"addConnection: Cannot directly connect graph input to graph output: \",\r\n          connection\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  const onConnect = (params: Connection | Edge) => {\r\n    addConnection(params);\r\n  };\r\n\r\n  const removeEdge = (edge: Edge) => {\r\n    const inputName = edge.targetHandle?.replace(/^input_/, \"\");\r\n\r\n    if (inputName !== undefined) {\r\n      removeTaskArgument(nodeIdToTaskId(edge.target), inputName);\r\n    } else {\r\n      removeGraphOutputValue(nodeIdToOutputName(edge.target));\r\n    }\r\n  };\r\n\r\n  const removeComponentInput = (inputNameToRemove: string) => {\r\n    // Removing the outcoming edges\r\n    // Not really needed since react-flow sends the node's incoming and outcoming edges for deletion when a node is deleted\r\n    for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n      for (const [inputName, argument] of Object.entries(\r\n        taskSpec.arguments ?? {}\r\n      )) {\r\n        if (typeof argument !== \"string\" && \"graphInput\" in argument) {\r\n          if (argument.graphInput.inputName === inputNameToRemove) {\r\n            removeTaskArgument(taskId, inputName);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Not checking the sources of graph outputs, since they cannot be directly connected to the graph inputs\r\n\r\n    // Removing the input itself\r\n    const newInputs = (componentSpec.inputs ?? []).filter(\r\n      (inputSpec) => inputSpec.name !== inputNameToRemove\r\n    );\r\n    componentSpec = { ...componentSpec, inputs: newInputs };\r\n    replaceComponentSpec(componentSpec);\r\n  };\r\n\r\n  const removeComponentOutput = (outputNameToRemove: string) => {\r\n    removeGraphOutputValue(outputNameToRemove);\r\n    // Removing the output itself\r\n    const newOutputs = (componentSpec.outputs ?? []).filter(\r\n      (outputSpec) => outputSpec.name !== outputNameToRemove\r\n    );\r\n    componentSpec = { ...componentSpec, outputs: newOutputs };\r\n    replaceComponentSpec(componentSpec);\r\n  };\r\n\r\n  const removeTask = (taskIdToRemove: string) => {\r\n    // Removing the outcoming edges\r\n    // Not really needed since react-flow sends the node's incoming and outcoming edges for deletion when a node is deleted\r\n    for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n      for (const [inputName, argument] of Object.entries(\r\n        taskSpec.arguments ?? {}\r\n      )) {\r\n        if (typeof argument !== \"string\" && \"taskOutput\" in argument) {\r\n          if (argument.taskOutput.taskId === taskIdToRemove) {\r\n            removeTaskArgument(taskId, inputName);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Removing outcoming edges that go to graph outputs.\r\n    // ? Should we delete the outputs themselves\r\n    const newGraphOutputValues = Object.fromEntries(\r\n      Object.entries(graphSpec.outputValues ?? {}).filter(\r\n        ([_, argument]) => argument.taskOutput.taskId !== taskIdToRemove\r\n      )\r\n    );\r\n    graphSpec = { ...graphSpec, outputValues: newGraphOutputValues };\r\n\r\n    // Removing the task\r\n    let newGraphSpec: GraphSpec = {\r\n      ...graphSpec,\r\n      tasks: { ...graphSpec.tasks },\r\n    };\r\n    delete newGraphSpec.tasks[taskIdToRemove];\r\n    replaceGraphSpec(newGraphSpec);\r\n  };\r\n\r\n  const removeNode = (node: Node) => {\r\n    // TODO: Use global constants for node types\r\n    if (node.type === \"input\") {\r\n      const inputName = nodeIdToInputName(node.id);\r\n      removeComponentInput(inputName);\r\n    } else if (node.type === \"output\") {\r\n      const outputName = nodeIdToOutputName(node.id);\r\n      removeComponentOutput(outputName);\r\n    } else if (node.type === \"task\") {\r\n      const taskId = nodeIdToTaskId(node.id);\r\n      removeTask(taskId);\r\n    } else {\r\n      console.log(\"removeNode: Unexpected note type: \", node);\r\n    }\r\n  };\r\n\r\n  const onElementsRemove = (elementsToRemove: Elements) => {\r\n    for (const element of elementsToRemove) {\r\n      if (isEdge(element)) {\r\n        removeEdge(element);\r\n      }\r\n    }\r\n    for (const element of elementsToRemove) {\r\n      if (isNode(element)) {\r\n        removeNode(element);\r\n      }\r\n    }\r\n  };\r\n\r\n  const onEdgeUpdate = (oldEdge: Edge, newConnection: Connection) => {\r\n    removeEdge(oldEdge);\r\n    addConnection(newConnection);\r\n  };\r\n\r\n  const onLoad = (_reactFlowInstance: OnLoadParams) =>\r\n    setReactFlowInstance(_reactFlowInstance);\r\n\r\n  const onDragOver = (event: DragEvent) => {\r\n    event.preventDefault();\r\n    event.dataTransfer.dropEffect = \"move\";\r\n  };\r\n\r\n  const makeNameUniqueByAddingIndex = (name: string, existingNames: Set<string>): ElementId => {\r\n    let finalName = name;\r\n    let index = 1;\r\n    while (existingNames.has(finalName)) {\r\n      index++;\r\n      finalName = name + \" \" + index.toString();\r\n    }\r\n    return finalName;\r\n  };\r\n\r\n  const getUniqueInputName = (name: string = \"Input\") => {\r\n    return makeNameUniqueByAddingIndex(\r\n      name,\r\n      new Set(componentSpec.inputs?.map((inputSpec) => inputSpec.name))\r\n    );\r\n  };\r\n\r\n  const getUniqueOutputName = (name: string = \"Output\") => {\r\n    return makeNameUniqueByAddingIndex(\r\n      name,\r\n      new Set(componentSpec.outputs?.map((outputSpec) => outputSpec.name))\r\n    );\r\n  };\r\n\r\n  const getUniqueTaskName = (name: string = \"Task\") => {\r\n    return makeNameUniqueByAddingIndex(\r\n      name,\r\n      new Set(Object.keys(graphSpec.tasks))\r\n    );\r\n  };\r\n\r\n  const onDrop = (event: DragEvent) => {\r\n    event.preventDefault();\r\n\r\n    if (reactFlowInstance) {\r\n      const droppedData = event.dataTransfer.getData(\"application/reactflow\");\r\n      if (droppedData === \"\") {\r\n        return;\r\n      }\r\n      const droppedDataObject = JSON.parse(droppedData);\r\n      const nodeType = Object.keys(droppedDataObject)[0];\r\n      const nodeData = droppedDataObject[nodeType];\r\n      \r\n      // Correcting the position using the drag point location information\r\n      let dragOffsetX = 0;\r\n      let dragOffsetY = 0;\r\n      const dragStartOffsetData = event.dataTransfer.getData(\"DragStart.offset\");\r\n      if (dragStartOffsetData !== \"\") {\r\n        const dragStartOffset = JSON.parse(dragStartOffsetData);\r\n        // Hack to work around Chrome's draggable anchor bug. TODO: Remove once Chrome is fixed\r\n        dragOffsetX = dragStartOffset.offsetX * 0.68 ?? 0;\r\n        dragOffsetY = dragStartOffset.offsetY * 0.64 ?? 0;\r\n      }\r\n\r\n      // Node position. Offsets should be included in projection, so that they snap to the grid.\r\n      // Otherwise the dropped nodes will be out of phase with the rest of the nodes even when snapping.\r\n      let position = reactFlowInstance.project({\r\n        x: event.clientX - dragOffsetX,\r\n        y: event.clientY - dragOffsetY,\r\n      });\r\n\r\n      const nodePosition = { x: position.x, y: position.y };\r\n      const positionAnnotations = {\r\n        \"editor.position\": JSON.stringify(nodePosition),\r\n      }\r\n      if (nodeType === \"task\") {\r\n        const taskSpec = nodeData as TaskSpec;\r\n        const mergedAnnotations = {\r\n          ...taskSpec.annotations,\r\n          ...positionAnnotations,\r\n        };\r\n        taskSpec.annotations = mergedAnnotations;\r\n        const taskSpecWithAnnotation: TaskSpec = {\r\n          ...taskSpec,\r\n          annotations: mergedAnnotations,\r\n        };\r\n        const taskId = getUniqueTaskName(taskSpec.componentRef.spec?.name ?? \"Task\");\r\n        graphSpec = { ...graphSpec, tasks: { ...graphSpec.tasks } };\r\n        graphSpec.tasks[taskId] = taskSpecWithAnnotation;\r\n        replaceGraphSpec(graphSpec);\r\n      } else if (nodeType === \"input\") {\r\n        const inputId = getUniqueInputName();\r\n        const inputSpec: InputSpec = {\r\n          name: inputId,\r\n          annotations: positionAnnotations,\r\n        };\r\n        const inputs = (componentSpec.inputs ?? []).concat([inputSpec]);\r\n        componentSpec = { ...componentSpec, inputs: inputs };\r\n        replaceComponentSpec(componentSpec);\r\n      } else if (nodeType === \"output\") {\r\n        const outputId = getUniqueOutputName();\r\n        const outputSpec: OutputSpec = {\r\n          name: outputId,\r\n          annotations: positionAnnotations,\r\n        };\r\n        const outputs = (componentSpec.outputs ?? []).concat([outputSpec]);\r\n        componentSpec = { ...componentSpec, outputs: outputs };\r\n        replaceComponentSpec(componentSpec);\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <ReactFlow\r\n      {...rest}\r\n      elements={elements}\r\n      nodeTypes={nodeTypes}\r\n      onConnect={onConnect}\r\n      onDragOver={onDragOver}\r\n      onDrop={onDrop}\r\n      onEdgeUpdate={onEdgeUpdate}\r\n      onElementsRemove={onElementsRemove}\r\n      onLoad={onLoad}\r\n    >\r\n      {children}\r\n    </ReactFlow>\r\n  );\r\n};\r\n\r\nexport default GraphComponentSpecFlow;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport yaml from \"js-yaml\";\r\nimport localForage from \"localforage\";\r\nimport { ComponentSearchConfig } from \"./appSettings\";\r\nimport { httpGetWithCache } from \"./cacheUtils\";\r\nimport {\r\n  ComponentSpec,\r\n  ComponentReference,\r\n  isValidComponentSpec,\r\n} from \"./componentSpec\";\r\nimport { preloadComponentReferences } from \"./DragNDrop/samplePipelines\";\r\n\r\n// const COMPONENT_FILE_NAME_SUFFIX = \"component.yaml\";\r\n// const COMPONENT_FILE_MAX_SIZE = 100000;\r\nconst SEARCH_CACHE_NAME = \"https://api.github.com/search\";\r\nconst BLOB_CACHE_NAME = \"raw.githubusercontent.com/.../component.yaml\";\r\n\r\n// IndexedDB: DB and table names\r\nconst DB_NAME = \"components\";\r\nconst HASH_TO_CONTENT_DB_TABLE_NAME = \"hash_to_data\";\r\nconst HASH_TO_COMPONENT_NAME_DB_TABLE_NAME = \"hash_to_component_name\";\r\nconst URL_TO_HASH_DB_TABLE_NAME = \"url_to_hash\";\r\nconst HASH_TO_URL_DB_TABLE_NAME = \"hash_to_url\";\r\nconst URL_PROCESSING_VERSION_TABLE_NAME = \"url_version\";\r\nconst CURRENT_URL_PROCESSING_VERSION = 1;\r\nconst BAD_HASHES_TABLE_NAME = \"bad_hashes\";\r\n\r\nexport const searchGitHubCodeWithCache = async (\r\n  query: string,\r\n  page = 1,\r\n  sort = \"indexed\",\r\n  order = \"desc\"\r\n): Promise<any> => {\r\n  // TODO: Paging\r\n  const encodedQuery = encodeURIComponent(query);\r\n  const encodedSort = encodeURIComponent(sort);\r\n  const encodedOrder = encodeURIComponent(order);\r\n  const searchUrl = `https://api.github.com/search/code?q=${encodedQuery}&sort=${encodedSort}&order=${encodedOrder}&per_page=100&page=${page}`;\r\n  const response = await httpGetWithCache(searchUrl, SEARCH_CACHE_NAME, true);\r\n  return response.json();\r\n};\r\n\r\nconst githubHtmlUrlToDownloadUrl = (htmlUrl: string): string => {\r\n  // https://github.com/               kubeflow/pipelines/blob/24bc9162a56c2fe3c50947d655ef280f71ba058f/components/gcp/dataflow/launch_flex_template/component.yaml\r\n  // https://raw.githubusercontent.com/kubeflow/pipelines     /24bc9162a56c2fe3c50947d655ef280f71ba058f/components/gcp/dataflow/launch_flex_template/component.yaml\r\n  return htmlUrl\r\n    .replace(\"https://github.com/\", \"https://raw.githubusercontent.com/\")\r\n    .replace(\"/blob/\", \"/\");\r\n};\r\n\r\ntype UrlAndHash = {\r\n  url: string;\r\n  hash: string;\r\n};\r\n\r\nexport async function* getComponentUrlsAndHashes(searchLocations: string[]) {\r\n  let urlsAndHashes: UrlAndHash[] = [];\r\n  // TODO: If the number of components exceeds 1000 we should issue separate query for each location.\r\n  // TODO: Perhaps try to filter by component contents (inputValue, inputPath, outputPath, graph, implementation)\r\n  const queryParts = [\"filename:component.yaml\"].concat(searchLocations);\r\n  const query = queryParts.join(\" \");\r\n  for (let page = 1; page < 100; page++) {\r\n    const searchResults = await searchGitHubCodeWithCache(query, page);\r\n    // \"total_count\": 512,\r\n    // \"incomplete_results\": false,\r\n    // \"items\": [\r\n    const items: any[] = searchResults.items;\r\n    if (items.length === 0) {\r\n      break;\r\n    }\r\n    for (let item of items) {\r\n      yield {\r\n        url: githubHtmlUrlToDownloadUrl(item.html_url),\r\n        hash: item.sha as string,\r\n      };\r\n    }\r\n    await new Promise((resolve) =>\r\n      setTimeout(resolve, ((60 * 1000) / 10) * (1 + 0.1))\r\n    );\r\n  }\r\n  return urlsAndHashes;\r\n}\r\n\r\nexport const cacheComponentCandidateBlobs = async (\r\n  searchLocations: string[]\r\n): Promise<any[]> => {\r\n  let urlsAndHashes: UrlAndHash[] = [];\r\n  let urls = [];\r\n  for await (const urlAndHash of getComponentUrlsAndHashes(searchLocations)) {\r\n    urlsAndHashes.push(urlAndHash);\r\n    urls.push(urlAndHash.url);\r\n  }\r\n  const cache = await caches.open(BLOB_CACHE_NAME);\r\n  await cache.addAll(urls);\r\n  return urlsAndHashes;\r\n};\r\n\r\nexport const downloadComponentDataWithCache = async (url: string) => {\r\n  const response = await httpGetWithCache(url, BLOB_CACHE_NAME);\r\n  const data = await response.blob();\r\n  const componentText = await data.text();\r\n  const componentSpecObj = yaml.load(componentText);\r\n  if (typeof componentSpecObj !== \"object\" || componentSpecObj === null) {\r\n    throw Error(\r\n      `componentText is not a YAML-encoded object: ${componentSpecObj}`\r\n    );\r\n  }\r\n  if (!isValidComponentSpec(componentSpecObj)) {\r\n    throw Error(\r\n      `componentText does not encode a valid pipeline component: ${componentSpecObj}`\r\n    );\r\n  }\r\n  const componentSpec = componentSpecObj;\r\n  return componentSpec;\r\n};\r\n\r\nexport const cacheAllComponents = async (searchLocations: string[]) => {\r\n  console.debug(\"Starting cacheAllComponents\");\r\n  const urlsAndHashesIterator = getComponentUrlsAndHashes(searchLocations);\r\n\r\n  // const cache = await caches.open(BLOB_CACHE_NAME);\r\n  const urlToHashDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_TO_HASH_DB_TABLE_NAME,\r\n  });\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  const hashToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  const urlProcessingVersionDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_PROCESSING_VERSION_TABLE_NAME,\r\n  });\r\n  const badHashesDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: BAD_HASHES_TABLE_NAME,\r\n  });\r\n  for await (const item of urlsAndHashesIterator) {\r\n    const hash = item.hash.toLowerCase();\r\n    const htmlUrl = item.url;\r\n    const badHashReason = await badHashesDb.getItem<string>(hash);\r\n    if (badHashReason !== null) {\r\n      console.debug(\r\n        `Skipping url ${htmlUrl} with hash ${hash} due to error: \"${badHashReason}\"`\r\n      );\r\n      continue;\r\n    }\r\n    try {\r\n      const downloadUrl: string = githubHtmlUrlToDownloadUrl(htmlUrl);\r\n      if (!downloadUrl.endsWith(\"component.yaml\")) {\r\n        console.debug(\r\n          `Skipping url ${downloadUrl} since it does not end with \"component.yaml\"`\r\n        );\r\n        continue;\r\n      }\r\n      // Sanity check\r\n      const cachedHash = await urlToHashDb.getItem<string>(downloadUrl);\r\n      if (cachedHash !== null && cachedHash !== hash) {\r\n        console.error(\r\n          `Component cache is broken. Stored hash for ${downloadUrl}: ${cachedHash} != ${hash}.`\r\n        );\r\n      }\r\n      // Check whether the processing is complete\r\n      const urlVersion = await urlProcessingVersionDb.getItem<string>(\r\n        downloadUrl\r\n      );\r\n\r\n      if (\r\n        cachedHash !== null && // Not sure we should check this, but it improves the sanity\r\n        urlVersion !== null &&\r\n        Number.parseInt(urlVersion) >= CURRENT_URL_PROCESSING_VERSION\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      console.debug(`Processing new component candidate: ${downloadUrl}.`);\r\n      const response = await httpGetWithCache(downloadUrl, BLOB_CACHE_NAME);\r\n      let componentSpec: ComponentSpec;\r\n      let componentText: string;\r\n      try {\r\n        const data = await response.blob();\r\n        componentText = await data.text();\r\n        const componentSpecObj = yaml.load(componentText);\r\n        if (typeof componentSpecObj !== \"object\" || componentSpecObj === null) {\r\n          throw Error(\r\n            `componentText is not a YAML-encoded object: ${componentSpecObj}`\r\n          );\r\n        }\r\n        if (!isValidComponentSpec(componentSpecObj)) {\r\n          throw Error(\r\n            `componentText does not encode a valid pipeline component: ${componentSpecObj}`\r\n          );\r\n        }\r\n        componentSpec = componentSpecObj;\r\n      } catch (err) {\r\n        badHashesDb.setItem(hash, err.name + \": \" + err.message);\r\n        continue;\r\n      }\r\n      if (componentSpec.implementation === undefined) {\r\n        badHashesDb.setItem(\r\n          hash,\r\n          'Component lacks the \"implementation\" section.'\r\n        );\r\n        continue;\r\n      }\r\n\r\n      // Blobs are cumbersome (need await to get text) - store text instead\r\n      // await hashToContentDb.setItem(hash, data);\r\n      await hashToContentDb.setItem(hash, componentText);\r\n\r\n      // Only adding hash -> URL once\r\n      const urlForHash = await hashToUrlDb.getItem<string>(hash);\r\n      if (urlForHash === null) {\r\n        await hashToUrlDb.setItem(hash, downloadUrl);\r\n      }\r\n\r\n      // Only storing names when they exist\r\n      if (componentSpec.name) {\r\n        await hashToComponentNameDb.setItem(hash, componentSpec.name);\r\n      }\r\n\r\n      await urlToHashDb.setItem(downloadUrl, hash);\r\n\r\n      // Marking the processing as completed\r\n      await urlProcessingVersionDb.setItem(\r\n        downloadUrl,\r\n        CURRENT_URL_PROCESSING_VERSION\r\n      );\r\n    } catch (err) {\r\n      console.error(\r\n        `Error when processing component candidate ${htmlUrl} Error: ${err}.`\r\n      );\r\n    }\r\n  }\r\n  console.debug(\"Finished cacheAllComponents\");\r\n};\r\n\r\ninterface ComponentFeedEntry {\r\n  componentRef: ComponentReference;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n  data: string;\r\n}\r\n\r\ninterface ComponentFeed {\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n  components: ComponentFeedEntry[];\r\n}\r\n\r\n// Type guards\r\nconst isComponentFeedEntry = (obj: any): obj is ComponentFeedEntry =>\r\n  \"componentRef\" in obj;\r\n\r\nconst isComponentFeedEntryArray = (obj: any): obj is ComponentFeedEntry[] =>\r\n  Array.isArray(obj) && obj.every(isComponentFeedEntry);\r\n\r\nconst isComponentFeed = (obj: any): obj is ComponentFeed =>\r\n  typeof obj === \"object\" &&\r\n  \"components\" in obj &&\r\n  isComponentFeedEntryArray(obj[\"components\"]);\r\n\r\nfunction notUndefined<T>(x: T | undefined): x is T {\r\n  return x !== undefined;\r\n}\r\n\r\nconst calculateGitBlobSha1HashHex = async (data: string | ArrayBuffer) => {\r\n  // TODO: Avoid string roundtrip\r\n  const dataString =\r\n    typeof data === \"string\" ? data : new TextDecoder().decode(data);\r\n  const gitDataString =\r\n    \"blob \" + dataString.length.toString() + \"\\0\" + dataString;\r\n  const gitDataBytes = new TextEncoder().encode(gitDataString);\r\n  const hashBuffer = await crypto.subtle.digest(\"SHA-1\", gitDataBytes);\r\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n  const hashHex = hashArray\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\");\r\n  return hashHex;\r\n};\r\n\r\nconst importComponentsFromFeed = async (componentFeedUrl: string) => {\r\n  console.debug(\"Starting importComponentsFromFeed\");\r\n  console.debug(`Downloading component feed: ${componentFeedUrl}.`);\r\n  const response = await fetch(componentFeedUrl);\r\n  const componentFeedCandidateBlob = await response.blob();\r\n  const componentFeedCandidateText = await componentFeedCandidateBlob.text();\r\n  const componentFeedCandidateObject = yaml.load(componentFeedCandidateText);\r\n  if (!isComponentFeed(componentFeedCandidateObject)) {\r\n    throw new Error(\r\n      `Component feed loaded from \"${componentFeedUrl}\" had invalid content inside.`\r\n    );\r\n  }\r\n  const componentFeed = componentFeedCandidateObject;\r\n\r\n  const urlsHashesAndData = (\r\n    await Promise.all(\r\n      componentFeed.components.map(async (entry) => {\r\n        const url = entry.componentRef.url;\r\n        if (url === undefined) {\r\n          console.error(\"Component feed entry has no reference URL.\");\r\n          return undefined;\r\n        }\r\n        return {\r\n          url: url,\r\n          hash: await calculateGitBlobSha1HashHex(entry.data),\r\n          data: entry.data,\r\n        };\r\n      })\r\n    )\r\n  ).filter(notUndefined);\r\n\r\n  // const cache = await caches.open(BLOB_CACHE_NAME);\r\n  const urlToHashDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_TO_HASH_DB_TABLE_NAME,\r\n  });\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  const hashToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  const urlProcessingVersionDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_PROCESSING_VERSION_TABLE_NAME,\r\n  });\r\n  const badHashesDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: BAD_HASHES_TABLE_NAME,\r\n  });\r\n  for await (const item of urlsHashesAndData) {\r\n    const hash = item.hash.toLowerCase();\r\n    const htmlUrl = item.url;\r\n    const badHashReason = await badHashesDb.getItem<string>(hash);\r\n    if (badHashReason !== null) {\r\n      console.debug(\r\n        `Skipping url ${htmlUrl} with hash ${hash} due to error: \"${badHashReason}\"`\r\n      );\r\n      continue;\r\n    }\r\n    try {\r\n      const downloadUrl = item.url;\r\n      // Sanity check\r\n      const cachedHash = await urlToHashDb.getItem<string>(downloadUrl);\r\n      if (cachedHash !== null && cachedHash !== hash) {\r\n        console.error(\r\n          `Component cache is broken. Stored hash for ${downloadUrl}: ${cachedHash} != ${hash}.`\r\n        );\r\n      }\r\n      // Check whether the processing is complete\r\n      const urlVersion = await urlProcessingVersionDb.getItem<string>(\r\n        downloadUrl\r\n      );\r\n\r\n      if (\r\n        cachedHash !== null && // Not sure we should check this, but it improves the sanity\r\n        urlVersion !== null &&\r\n        Number.parseInt(urlVersion) >= CURRENT_URL_PROCESSING_VERSION\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      console.debug(`Processing new component candidate: ${downloadUrl}.`);\r\n      let componentText = item.data;\r\n      if (componentText === undefined) {\r\n        const response = await httpGetWithCache(downloadUrl, BLOB_CACHE_NAME);\r\n        try {\r\n          const data = await response.blob();\r\n          componentText = await data.text();\r\n        } catch (err) {\r\n          const error_message =\r\n            err instanceof Error ? err.name + \": \" + err.message : String(err);\r\n          badHashesDb.setItem(hash, error_message);\r\n          continue;\r\n        }\r\n      }\r\n      const componentSpecObj = yaml.load(componentText);\r\n      if (typeof componentSpecObj !== \"object\" || componentSpecObj === null) {\r\n        throw Error(\r\n          `componentText is not a YAML-encoded object: ${componentSpecObj}`\r\n        );\r\n      }\r\n      if (!isValidComponentSpec(componentSpecObj)) {\r\n        throw Error(\r\n          `componentText does not encode a valid pipeline component: ${componentSpecObj}`\r\n        );\r\n      }\r\n      const componentSpec = componentSpecObj;\r\n      if (componentSpec.implementation === undefined) {\r\n        badHashesDb.setItem(\r\n          hash,\r\n          'Component lacks the \"implementation\" section.'\r\n        );\r\n        continue;\r\n      }\r\n\r\n      // Blobs are cumbersome (need await to get text) - store text instead\r\n      // await hashToContentDb.setItem(hash, data);\r\n      await hashToContentDb.setItem(hash, componentText);\r\n\r\n      // Only adding hash -> URL once\r\n      const urlForHash = await hashToUrlDb.getItem<string>(hash);\r\n      if (urlForHash === null) {\r\n        await hashToUrlDb.setItem(hash, downloadUrl);\r\n      }\r\n\r\n      // Only storing names when they exist\r\n      if (componentSpec.name) {\r\n        await hashToComponentNameDb.setItem(hash, componentSpec.name);\r\n      }\r\n\r\n      await urlToHashDb.setItem(downloadUrl, hash);\r\n\r\n      // Marking the processing as completed\r\n      await urlProcessingVersionDb.setItem(\r\n        downloadUrl,\r\n        CURRENT_URL_PROCESSING_VERSION\r\n      );\r\n    } catch (err) {\r\n      console.error(\r\n        `Error when processing component candidate ${htmlUrl} Error: ${err}.`\r\n      );\r\n    }\r\n  }\r\n  console.debug(\"Finished importComponentsFromFeed\");\r\n};\r\n\r\nexport const refreshComponentDb = async (\r\n  componentSearchConfig: ComponentSearchConfig\r\n) => {\r\n  if (componentSearchConfig.ComponentFeedUrls) {\r\n    for (const componentFeedUrl of componentSearchConfig.ComponentFeedUrls) {\r\n      try {\r\n        await importComponentsFromFeed(componentFeedUrl);\r\n      } catch (error) {\r\n        console.error(\r\n          `Error importing component feed \"${componentFeedUrl}\": ${error}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  if (componentSearchConfig.GitHubSearchLocations !== undefined) {\r\n    await cacheAllComponents(componentSearchConfig.GitHubSearchLocations);\r\n  }\r\n};\r\n\r\nexport const getAllComponentsAsRefs = async () => {\r\n  // Perhaps use urlProcessingVersionDb as source of truth. Hmm. It is URL-based\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  let hashToComponentRef = new Map<string, ComponentReference>();\r\n\r\n  // !!! Iterating using hashToContentDb.iterate<string, void> causes all values to be `[object Blob]`\r\n  //await hashToContentDb.iterate<Blob, void>(\r\n  await hashToContentDb.iterate<string, void>(\r\n    // !!! async processor causes only 1 item to be processed since it returns Promise instead of undefined.\r\n    //async (componentData, hash, iterationNumber) => {\r\n    (componentText, hash, iterationNumber) => {\r\n      //const componentText = await componentData.text();\r\n      try {\r\n        const componentSpec = yaml.load(componentText) as ComponentSpec;\r\n        preloadComponentReferences(componentSpec);\r\n        hashToComponentRef.set(hash, {\r\n          spec: componentSpec,\r\n        });\r\n      } catch (err) {\r\n        console.error(\r\n          `Error when parsing cached component. Hash: ${hash}. Error: ${err}. Component text: ${componentText}`\r\n        );\r\n      }\r\n    }\r\n  );\r\n  await hashToUrlDb.iterate<string, void>((url, hash, iterationNumber) => {\r\n    let componentRef = hashToComponentRef.get(hash);\r\n    if (componentRef === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with url ${url} and hash ${hash} has no content in the DB.`\r\n      );\r\n    } else {\r\n      componentRef.url = url;\r\n    }\r\n  });\r\n  let componentRefs: ComponentReference[] = [];\r\n  // TODO: Improve the iteration once TypeScript property supports it\r\n  hashToComponentRef.forEach((componentRef, hash) => {\r\n    if (componentRef.url === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with hash ${hash} has content, but no URL in the DB.`\r\n      );\r\n    } else {\r\n      componentRefs.push(componentRef);\r\n    }\r\n  });\r\n  return componentRefs;\r\n};\r\n\r\nexport const isComponentDbEmpty = async () => {\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  return (await hashToContentDb.length()) === 0;\r\n};\r\n\r\nexport const searchComponentsByName = async (name: string) => {\r\n  const componentRefs = await getAllComponentsAsRefs();\r\n  return componentRefs.filter(\r\n    (ref) => ref.spec?.name?.toLowerCase().includes(name.toLowerCase()) ?? false\r\n  );\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nexport const httpGetWithCache = async (\r\n  urlOrRequest: string | RequestInfo,\r\n  cacheName: string,\r\n  updateIfInCache: boolean = false\r\n): Promise<Response> => {\r\n  const cache = await caches.open(cacheName);\r\n  const response = await cache.match(urlOrRequest);\r\n  if (response !== undefined) {\r\n    if (updateIfInCache) {\r\n      cache.add(urlOrRequest);\r\n    }\r\n    return response;\r\n  }\r\n  await cache.add(urlOrRequest);\r\n  const response2 = await cache.match(urlOrRequest);\r\n  if (response2 === undefined) {\r\n    return Promise.reject(\"Added object to cache, but could not find it\");\r\n  }\r\n  return response2;\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { DragEvent } from \"react\";\r\n\r\nimport { ComponentReference, TaskSpec } from \"../componentSpec\";\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData(\"application/reactflow\", JSON.stringify(nodeData));\r\n  event.dataTransfer.setData(\r\n    \"DragStart.offset\",\r\n    JSON.stringify({\r\n      offsetX: event.nativeEvent.offsetX,\r\n      offsetY: event.nativeEvent.offsetY,\r\n    })\r\n  );\r\n  event.dataTransfer.effectAllowed = \"move\";\r\n};\r\n\r\ninterface DraggableComponentProps\r\n  extends React.DetailedHTMLProps<\r\n    React.HTMLAttributes<HTMLDivElement>,\r\n    HTMLDivElement\r\n  > {\r\n  componentReference: ComponentReference;\r\n}\r\n\r\nconst DraggableComponent = ({\r\n  componentReference,\r\n  ...props\r\n}: DraggableComponentProps) => {\r\n  return (\r\n    <div\r\n      className=\"react-flow__node react-flow__node-task sidebar-node\"\r\n      draggable\r\n      onDragStart={(event: DragEvent) => {\r\n        const taskSpec: TaskSpec = {\r\n          componentRef: componentReference,\r\n        };\r\n        return onDragStart(event, { task: taskSpec });\r\n      }}\r\n      {...props}\r\n    >\r\n      {componentReference.spec?.name ?? \"Component\"}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DraggableComponent;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { ArgumentType, ComponentSpec, TypeSpecType } from \"../componentSpec\";\r\n\r\ninterface ArgumentsEditorProps {\r\n  componentSpec: ComponentSpec;\r\n  componentArguments: Record<string, ArgumentType>;\r\n  setComponentArguments: (args: Record<string, ArgumentType>) => void;\r\n  shrinkToWidth?: boolean;\r\n}\r\n\r\nconst getPatternForTypeSpec = (typeSpec?: TypeSpecType) => {\r\n  // TODO: Implement\r\n  return undefined;\r\n};\r\n\r\nconst typeSpecToString = (typeSpec?: TypeSpecType): string => {\r\n  if (typeSpec === undefined) {\r\n    return \"Any\";\r\n  }\r\n  if (typeof typeSpec === \"string\") {\r\n    return typeSpec;\r\n  }\r\n  return JSON.stringify(typeSpec);\r\n};\r\n\r\nconst ArgumentsEditor = ({\r\n  componentSpec,\r\n  componentArguments,\r\n  setComponentArguments,\r\n  shrinkToWidth = false,\r\n}: ArgumentsEditorProps) => {\r\n  return (\r\n    <div\r\n      className=\"highlight-invalid-inputs\"\r\n      style={{\r\n        display: \"table\",\r\n        borderSpacing: \"5px\",\r\n        // Enables shrinking the table. But also makes all columns same width regardless of the content\r\n        tableLayout: shrinkToWidth ? \"fixed\" : \"auto\",\r\n        // Width is needed for table-layout: \"fixed\" to work\r\n        width: \"100%\",\r\n      }}\r\n    >\r\n      {(componentSpec.inputs ?? []).map((inputSpec) => {\r\n        const inputName = inputSpec.name;\r\n        let value: string | undefined = undefined;\r\n        let placeholder: string | undefined = undefined;\r\n        const argument = componentArguments[inputName];\r\n        if (argument === undefined) {\r\n          value = inputSpec.default;\r\n        } else {\r\n          if (typeof argument === \"string\") {\r\n            value = argument;\r\n          } else if (\"taskOutput\" in argument) {\r\n            placeholder = `<from task ${argument.taskOutput.taskId} / ${argument.taskOutput.outputName}>`;\r\n          } else if (\"graphInput\" in argument) {\r\n            placeholder = `<from graph input ${argument.graphInput.inputName}>`;\r\n          } else {\r\n            placeholder = \"<reference>\";\r\n          }\r\n        }\r\n\r\n        const argumentIsRequiredButMissing =\r\n          !(inputName in componentArguments) &&\r\n          inputSpec.optional !== true &&\r\n          inputSpec.default === undefined;\r\n\r\n        const typeSpecString =\r\n          typeSpecToString(inputSpec.type) +\r\n          (inputSpec.optional === true ? \"?\" : \"\");\r\n\r\n        return (\r\n          <div\r\n            key={inputName}\r\n            style={{\r\n              display: \"table-row\",\r\n            }}\r\n          >\r\n            <label\r\n              title={`${inputName} (${typeSpecString})`}\r\n              style={{\r\n                textAlign: \"right\",\r\n                display: \"table-cell\",\r\n                whiteSpace: \"nowrap\",\r\n                overflow: \"hidden\",\r\n                textOverflow: \"ellipsis\",\r\n              }}\r\n            >\r\n              <span>\r\n                {inputName} (\r\n                <span\r\n                  style={{\r\n                    textOverflow: \"ellipsis\",\r\n                    overflow: \"hidden\",\r\n                    maxWidth: \"90px\",\r\n                    display: \"inline-block\",\r\n                    verticalAlign: \"bottom\",\r\n                  }}\r\n                  title={typeSpecString}\r\n                >\r\n                  {typeSpecString}\r\n                </span>\r\n                )\r\n              </span>\r\n            </label>\r\n            <input\r\n              style={{\r\n                display: \"table-cell\",\r\n                // Prevents border flickering and disappearing on movement\r\n                borderWidth: \"1px\",\r\n                // Overriding both min-width and max-width to enable the input element shrinking\r\n                minWidth: \"50px\",\r\n                maxWidth: \"100%\",\r\n              }}\r\n              placeholder={placeholder}\r\n              required={argumentIsRequiredButMissing}\r\n              value={value ?? \"\"}\r\n              pattern={getPatternForTypeSpec(inputSpec.type)}\r\n              onChange={(e) => {\r\n                componentArguments[inputName] = e.target.value;\r\n                setComponentArguments({ ...componentArguments });\r\n              }}\r\n            />\r\n            <div\r\n              style={{\r\n                display: \"table-cell\",\r\n                // Setting explicit width to make the button column smaller. Otherwise it takes 1/3 of the total width when the table-layout is set to fixed.\r\n                // The width should have been set to \"min-content\", but that does not work for some reason\r\n                width: \"30px\",\r\n              }}\r\n            >\r\n              <button\r\n                type=\"button\"\r\n                title=\"Reset to default\"\r\n                onClick={(e) => {\r\n                  delete componentArguments[inputName];\r\n                  setComponentArguments({ ...componentArguments });\r\n                }}\r\n                disabled={!(inputName in componentArguments)}\r\n              >\r\n                \r\n              </button>\r\n            </div>\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ArgumentsEditor;\r\n","/**\r\n * @license\r\n * Copyright 2022 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2022 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nexport const componentLibraryUrl =\r\n  process.env.PUBLIC_URL + \"/component_library.yaml\";\r\n\r\nexport interface ComponentSearchConfig {\r\n  ComponentFeedUrls?: string[];\r\n  GitHubSearchLocations?: string[];\r\n}\r\n\r\nexport const componentSearchConfig: ComponentSearchConfig = {\r\n  ComponentFeedUrls: [\r\n    \"https://raw.githubusercontent.com/Ark-kun/pipeline_components/pipeline_component_feed/pipeline_component_feed.yaml\",\r\n  ],\r\n  GitHubSearchLocations: [\"repo:Ark-kun/pipeline_components path:components\"],\r\n};\r\n\r\nexport const DEFAULT_COMPONENT_LIBRARY_URL =\r\n  process.env.PUBLIC_URL + \"/component_library.yaml\";\r\n\r\nexport const COMPONENT_SEARCH_GITHUB_USERS = [\"Ark-kun\", \"kubeflow\"];\r\nexport const COMPONENT_SEARCH_GITHUB_REPOS = [];\r\nexport const COMPONENT_SEARCH_COMPONENT_FEED_URLS = [\r\n  \"https://raw.githubusercontent.com/Ark-kun/pipeline_components/pipeline_component_feed/pipeline_component_feed.yaml\",\r\n];\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\n// Manually converted from https://github.com/kubeflow/pipelines/blob/master/api/v2alpha1/pipeline_spec.proto\r\n\r\n// The spec of a pipeline job.\r\nexport interface PipelineJob {\r\n  // Name of the job.\r\n  name?: string;\r\n\r\n  // User friendly display name\r\n  displayName?: string;\r\n  // Definition of the pipeline that is being executed.\r\n  pipelineSpec: PipelineSpec;\r\n\r\n  // The labels with user-defined metadata to organize PipelineJob.\r\n  labels?: { [k: string]: string };\r\n\r\n  // Runtime config of the pipeline.\r\n  runtimeConfig: RuntimeConfig;\r\n}\r\n\r\n// The runtime config of a PipelineJob.\r\nexport interface RuntimeConfig {\r\n  // The runtime parameters of the PipelineJob. The parameters will be\r\n  // passed into [PipelineJob.pipeline_spec][] to replace the placeholders\r\n  // at runtime.\r\n  parameters?: { [k: string]: MlmdValue };\r\n\r\n  // A path in a Cloud Storage bucket which will be treated as the root\r\n  // output directory of the pipeline. It is used by the system to\r\n  // generate the paths of output artifacts.\r\n  // This is a GCP-specific optimization.\r\n  gcsOutputDirectory: string;\r\n}\r\n\r\n// The spec of a pipeline.\r\nexport interface PipelineSpec {\r\n  // The metadata of the pipeline.\r\n  pipelineInfo?: PipelineInfo;\r\n\r\n  // The deployment config of the pipeline.\r\n  // The deployment config can be extended to provide platform specific configs.\r\n  deploymentSpec: PipelineDeploymentConfig;\r\n\r\n  // The version of the sdk, which compiles the spec.\r\n  sdkVersion?: string;\r\n\r\n  // The version of the schema.\r\n  schemaVersion?: string;\r\n\r\n  // The map of name to definition of all components used in this pipeline.\r\n  components: { [k: string]: ComponentSpec };\r\n\r\n  // The definition of the main pipeline.  Execution of the pipeline is\r\n  // completed upon the completion of this component.\r\n  root: ComponentSpec;\r\n}\r\n\r\n// Definition of a component.\r\nexport interface ComponentSpec {\r\n  // Definition of the input parameters and artifacts of the component.\r\n  inputDefinitions?: ComponentInputsSpec;\r\n\r\n  // Definition of the output parameters and artifacts of the component.\r\n  outputDefinitions?: ComponentOutputsSpec;\r\n\r\n  // Either a DAG or a single execution.\r\n  //oneof implementation {\r\n  dag?: DagSpec;\r\n  executorLabel?: string;\r\n  //}\r\n}\r\n\r\n// A DAG contains multiple tasks.\r\nexport interface DagSpec {\r\n  // The tasks inside the dag.\r\n  tasks: { [k: string]: PipelineTaskSpec };\r\n\r\n  // Defines how the outputs of the dag are linked to the sub tasks.\r\n  outputs?: DagOutputsSpec;\r\n}\r\n\r\n// Definition of the output artifacts and parameters of the DAG component.\r\nexport interface DagOutputsSpec {\r\n  // Name to the output artifact channel of the DAG.\r\n  artifacts?: { [k: string]: DagOutputArtifactSpec };\r\n\r\n  // The name to the output parameter.\r\n  parameters?: { [k: string]: DagOutputParameterSpec };\r\n}\r\n\r\n// Selects a defined output artifact from a sub task of the DAG.\r\nexport interface ArtifactSelectorSpec {\r\n  // The name of the sub task which produces the output that matches with\r\n  // the `output_artifact_key`.\r\n  producerSubtask: string;\r\n\r\n  // The key of [ComponentOutputsSpec.artifacts][] map of the producer task.\r\n  outputArtifactKey: string;\r\n}\r\n\r\n// Selects a list of output artifacts that will be aggregated to the single\r\n// output artifact channel of the DAG.\r\nexport interface DagOutputArtifactSpec {\r\n  // The selected artifacts will be aggregated as output as a single\r\n  // output channel of the DAG.\r\n  artifactSelectors: ArtifactSelectorSpec[];\r\n}\r\n\r\n// Selects a defined output parameter from a sub task of the DAG.\r\nexport interface ParameterSelectorSpec {\r\n  // The name of the sub task which produces the output that matches with\r\n  // the `output_parameter_key`.\r\n  producerSubtask: string;\r\n\r\n  // The key of [ComponentOutputsSpec.parameters][] map of the producer task.\r\n  outputParameterKey: string;\r\n}\r\n\r\n// Aggregate output parameters from sub tasks into a list object.\r\nexport interface ParameterSelectorsSpec {\r\n  parameterSelectors: ParameterSelectorSpec[];\r\n}\r\n\r\n// Aggregates output parameters from sub tasks into a map object.\r\nexport interface MapParameterSelectorsSpec {\r\n  mappedParameters: { [k: string]: ParameterSelectorSpec };\r\n}\r\n\r\n// We support four ways to fan-in output parameters from sub tasks to the DAG\r\n// parent task.\r\n// 1. Directly expose a single output parameter from a sub task,\r\n// 2. (Conditional flow) Expose a list of output from multiple tasks\r\n// (some might be skipped) but allows only one of the output being generated.\r\n// 3. Expose a list of outputs from multiple tasks (e.g. iterator flow).\r\n// 4. Expose the aggregation of output parameters as a name-value map.\r\nexport type DagOutputParameterSpec =\r\n  // Returns the sub-task parameter as a DAG parameter.  The selected\r\n  // parameter must have the same type as the DAG parameter type.\r\n  | { valueFromParameter: ParameterSelectorSpec }\r\n  // Returns one of the sub-task parameters as a DAG parameter. If there are\r\n  // multiple values are available to select, the DAG will fail. All the\r\n  // selected parameters must have the same type as the DAG parameter type.\r\n  | { valueFromOneof: ParameterSelectorsSpec };\r\n\r\n// Definition specification of the component input parameters and artifacts.\r\nexport interface ComponentInputsSpec {\r\n  // Name to artifact input.\r\n  artifacts?: { [k: string]: InputArtifactSpec };\r\n\r\n  // Name to parameter input.\r\n  parameters?: { [k: string]: InputParameterSpec };\r\n}\r\n\r\n// Definition of an artifact input.\r\nexport interface InputArtifactSpec {\r\n  artifactType: ArtifactTypeSchema;\r\n}\r\n\r\n// Definition of a parameter input.\r\nexport interface InputParameterSpec {\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// Definition specification of the component output parameters and artifacts.\r\nexport interface ComponentOutputsSpec {\r\n  // Name to artifact output.\r\n  artifacts?: { [k: string]: OutputArtifactSpec };\r\n\r\n  // Name to parameter output.\r\n  parameters?: { [k: string]: OutputParameterSpec };\r\n}\r\n\r\n// Definition of an artifact output.\r\nexport interface OutputArtifactSpec {\r\n  artifactType: ArtifactTypeSchema;\r\n\r\n  // Properties of the Artifact.\r\n  metadata?: { [k: string]: any };\r\n}\r\n\r\n// Definition of a parameter output.\r\nexport interface OutputParameterSpec {\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// The spec of task inputs.\r\n//export interface TaskInputsSpec {\r\nexport interface TaskArgumentsSpec {\r\n  // A map of input parameters which are small values, stored by the system and\r\n  // can be queried.\r\n  parameters?: { [k: string]: ParameterArgumentSpec };\r\n  // A map of input artifacts.\r\n  artifacts?: { [k: string]: ArtifactArgumentSpec };\r\n}\r\n\r\n// The specification of a task input artifact.\r\n//export type InputArtifactSpec =\r\nexport type ArtifactArgumentSpec =\r\n  // Pass the input artifact from another task within the same parent\r\n  // component.\r\n  | { taskOutputArtifact: TaskOutputArtifactSpec }\r\n  // Pass the input artifact from parent component input artifact.\r\n  | { componentInputArtifact: string };\r\n\r\nexport interface TaskOutputArtifactSpec {\r\n  // The name of the upstream task which produces the output that matches\r\n  // with the `output_artifact_key`.\r\n  producerTask: string;\r\n\r\n  // The key of [TaskOutputsSpec.artifacts][] map of the producer task.\r\n  outputArtifactKey: string;\r\n}\r\n\r\n// Represents an input parameter. The value can be taken from an upstream\r\n// task's output parameter (if specifying `producer_task` and\r\n// `output_parameter_key`, or it can be a runtime value, which can either be\r\n// determined at compile-time, or from a pipeline parameter.\r\n//export interface InputParameterSpec {\r\nexport interface ParameterArgumentSpec {\r\n  //oneof kind {\r\n  // Output parameter from an upstream task.\r\n  taskOutputParameter?: TaskOutputParameterSpec;\r\n  // A constant value or runtime parameter.\r\n  runtimeValue?: ValueOrRuntimeParameter;\r\n  // Pass the input parameter from parent component input parameter.\r\n  componentInputParameter?: string;\r\n  // The final status of an upstream task.\r\n  taskFinalStatus?: TaskFinalStatus;\r\n  //}\r\n\r\n  // Selector expression of Common Expression Language (CEL)\r\n  // that applies to the parameter found from above kind.\r\n  //\r\n  // The expression is applied to the Value type\r\n  // [Value][].  For example,\r\n  // 'size(string_value)' will return the size of the Value.string_value.\r\n  //\r\n  // After applying the selection, the parameter will be returned as a\r\n  // [Value][].  The type of the Value is either deferred from the input\r\n  // definition in the corresponding\r\n  // [ComponentSpec.input_definitions.parameters][], or if not found,\r\n  // automatically deferred as either string value or double value.\r\n  //\r\n  // In addition to the builtin functions in CEL, The value.string_value can\r\n  // be treated as a json string and parsed to the [google.protobuf.Value][]\r\n  // proto message. Then, the CEL expression provided in this field will be\r\n  // used to get the requested field. For examples,\r\n  //  - if Value.string_value is a json array of \"[1.1, 2.2, 3.3]\",\r\n  //  'parseJson(string_value)[i]' will pass the ith parameter from the list\r\n  //  to the current task, or\r\n  //  - if the Value.string_value is a json map of \"{\"a\": 1.1, \"b\": 2.2,\r\n  //  \"c\": 3.3}, 'parseJson(string_value)[key]' will pass the map value from\r\n  //  the struct map to the current task.\r\n  //\r\n  // If unset, the value will be passed directly to the current task.\r\n  parameterExpressionSelector?: string;\r\n}\r\n\r\n// Represents an upstream task's output parameter.\r\nexport interface TaskOutputParameterSpec {\r\n  // The name of the upstream task which produces the output parameter that\r\n  // matches with the `output_parameter_key`.\r\n  producerTask: string;\r\n\r\n  // The key of [TaskOutputsSpec.parameters][] map of the producer task.\r\n  outputParameterKey: string;\r\n}\r\n\r\n// Represents an upstream task's final status. The field can only be set if\r\n// the schema version is `2.0.0`. The resolved input parameter will be a\r\n// json payload in string type.\r\nexport interface TaskFinalStatus {\r\n  // The name of the upsteram task where the final status is coming from.\r\n  producerTask: string;\r\n}\r\n\r\n// The spec of task outputs.\r\nexport interface TaskOutputsSpec {\r\n  // A map of output parameters which are small values, stored by the system and\r\n  // can be queried. The output key is used\r\n  // by [TaskInputsSpec.InputParameterSpec][] of the downstream task to specify\r\n  // the data dependency. The same key will also be used by\r\n  // [ExecutorInput.Inputs][] to reference the output parameter.\r\n  parameters?: { [k: string]: OutputParameterSpec };\r\n  // A map of output artifacts. Keyed by output key. The output key is used\r\n  // by [TaskInputsSpec.InputArtifactSpec][] of the downstream task to specify\r\n  // the data dependency. The same key will also be used by\r\n  // [ExecutorInput.Inputs][] to reference the output artifact.\r\n  artifacts?: { [k: string]: OutputArtifactSpec };\r\n}\r\n\r\n// The specification of a task output artifact.\r\nexport interface OutputArtifactSpec {\r\n  // The type of the artifact.\r\n  artifactType: ArtifactTypeSchema;\r\n\r\n  // The properties of the artifact, which are determined either at\r\n  // compile-time, or at pipeline submission time through runtime parameters\r\n  properties?: { [k: string]: ValueOrRuntimeParameter };\r\n\r\n  // The custom properties of the artifact, which are determined either at\r\n  // compile-time, or at pipeline submission time through runtime parameters\r\n  customProperties?: { [k: string]: ValueOrRuntimeParameter };\r\n}\r\n\r\n// Specification for output parameters produced by the task.\r\nexport interface OutputParameterSpec {\r\n  // Required field. The type of the output parameter.\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// Represent primitive types.\r\nexport enum PrimitiveTypeEnum {\r\n  PRIMITIVE_TYPE_UNSPECIFIED = \"PRIMITIVE_TYPE_UNSPECIFIED\",\r\n  INT = \"INT\",\r\n  DOUBLE = \"DOUBLE\",\r\n  STRING = \"STRING\",\r\n}\r\n\r\n// The spec of a pipeline task.\r\nexport interface PipelineTaskSpec {\r\n  // Basic info of a pipeline task.\r\n  taskInfo?: PipelineTaskInfo;\r\n\r\n  // Specification for task inputs which contains parameters and artifacts.\r\n  // <Alexey Volkov>: This should have been named: `arguments: TaskArguments`\r\n  inputs?: TaskArgumentsSpec;\r\n\r\n  // A list of names of upstream tasks that do not provide input\r\n  // artifacts for this task, but nonetheless whose completion this task depends\r\n  // on.\r\n  dependentTasks?: string[];\r\n\r\n  cachingOptions?: CachingOptions;\r\n\r\n  // Reference to a component.  Use this field to define either a DAG or an\r\n  // executor.\r\n  componentRef: ComponentRef;\r\n\r\n  // Trigger policy of the task.\r\n  triggerPolicy?: TriggerPolicy;\r\n\r\n  // Iterator supports fanning out the task into multiple sub-tasks based on the\r\n  // values of input artifact or parameter. The current task will become the\r\n  // parent of all the fan-out tasks. The output of the current task follows\r\n  // the following conventions:\r\n  // * Output artifacts with the same name of each iteration will be merged\r\n  //   into one output artifact channel of the parent iterator task.\r\n  // * Output parameters with the same name of each iteration will be merged\r\n  //   into a string output parameter with the same name with content being a\r\n  //   JSON array.\r\n  //\r\n  // For example, if an iterator starts two sub-tasks (t1 and t2) with the\r\n  // following outputs.\r\n  //\r\n  // t1.outputs.parameters = { 'p': 'v1' }\r\n  // t1.outputs.artifacts = { 'a': [a1] }\r\n  // t2.outputs.parameters = { 'p': 'v2' }\r\n  // t2.outputs.artifacts = { 'a': [a2] }\r\n  // parent_task.outputs.parameters = { 'p': '[\"v1\", \"v2\"]' }\r\n  // parent_task.outputs.artifacts = { 'a': [a1, a2] }\r\n  //oneof iterator {\r\n  // Iterator to iterate over an artifact input.\r\n  artifactIterator?: ArtifactIteratorSpec;\r\n  // Iterator to iterate over a parameter input.\r\n  parameterIterator?: ParameterIteratorSpec;\r\n  //}\r\n}\r\n\r\nexport interface CachingOptions {\r\n  // Whether or not to enable cache for this task. Defaults to false.\r\n  enableCache: boolean;\r\n}\r\n\r\n// Trigger policy defines how the task gets triggered. If a task is not\r\n// triggered, it will run into SKIPPED state.\r\nexport interface TriggerPolicy {\r\n  // An expression which will be evaluated into a boolean value. True to\r\n  // trigger the task to run. The expression follows the language of\r\n  // [CEL Spec][https://github.com/google/cel-spec]. It can access the data\r\n  // from [ExecutorInput][] message of the task.\r\n  // For example:\r\n  // - `inputs.artifacts['model'][0].properties['accuracy']*100 > 90`\r\n  // - `inputs.parameters['type'] == 'foo' && inputs.parameters['num'] == 1`\r\n  condition: string;\r\n\r\n  // The trigger strategy of this task.  The `strategy` and `condition` are\r\n  // in logic \"AND\", as a task will only be tested for the `condition` when\r\n  // the `strategy` is meet.\r\n  // Unset or set to default value of TRIGGER_STRATEGY_UNSPECIFIED behaves the\r\n  // same as ALL_UPSTREAM_TASKS_SUCCEEDED.\r\n  strategy: TriggerStrategy;\r\n}\r\n\r\n// An enum defines the trigger strategy of when the task will be ready to be\r\n// triggered.\r\n// ALL_UPSTREAM_TASKS_SUCCEEDED - all upstream tasks in succeeded state.\r\n// ALL_UPSTREAM_TASKS_COMPLETED - all upstream tasks in any final state.\r\n// (Note that CANCELLED is also a final state but job will not trigger new\r\n// tasks when job is in CANCELLING state, so that the task with the trigger\r\n// policy at ALL_UPSTREAM_TASKS_COMPLETED will not start when job\r\n// cancellation is in progress.)\r\nenum TriggerStrategy {\r\n  // Unspecified.  Behave the same as ALL_UPSTREAM_TASKS_SUCCEEDED.\r\n  TRIGGER_STRATEGY_UNSPECIFIED = \"TRIGGER_STRATEGY_UNSPECIFIED\",\r\n  // Specifies that all upstream tasks are in succeeded state.\r\n  ALL_UPSTREAM_TASKS_SUCCEEDED = \"ALL_UPSTREAM_TASKS_SUCCEEDED\",\r\n  // Specifies that all upstream tasks are in any final state.\r\n  ALL_UPSTREAM_TASKS_COMPLETED = \"ALL_UPSTREAM_TASKS_COMPLETED\",\r\n}\r\n\r\n// The spec of an artifact iterator. It supports fan-out a workflow from a list\r\n// of artifacts.\r\nexport interface ArtifactIteratorSpec {\r\n  // The items to iterate.\r\n  items: ArtifactItemsSpec;\r\n  // The name of the input artifact channel which has the artifact item from the\r\n  // [items][] collection.\r\n  itemInput: string;\r\n}\r\n// Specifies the name of the artifact channel which contains the collection of\r\n// items to iterate. The iterator will create a sub-task for each item of\r\n// the collection and pass the item as a new input artifact channel as\r\n// specified by [item_input][].\r\nexport interface ArtifactItemsSpec {\r\n  // The name of the input artifact.\r\n  inputArtifact: string;\r\n}\r\n\r\n// The spec of a parameter iterator. It supports fan-out a workflow from a\r\n// string parameter which contains a JSON array.\r\nexport interface ParameterIteratorSpec {\r\n  // The items to iterate.\r\n  items: ParameterItemsSpec;\r\n  // The name of the input parameter which has the item value from the\r\n  // [items][] collection.\r\n  itemInput: string;\r\n}\r\n\r\n// Specifies the spec to describe the parameter items to iterate.\r\nexport type ParameterItemsSpec =\r\n  // Specifies where to get the collection of items to iterate. The iterator\r\n  // will create a sub-task for each item of the collection and pass the item\r\n  // as a new input parameter as specified by [item_input][].\r\n  // The raw JSON array.\r\n  | { raw: string }\r\n  // The name of the input parameter whose value has the items collection.\r\n  // The parameter must be in STRING type and its content can be parsed\r\n  // as a JSON array.\r\n  | { input_parameter: string };\r\n\r\nexport interface ComponentRef {\r\n  // The name of a component. Refer to the key of the\r\n  // [PipelineSpec.components][] map.\r\n  name: string;\r\n}\r\n\r\n// Basic info of a pipeline.\r\nexport interface PipelineInfo {\r\n  // Required field. The name of the pipeline.\r\n  // The name will be used to create or find pipeline context in MLMD.\r\n  name: string;\r\n}\r\n\r\n// The definition of a artifact type in MLMD.\r\nexport type ArtifactTypeSchema =\r\n  // The name of the type. The format of the title must be:\r\n  // `<namespace>.<title>.<version>`.\r\n  // Examples:\r\n  //  - `aiplatform.Model.v1`\r\n  //  - `acme.CustomModel.v2`\r\n  // When this field is set, the export type must be pre-registered in the MLMD\r\n  // store.\r\n  | { schemaTitle: string }\r\n\r\n  // Points to a YAML file stored on Google Cloud Storage describing the\r\n  // format.\r\n  | { schemaUri: string }\r\n\r\n  // Contains a raw YAML string, describing the format of\r\n  // the properties of the type.\r\n  | { instanceSchema: string };\r\n\r\n// The basic info of a task.\r\nexport interface PipelineTaskInfo {\r\n  // The unique name of the task within the pipeline definition. This name\r\n  // will be used in downstream tasks to indicate task and data dependencies.\r\n  // <Alexey Volkov>: This ^^^ does not seem to be true. This name seems to be used only as display name.\r\n  name: string;\r\n}\r\n\r\n// Definition for a value or reference to a runtime parameter. A\r\n// ValueOrRuntimeParameter instance can be either a field value that is\r\n// determined during compilation time, or a runtime parameter which will be\r\n// determined during runtime.\r\nexport type ValueOrRuntimeParameter =\r\n  // Constant value which is determined in compile time.\r\n  | { constantValue: MlmdValue }\r\n  // The runtime parameter refers to the parent component input parameter.\r\n  | { runtimeParameter: string };\r\n\r\nexport type MlmdValue =\r\n  | {\r\n      stringValue: string;\r\n    }\r\n  | {\r\n      intValue: number;\r\n    }\r\n  | {\r\n      doubleValue: number;\r\n    };\r\n\r\n// The definition of the deployment config of the pipeline. It contains the\r\n// the platform specific executor configs for KFP OSS.\r\nexport interface PipelineDeploymentConfig {\r\n  // Map from executor label to executor spec.\r\n  executors: { [k: string]: ExecutorSpec };\r\n}\r\n\r\n// The specification on a container invocation.\r\n// The string fields of the message support string based placeholder contract\r\n// defined in [ExecutorInput](). The output of the container follows the\r\n// contract of [ExecutorOutput]().\r\nexport interface PipelineContainerSpec {\r\n  // The image uri of the container.\r\n  image: string;\r\n  // The main entrypoint commands of the container to run. If not provided,\r\n  // fallback to use the entry point command defined in the container image.\r\n  command?: string[];\r\n  // The arguments to pass into the main entrypoint of the container.\r\n  args?: string[];\r\n\r\n  // The lifecycle hooks of the container executor.\r\n  // lifecycle: Lifecycle;\r\n\r\n  resources?: ResourceSpec;\r\n}\r\n\r\n// The specification on the resource requirements of a container execution.\r\n// This can include specification of vCPU, memory requirements, as well as\r\n// accelerator types and counts.\r\nexport interface ResourceSpec {\r\n  // The limit of the number of vCPU cores. This container execution needs\r\n  // at most cpu_limit vCPU to run.\r\n  cpuLimit: number;\r\n\r\n  // The memory limit in GB. This container execution needs at most\r\n  // memory_limit RAM to run.\r\n  memoryLimit: number;\r\n\r\n  accelerator: AcceleratorConfig;\r\n}\r\n\r\n// The specification of the executor.\r\nexport type ExecutorSpec =\r\n  // Starts a container.\r\n  { container: PipelineContainerSpec };\r\n// Import an artifact.\r\n//| { importer: ImporterSpec }\r\n// Resolves an existing artifact.\r\n//| { resolver: ResolverSpec }\r\n// Starts a Google Cloud AI Platform CustomJob.\r\n//| { custom_job: AIPlatformCustomJobSpec };\r\n\r\n// The specification on the accelerators being attached to this container.\r\nexport interface AcceleratorConfig {\r\n  // The type of accelerators.\r\n  type: string;\r\n  // The number of accelerators.\r\n  count: number;\r\n}\r\n\r\n// Missing: Lifecycle\r\n// Missing: ImporterSpec\r\n// Missing: ResolverSpec\r\n// Missing: RuntimeArtifact\r\n// Missing: ArtifactList\r\n// Missing: ExecutorInput\r\n// Missing: ExecutorOutput\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  ArgumentType,\r\n  ComponentSpec,\r\n  StringOrPlaceholder,\r\n  TypeSpecType,\r\n  isContainerImplementation,\r\n  isGraphImplementation,\r\n  InputSpec,\r\n} from \"../componentSpec\";\r\n\r\nimport * as vertex from \"./vertexPipelineSpec\";\r\n\r\n// # How to handle I/O:\r\n// Rules (might have exceptions)\r\n// output = output artifact\r\n// inputValue => input parameter\r\n// inputPath => input artifact\r\n// # Fixing conflicts:\r\n// 1) Artifact (may only come from task output) is consumed as value.\r\n//   Solution 1) (implemented): Change input from parameter to artifact and use the input.artifact.value placeholder.\r\n//      Cons: The downstream component input definitions depend on arguments. (Some inputs are changed from parameter to artifact.)\r\n//   Solution 2): Add parameter output (with the same name as the artifact output) to the upstream component. The paths should be the same, so a single file will be treated as both parameter and output.\r\n//      Cons: The upstream component output definitions depend on downstream consumption style. (Although parameter outputs are added, not changed.)\r\n//   Solution 3): Insert a \"Downloader\" task between upstream and downstream.\r\n//      Cons: Extra container task\r\n// 2) Parameter (pipeline input or constant value) is consumed as artifact (as file).\r\n//   Solution 1): Insert a \"Uploader\" task to convert parameter to artifact.\r\n//      Cons: Extra container task\r\n\r\nconst sanitizePipelineInfoName = (pipelineContextName: string) => {\r\n  return pipelineContextName.toLowerCase().replace(/\\W/, \"-\");\r\n};\r\n\r\ntype ResolvedCommandLineAndArgs = {\r\n  command?: string[];\r\n  args?: string[];\r\n  inputsConsumedAsParameter: Set<string>;\r\n  inputsConsumedAsArtifact: Set<string>;\r\n};\r\n\r\nconst resolveCommandLine = (\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>\r\n): ResolvedCommandLineAndArgs => {\r\n  if (!isContainerImplementation(componentSpec.implementation)) {\r\n    throw Error(\"resolveCommandLine only supports container components\");\r\n  }\r\n  const containerSpec = componentSpec.implementation.container;\r\n\r\n  const inputsConsumedAsParameter = new Set<string>();\r\n  const inputsConsumedAsArtifact = new Set<string>();\r\n  const convertArg = (arg: StringOrPlaceholder): string[] => {\r\n    if (typeof arg == \"string\") {\r\n      return [arg];\r\n    } else if (\"inputValue\" in arg) {\r\n      const inputName = arg.inputValue;\r\n      if (!inputsThatHaveParameterArguments.has(inputName)) {\r\n        // ! Important details:\r\n        // In this branch, the argument comes from task output (or graph input with artifact argument).\r\n        // All outputs are artifacts by default, so this argument is an artifact argument.\r\n        // We can either try to change the argument to parameter or make the input to be an artifact to solve the conflict.\r\n        // I choose to make the input to be artifact.\r\n        // Adding input name to inputsConsumedAsPath to make the input rendered as an artifact input.\r\n        inputsConsumedAsArtifact.add(inputName);\r\n        return [`{{$.inputs.artifacts['${inputName}'].value}}`];\r\n      } else {\r\n        inputsConsumedAsParameter.add(inputName);\r\n        return [`{{$.inputs.parameters['${inputName}']}}`];\r\n      }\r\n    } else if (\"inputPath\" in arg) {\r\n      const inputName = arg.inputPath;\r\n      inputsConsumedAsArtifact.add(inputName);\r\n      return [`{{$.inputs.artifacts['${inputName}'].path}}`];\r\n    } else if (\"outputPath\" in arg) {\r\n      const outputName = arg.outputPath;\r\n      return [`{{$.outputs.artifacts['${outputName}'].path}}`];\r\n    } else if (\"if\" in arg) {\r\n      const [ifCond, ifThen, ifElse] = [arg.if.cond, arg.if.then, arg.if.else];\r\n      // TODO: Check false values, not just check for true\r\n      let condEvaluatesToTrue = false;\r\n      if (typeof ifCond === \"string\") {\r\n        condEvaluatesToTrue = ifCond.toLowerCase() === \"true\";\r\n      } else if (typeof ifCond === \"boolean\") {\r\n        condEvaluatesToTrue = ifCond;\r\n      } else if (\"isPresent\" in ifCond) {\r\n        const inputName = ifCond.isPresent;\r\n        condEvaluatesToTrue = inputName in taskArguments;\r\n      } else if (\"inputValue\" in ifCond) {\r\n        const inputName = ifCond.inputValue;\r\n        if (!(inputName in taskArguments)) {\r\n          condEvaluatesToTrue = false;\r\n        } else {\r\n          const taskArgument = taskArguments[inputName];\r\n          if (typeof taskArgument === \"string\") {\r\n            condEvaluatesToTrue = taskArgument.toLowerCase() === \"true\";\r\n          } else {\r\n            throw Error(\r\n              \"Using runtime conditions in component command line placeholders is not supported yet.\"\r\n            );\r\n          }\r\n        }\r\n      } else {\r\n        throw Error(\"Unexpected condition kind: \" + ifCond);\r\n      }\r\n      const unresolvedArgs = condEvaluatesToTrue ? ifThen : ifElse;\r\n      if (unresolvedArgs === undefined) {\r\n        return [];\r\n      }\r\n      return unresolvedArgs.flatMap(convertArg);\r\n    } else if (\"concat\" in arg) {\r\n      const concatArgs = arg.concat;\r\n      return [concatArgs.flatMap(convertArg).join(\"\")];\r\n    } else {\r\n      throw Error(`Unknown kind of command-line argument: ${arg}`);\r\n    }\r\n  };\r\n\r\n  const result = {\r\n    command: containerSpec.command?.flatMap(convertArg),\r\n    args: containerSpec.args?.flatMap(convertArg),\r\n    inputsConsumedAsParameter: inputsConsumedAsParameter,\r\n    inputsConsumedAsArtifact: inputsConsumedAsArtifact,\r\n  };\r\n  return result;\r\n};\r\n\r\nconst typeSpecToVertexPrimitiveTypeEnum = (\r\n  typeSpec: TypeSpecType | undefined\r\n): vertex.PrimitiveTypeEnum => {\r\n  if (typeof typeSpec === \"string\") {\r\n    if ([\"integer\"].includes(typeSpec.toLowerCase())) {\r\n      return vertex.PrimitiveTypeEnum.INT;\r\n    }\r\n    if ([\"float\", \"double\"].includes(typeSpec.toLowerCase())) {\r\n      return vertex.PrimitiveTypeEnum.DOUBLE;\r\n    }\r\n  }\r\n  return vertex.PrimitiveTypeEnum.STRING;\r\n};\r\n\r\nconst typeSpecToVertexParameterSpec = (\r\n  typeSpec: TypeSpecType | undefined\r\n): vertex.InputParameterSpec => {\r\n  return {\r\n    type: typeSpecToVertexPrimitiveTypeEnum(typeSpec),\r\n  };\r\n};\r\n\r\nconst typeSpecToVertexArtifactTypeSchema = (\r\n  typeSpec: TypeSpecType | undefined\r\n): vertex.ArtifactTypeSchema => {\r\n  // TODO: Implement better mapping\r\n  const artifactTypeSchema = {\r\n    schemaTitle: \"system.Artifact\",\r\n  };\r\n  return artifactTypeSchema;\r\n};\r\n\r\nconst typeSpecToVertexArtifactSpec = (\r\n  typeSpec: TypeSpecType | undefined\r\n): vertex.InputArtifactSpec => {\r\n  return {\r\n    artifactType: typeSpecToVertexArtifactTypeSchema(typeSpec),\r\n  };\r\n};\r\n// const typeSpecToVertexArtifactType(typeSpec: TypeSpecType) => {\r\n//     return typeof typeSpec === \"string\" && [\"String\", \"Integer\", \"Float\", \"Double\", \"Boolean\", ]\r\n// }\r\n\r\nconst stringToMlmdValue = (\r\n  constantString: string,\r\n  primitiveType: vertex.PrimitiveTypeEnum\r\n): vertex.MlmdValue => {\r\n  switch (primitiveType) {\r\n    case vertex.PrimitiveTypeEnum.STRING:\r\n      return {\r\n        stringValue: constantString,\r\n      };\r\n    case vertex.PrimitiveTypeEnum.INT:\r\n      return {\r\n        intValue: parseInt(constantString),\r\n      };\r\n    case vertex.PrimitiveTypeEnum.DOUBLE:\r\n      return {\r\n        doubleValue: parseFloat(constantString),\r\n      };\r\n    default:\r\n      throw Error(`Unknown primitive type ${primitiveType}`);\r\n  }\r\n};\r\n\r\nconst MAKE_ARTIFACT_COMPONENT_ID = \"_make_artifact\";\r\nconst MAKE_ARTIFACT_EXECUTOR_ID = \"_make_artifact\";\r\nconst MAKE_ARTIFACT_INPUT_NAME = \"parameter\";\r\nconst MAKE_ARTIFACT_OUTPUT_NAME = \"artifact\";\r\n\r\nconst buildMakeArtifactTaskSpec = (\r\n  parameterArgumentSpec: vertex.ParameterArgumentSpec\r\n): vertex.PipelineTaskSpec => {\r\n  const taskSpec: vertex.PipelineTaskSpec = {\r\n    componentRef: {\r\n      name: MAKE_ARTIFACT_COMPONENT_ID,\r\n    },\r\n    taskInfo: {\r\n      name: \"Make artifact\",\r\n    },\r\n    inputs: {\r\n      parameters: {\r\n        [MAKE_ARTIFACT_INPUT_NAME]: parameterArgumentSpec,\r\n      },\r\n    },\r\n    cachingOptions: {\r\n      enableCache: true,\r\n    },\r\n  };\r\n  return taskSpec;\r\n};\r\n\r\nconst makeArtifactComponentSpec: vertex.ComponentSpec = {\r\n  executorLabel: MAKE_ARTIFACT_EXECUTOR_ID,\r\n  inputDefinitions: {\r\n    parameters: {\r\n      [MAKE_ARTIFACT_INPUT_NAME]: {\r\n        type: vertex.PrimitiveTypeEnum.STRING,\r\n      },\r\n    },\r\n  },\r\n  outputDefinitions: {\r\n    artifacts: {\r\n      [MAKE_ARTIFACT_OUTPUT_NAME]: {\r\n        artifactType: {\r\n          schemaTitle: \"system.Artifact\",\r\n        },\r\n      },\r\n    },\r\n  },\r\n};\r\n\r\nconst makeArtifactExecutorSpec: vertex.ExecutorSpec = {\r\n  container: {\r\n    image: \"alpine\",\r\n    command: [\r\n      \"sh\",\r\n      \"-ec\",\r\n      'mkdir -p \"$(dirname \"$1\")\"; printf \"%s\" \"$0\" > \"$1\"',\r\n      `{{$.inputs.parameters['${MAKE_ARTIFACT_INPUT_NAME}']}}`,\r\n      `{{$.outputs.artifacts['${MAKE_ARTIFACT_OUTPUT_NAME}'].path}}`,\r\n    ],\r\n  },\r\n};\r\n\r\nfunction buildVertexParameterArgumentSpec(\r\n  taskArgument: ArgumentType | undefined,\r\n  inputSpec: InputSpec\r\n) {\r\n  if (taskArgument === undefined) {\r\n    if (inputSpec.default !== undefined) {\r\n      taskArgument = inputSpec.default;\r\n    } else {\r\n      if (inputSpec.optional === true) {\r\n        // TODO: Decide what the behavior should be\r\n        // throw Error(`Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`);\r\n        console.error(\r\n          `Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`\r\n        );\r\n        taskArgument = \"\";\r\n      } else {\r\n        throw Error(\r\n          `Argument was not provided for required input \"${inputSpec.name}\"`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  let result: vertex.ParameterArgumentSpec;\r\n  if (typeof taskArgument === \"string\") {\r\n    result = {\r\n      runtimeValue: {\r\n        constantValue: stringToMlmdValue(\r\n          taskArgument,\r\n          typeSpecToVertexPrimitiveTypeEnum(inputSpec.type)\r\n        ),\r\n      },\r\n    };\r\n    return result;\r\n  } else if (\"graphInput\" in taskArgument) {\r\n    result = {\r\n      componentInputParameter: taskArgument.graphInput.inputName,\r\n    };\r\n    return result;\r\n  } else if (\"taskOutput\" in taskArgument) {\r\n    result = {\r\n      taskOutputParameter: {\r\n        producerTask: taskArgument.taskOutput.taskId,\r\n        outputParameterKey: taskArgument.taskOutput.outputName,\r\n      },\r\n    };\r\n    return result;\r\n  } else {\r\n    throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n  }\r\n}\r\n\r\nfunction buildVertexArtifactArgumentSpec(\r\n  taskArgument: ArgumentType | undefined,\r\n  inputSpec: InputSpec,\r\n  upstreamCannotBeArtifact: boolean,\r\n  addMakeArtifactTaskAndGetArtifactArgumentSpec: (\r\n    parameterArgumentSpec: vertex.ParameterArgumentSpec,\r\n    namePrefix?: string\r\n  ) => vertex.ArtifactArgumentSpec\r\n) {\r\n  //if (! (inputName in taskArguments)) {\r\n  if (taskArgument === undefined) {\r\n    // Checking for default value\r\n    if (inputSpec.default !== undefined) {\r\n      taskArgument = inputSpec.default;\r\n    } else {\r\n      if (inputSpec.optional === true) {\r\n        // TODO: Decide what the behavior should be\r\n        // throw Error(`Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`);\r\n        console.error(\r\n          `Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`\r\n        );\r\n        taskArgument = \"\";\r\n      } else {\r\n        throw Error(\r\n          `Argument was not provided for required input \"${inputSpec.name}\"`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  let result: vertex.ArtifactArgumentSpec;\r\n  if (typeof taskArgument === \"string\") {\r\n    const parameterArgumentSpec: vertex.ParameterArgumentSpec = {\r\n      runtimeValue: {\r\n        constantValue: {\r\n          // TODO: Check whether string is always OK here\r\n          stringValue: taskArgument,\r\n        },\r\n      },\r\n    };\r\n    // TODO: Maybe use the taskArgument as part of the name?\r\n    const convertedArtifactArgumentSpec =\r\n      addMakeArtifactTaskAndGetArtifactArgumentSpec(\r\n        parameterArgumentSpec,\r\n        \"Make artifact\"\r\n      );\r\n    result = convertedArtifactArgumentSpec;\r\n    return result;\r\n  } else if (\"graphInput\" in taskArgument) {\r\n    // Workaround for root DAG where all inputs must be parameters\r\n    if (upstreamCannotBeArtifact) {\r\n      const parameterArgumentSpec: vertex.ParameterArgumentSpec = {\r\n        componentInputParameter: taskArgument.graphInput.inputName,\r\n      };\r\n      // We only need one task for each pipeline input parameter\r\n      const convertedArtifactArgumentSpec =\r\n        addMakeArtifactTaskAndGetArtifactArgumentSpec(\r\n          parameterArgumentSpec,\r\n          \"Make artifact for \" + taskArgument.graphInput.inputName\r\n        );\r\n      result = convertedArtifactArgumentSpec;\r\n    } else {\r\n      result = {\r\n        componentInputArtifact: taskArgument.graphInput.inputName,\r\n      };\r\n    }\r\n    return result;\r\n  } else if (\"taskOutput\" in taskArgument) {\r\n    result = {\r\n      taskOutputArtifact: {\r\n        producerTask: taskArgument.taskOutput.taskId,\r\n        outputArtifactKey: taskArgument.taskOutput.outputName,\r\n      },\r\n    };\r\n    return result;\r\n  } else {\r\n    throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n  }\r\n}\r\n\r\nconst assertDefined = <T>(obj: T | undefined) => {\r\n  if (obj === undefined) {\r\n    throw TypeError(\"Object is undefined\");\r\n  }\r\n  return obj;\r\n};\r\n\r\nconst transformRecordValues = <T1, T2>(\r\n  record: Record<string, T1>,\r\n  transform: (value: T1) => T2\r\n) =>\r\n  Object.fromEntries(\r\n    Object.entries(record).map(([key, value]) => [key, transform(value)])\r\n  );\r\n\r\nfunction buildVertexComponentSpecFromContainerComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>,\r\n  addExecutorAndGetId: (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix?: string | undefined\r\n  ) => string\r\n) {\r\n  if (!isContainerImplementation(componentSpec.implementation)) {\r\n    throw Error(\"Only container components are supported by this function\");\r\n  }\r\n\r\n  const containerSpec = componentSpec.implementation.container;\r\n\r\n  const resolvedCommandLine = resolveCommandLine(\r\n    componentSpec,\r\n    taskArguments,\r\n    inputsThatHaveParameterArguments\r\n  );\r\n\r\n  const vertexExecutorSpec: vertex.ExecutorSpec = {\r\n    container: {\r\n      image: containerSpec.image,\r\n      command: resolvedCommandLine.command,\r\n      args: resolvedCommandLine.args,\r\n    },\r\n  };\r\n\r\n  const vertexExecutorId = addExecutorAndGetId(\r\n    vertexExecutorSpec,\r\n    componentSpec.name ?? \"Component\"\r\n  );\r\n\r\n  const inputMap = new Map(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => [inputSpec.name, inputSpec])\r\n  );\r\n\r\n  const vertexComponentInputsSpec: vertex.ComponentInputsSpec = {\r\n    parameters: Object.fromEntries(\r\n      Array.from(resolvedCommandLine.inputsConsumedAsParameter.values()).map(\r\n        (inputName) => [\r\n          inputName,\r\n          typeSpecToVertexParameterSpec(inputMap.get(inputName)?.type),\r\n        ]\r\n      )\r\n    ),\r\n    artifacts: Object.fromEntries(\r\n      Array.from(resolvedCommandLine.inputsConsumedAsArtifact.values()).map(\r\n        (inputName) => [\r\n          inputName,\r\n          typeSpecToVertexArtifactSpec(inputMap.get(inputName)?.type),\r\n        ]\r\n      )\r\n    ),\r\n  };\r\n\r\n  const vertexComponentOutputsSpec: vertex.ComponentOutputsSpec = {\r\n    parameters: {},\r\n    artifacts: Object.fromEntries(\r\n      (componentSpec.outputs ?? []).map((outputSpec) => [\r\n        outputSpec.name,\r\n        typeSpecToVertexArtifactSpec(outputSpec.type),\r\n      ])\r\n    ),\r\n  };\r\n\r\n  const vertexComponentSpec: vertex.ComponentSpec = {\r\n    inputDefinitions: vertexComponentInputsSpec,\r\n    outputDefinitions: vertexComponentOutputsSpec,\r\n    // dag\r\n    executorLabel: vertexExecutorId,\r\n  };\r\n  return vertexComponentSpec;\r\n}\r\n\r\nfunction buildVertexComponentSpecFromGraphComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>,\r\n  addExecutorAndGetId: (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix?: string\r\n  ) => string,\r\n  addComponentAndGetId: (\r\n    component: vertex.ComponentSpec,\r\n    namePrefix?: string\r\n  ) => string\r\n) {\r\n  if (!isGraphImplementation(componentSpec.implementation)) {\r\n    throw Error(\"Only graph components are supported by this function\");\r\n  }\r\n\r\n  const graphSpec = componentSpec.implementation.graph;\r\n\r\n  const inputsConsumedAsParameter = new Set<string>();\r\n  const inputsConsumedAsArtifact = new Set<string>();\r\n\r\n  let vertexTasks: Record<string, vertex.PipelineTaskSpec> = {};\r\n  const taskStringToTaskId = new Map<string, string>();\r\n\r\n  const addTaskAndGetId = (\r\n    task: vertex.PipelineTaskSpec,\r\n    namePrefix: string = \"Task\"\r\n  ) => {\r\n    const serializedSpec = JSON.stringify(task);\r\n    const existingId = taskStringToTaskId.get(serializedSpec);\r\n    if (existingId !== undefined) {\r\n      return existingId;\r\n    }\r\n    const usedIds = new Set(Object.keys(vertexTasks));\r\n    const id = makeNameUniqueByAddingIndex(namePrefix, usedIds);\r\n    taskStringToTaskId.set(serializedSpec, id);\r\n    vertexTasks[id] = task;\r\n    return id;\r\n  };\r\n\r\n  const addMakeArtifactTaskAndGetArtifactArgumentSpec = (\r\n    parameterArgumentSpec: vertex.ParameterArgumentSpec,\r\n    namePrefix: string = \"Make artifact\"\r\n  ) => {\r\n    // These system names are expected to not conflict with user task names\r\n    const makeArtifactExecutorId = addExecutorAndGetId(\r\n      makeArtifactExecutorSpec,\r\n      MAKE_ARTIFACT_EXECUTOR_ID\r\n    );\r\n    const makeArtifactComponentSpecCopy = {\r\n      ...makeArtifactComponentSpec,\r\n      executorLabel: makeArtifactExecutorId,\r\n    };\r\n    const makeArtifactComponentsId = addComponentAndGetId(\r\n      makeArtifactComponentSpecCopy,\r\n      MAKE_ARTIFACT_COMPONENT_ID\r\n    );\r\n    const makeArtifactTaskSpec = buildMakeArtifactTaskSpec(\r\n      parameterArgumentSpec\r\n    );\r\n    makeArtifactTaskSpec.componentRef.name = makeArtifactComponentsId;\r\n    const taskId = addTaskAndGetId(makeArtifactTaskSpec, namePrefix);\r\n    const artifactArgumentSpec: vertex.ArtifactArgumentSpec = {\r\n      taskOutputArtifact: {\r\n        producerTask: taskId,\r\n        outputArtifactKey: MAKE_ARTIFACT_OUTPUT_NAME,\r\n      },\r\n    };\r\n    return artifactArgumentSpec;\r\n  };\r\n\r\n  for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n    if (taskSpec.componentRef.spec === undefined) {\r\n      throw Error(`Task \"${taskId}\" does not have taskSpec.componentRef.spec.`);\r\n    }\r\n    try {\r\n      const vertexTaskSpec = buildVertexTaskSpecFromTaskSpec(\r\n        taskSpec.componentRef.spec,\r\n        taskSpec.arguments ?? {},\r\n        inputsThatHaveParameterArguments,\r\n        addExecutorAndGetId,\r\n        addComponentAndGetId,\r\n        addMakeArtifactTaskAndGetArtifactArgumentSpec\r\n      );\r\n      if (taskId in vertexTasks) {\r\n        throw Error(\r\n          `Task ID \"${taskId}\" is not unique. This cannot happen (unless user task ID clashes with special task ID).`\r\n        );\r\n      }\r\n      vertexTasks[taskId] = vertexTaskSpec;\r\n\r\n      for (const argument of Object.values(\r\n        vertexTaskSpec.inputs?.parameters ?? {}\r\n      )) {\r\n        if (argument.componentInputParameter !== undefined) {\r\n          inputsConsumedAsParameter.add(argument.componentInputParameter);\r\n        }\r\n      }\r\n      for (const argument of Object.values(\r\n        vertexTaskSpec.inputs?.artifacts ?? {}\r\n      )) {\r\n        if (\"componentInputArtifact\" in argument) {\r\n          inputsConsumedAsArtifact.add(argument.componentInputArtifact);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      if (err instanceof Error) {\r\n        err.message = `Error compiling task ${taskId}: ` + err.message;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Sanity checks\r\n  const inputNamesThatAreUsedBothAsParameterAndArtifact = Array.from(\r\n    inputsConsumedAsParameter\r\n  ).filter((x) => inputsConsumedAsArtifact.has(x));\r\n  if (inputNamesThatAreUsedBothAsParameterAndArtifact.length > 0) {\r\n    throw Error(\r\n      `Compiler error: Some inputs are used both as parameter and artifact: \"${inputNamesThatAreUsedBothAsParameterAndArtifact}\". Please file a bug report.`\r\n    );\r\n  }\r\n  const inputNamesThatAreParametersButAreConsumedAsArtifacts = Array.from(\r\n    inputsThatHaveParameterArguments\r\n  ).filter((x) => inputsConsumedAsArtifact.has(x));\r\n  if (inputNamesThatAreParametersButAreConsumedAsArtifacts.length > 0) {\r\n    throw Error(\r\n      `Compiler error: Some parameter inputs are consumer as artifact: \"${inputNamesThatAreParametersButAreConsumedAsArtifacts}\". Please file a bug report.`\r\n    );\r\n  }\r\n\r\n  const dagOutputArtifactSpecs = transformRecordValues(\r\n    graphSpec.outputValues ?? {},\r\n    (taskOutputArgument) => {\r\n      const result: vertex.DagOutputArtifactSpec = {\r\n        artifactSelectors: [\r\n          {\r\n            producerSubtask: taskOutputArgument.taskOutput.taskId,\r\n            outputArtifactKey: taskOutputArgument.taskOutput.outputName,\r\n          },\r\n        ],\r\n      };\r\n      return result;\r\n    }\r\n  );\r\n\r\n  const inputMap = new Map(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => [inputSpec.name, inputSpec])\r\n  );\r\n\r\n  const vertexComponentInputsSpec: vertex.ComponentInputsSpec = {\r\n    parameters: Object.fromEntries(\r\n      Array.from(inputsConsumedAsParameter.values()).map((inputName) => [\r\n        inputName,\r\n        typeSpecToVertexParameterSpec(inputMap.get(inputName)?.type),\r\n      ])\r\n    ),\r\n    artifacts: Object.fromEntries(\r\n      Array.from(inputsConsumedAsArtifact.values()).map((inputName) => [\r\n        inputName,\r\n        typeSpecToVertexArtifactSpec(inputMap.get(inputName)?.type),\r\n      ])\r\n    ),\r\n  };\r\n\r\n  const vertexComponentOutputsSpec: vertex.ComponentOutputsSpec = {\r\n    // parameters: {},\r\n    artifacts: Object.fromEntries(\r\n      (componentSpec.outputs ?? []).map((outputSpec) => [\r\n        outputSpec.name,\r\n        typeSpecToVertexArtifactSpec(outputSpec.type),\r\n      ])\r\n    ),\r\n  };\r\n\r\n  const vertexComponentSpec: vertex.ComponentSpec = {\r\n    inputDefinitions: vertexComponentInputsSpec,\r\n    outputDefinitions: vertexComponentOutputsSpec,\r\n    dag: {\r\n      tasks: vertexTasks,\r\n      outputs: {\r\n        artifacts: dagOutputArtifactSpecs,\r\n        // parameters: {},\r\n      },\r\n    },\r\n  };\r\n  return vertexComponentSpec;\r\n}\r\n\r\nfunction buildVertexComponentSpecFromComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>,\r\n  addExecutorAndGetId: (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix?: string\r\n  ) => string,\r\n  addComponentAndGetId: (\r\n    component: vertex.ComponentSpec,\r\n    namePrefix?: string\r\n  ) => string\r\n) {\r\n  if (isContainerImplementation(componentSpec.implementation)) {\r\n    return buildVertexComponentSpecFromContainerComponentSpec(\r\n      componentSpec,\r\n      taskArguments,\r\n      inputsThatHaveParameterArguments,\r\n      addExecutorAndGetId\r\n    );\r\n  } else if (isGraphImplementation(componentSpec.implementation)) {\r\n    return buildVertexComponentSpecFromGraphComponentSpec(\r\n      componentSpec,\r\n      taskArguments,\r\n      inputsThatHaveParameterArguments,\r\n      addExecutorAndGetId,\r\n      addComponentAndGetId\r\n    );\r\n  } else {\r\n    throw Error(\r\n      `Unsupported component implementation kind: ${componentSpec.implementation}`\r\n    );\r\n  }\r\n}\r\n\r\nconst buildVertexTaskSpecFromTaskSpec = (\r\n  componentSpec: ComponentSpec,\r\n  //passedArgumentNames: string[],\r\n  taskArguments: Record<string, ArgumentType>,\r\n  graphInputsWithParameterArguments: Set<string>,\r\n  addExecutorAndGetId: (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix?: string\r\n  ) => string,\r\n  addComponentAndGetId: (\r\n    component: vertex.ComponentSpec,\r\n    namePrefix?: string\r\n  ) => string,\r\n  addMakeArtifactTaskAndGetArtifactArgumentSpec: (\r\n    parameterArgumentSpec: vertex.ParameterArgumentSpec,\r\n    namePrefix?: string\r\n  ) => vertex.ArtifactArgumentSpec\r\n) => {\r\n  // So-called \"parameter\" arguments can either be constant arguments\r\n  // or come from the arguments to the graph component of the current task.\r\n  // In the current implementation the parameter arguments cannot come from task outputs since all task outputs are artifacts.\r\n  const inputsThatHaveParameterArguments = new Set(\r\n    (componentSpec.inputs ?? [])\r\n      .map((inputSpec) => inputSpec.name)\r\n      .filter((inputName) => {\r\n        const taskArgument = taskArguments[inputName];\r\n        if (taskArgument === undefined) {\r\n          // Missing arguments fall back to default values which are constant strings which are parameters.\r\n          return true;\r\n        }\r\n        if (typeof taskArgument === \"string\") {\r\n          return true;\r\n        }\r\n        if (\"graphInput\" in taskArgument) {\r\n          if (\r\n            graphInputsWithParameterArguments.has(\r\n              taskArgument.graphInput.inputName\r\n            )\r\n          ) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      })\r\n  );\r\n\r\n  const inputMap = new Map(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => [inputSpec.name, inputSpec])\r\n  );\r\n\r\n  const vertexComponentSpec: vertex.ComponentSpec =\r\n    buildVertexComponentSpecFromComponentSpec(\r\n      componentSpec,\r\n      taskArguments,\r\n      inputsThatHaveParameterArguments,\r\n      addExecutorAndGetId,\r\n      addComponentAndGetId\r\n    );\r\n\r\n  const vertexComponentId = addComponentAndGetId(\r\n    vertexComponentSpec,\r\n    componentSpec.name ?? \"Component\"\r\n  );\r\n\r\n  const vertexTaskParameterArguments = Object.fromEntries(\r\n    Object.keys(vertexComponentSpec.inputDefinitions?.parameters ?? {}).map(\r\n      (inputName) => [\r\n        inputName,\r\n        buildVertexParameterArgumentSpec(\r\n          taskArguments[inputName],\r\n          assertDefined(inputMap.get(inputName))\r\n        ),\r\n      ]\r\n    )\r\n  );\r\n\r\n  const vertexTaskArtifactArguments = Object.fromEntries(\r\n    Object.keys(vertexComponentSpec.inputDefinitions?.artifacts ?? {}).map(\r\n      (inputName) => [\r\n        inputName,\r\n        buildVertexArtifactArgumentSpec(\r\n          taskArguments[inputName],\r\n          assertDefined(inputMap.get(inputName)),\r\n          inputsThatHaveParameterArguments.has(inputName),\r\n          addMakeArtifactTaskAndGetArtifactArgumentSpec\r\n        ),\r\n      ]\r\n    )\r\n  );\r\n\r\n  const vertexTaskSpec: vertex.PipelineTaskSpec = {\r\n    taskInfo: {\r\n      // This is the task display name, not an ID\r\n      name: componentSpec.name ?? \"Component\",\r\n    },\r\n    inputs: {\r\n      parameters: vertexTaskParameterArguments,\r\n      artifacts: vertexTaskArtifactArguments,\r\n    },\r\n    // dependent_tasks: [],\r\n    cachingOptions: {\r\n      enableCache: true,\r\n    },\r\n    componentRef: {\r\n      name: vertexComponentId,\r\n    },\r\n    // triggerPolicy: {\r\n    //     condition: \"...\",\r\n    //     strategy: \"ALL_UPSTREAM_TASKS_SUCCEEDED\",\r\n    // },\r\n    // iterator: {\r\n    //     artifactIterator: {...},\r\n    //     parameterIterator: {...},\r\n    // },\r\n  };\r\n\r\n  return vertexTaskSpec;\r\n};\r\n\r\nconst makeNameUniqueByAddingIndex = (\r\n  name: string,\r\n  existingNames: Set<string>\r\n): string => {\r\n  let finalName = name;\r\n  let index = 1;\r\n  while (existingNames.has(finalName)) {\r\n    index++;\r\n    finalName = name + \" \" + index.toString();\r\n  }\r\n  return finalName;\r\n};\r\n\r\nexport const graphComponentSpecToVertexPipelineSpec = (\r\n  componentSpec: ComponentSpec,\r\n  pipelineContextName = \"pipeline\"\r\n) => {\r\n  let vertexExecutors: Record<string, vertex.ExecutorSpec> = {};\r\n  const executorStringToExecutorId = new Map<string, string>();\r\n  let vertexComponents: Record<string, vertex.ComponentSpec> = {};\r\n  const componentStringToComponentId = new Map<string, string>();\r\n\r\n  const addExecutorAndGetId = (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix: string = \"Executor\"\r\n  ) => {\r\n    const serializedSpec = JSON.stringify(executor);\r\n    const existingId = executorStringToExecutorId.get(serializedSpec);\r\n    if (existingId !== undefined) {\r\n      return existingId;\r\n    }\r\n    const usedIds = new Set(Object.keys(vertexExecutors));\r\n    const id = makeNameUniqueByAddingIndex(namePrefix, usedIds);\r\n    executorStringToExecutorId.set(serializedSpec, id);\r\n    vertexExecutors[id] = executor;\r\n    return id;\r\n  };\r\n\r\n  const addComponentAndGetId = (\r\n    component: vertex.ComponentSpec,\r\n    namePrefix: string = \"Component\"\r\n  ) => {\r\n    const serializedSpec = JSON.stringify(component);\r\n    const existingId = componentStringToComponentId.get(serializedSpec);\r\n    if (existingId !== undefined) {\r\n      return existingId;\r\n    }\r\n    const usedIds = new Set(Object.keys(vertexComponents));\r\n    const id = makeNameUniqueByAddingIndex(namePrefix, usedIds);\r\n    componentStringToComponentId.set(serializedSpec, id);\r\n    vertexComponents[id] = component;\r\n    return id;\r\n  };\r\n\r\n  // All root graph inputs are parameters\r\n  const graphInputsWithParameterArguments = new Set(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => inputSpec.name)\r\n  );\r\n\r\n  const pipelineArguments: Record<string, ArgumentType> = Object.fromEntries(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => {\r\n      const argument: ArgumentType = {\r\n        graphInput: { inputName: inputSpec.name },\r\n      };\r\n      return [inputSpec.name, argument];\r\n    })\r\n  );\r\n  const pipelineComponentSpec = buildVertexComponentSpecFromComponentSpec(\r\n    componentSpec,\r\n    pipelineArguments,\r\n    graphInputsWithParameterArguments,\r\n    addExecutorAndGetId,\r\n    addComponentAndGetId\r\n  );\r\n\r\n  const vertexPipelineSpec: vertex.PipelineSpec = {\r\n    pipelineInfo: {\r\n      name: sanitizePipelineInfoName(pipelineContextName),\r\n    },\r\n    sdkVersion: \"Cloud-Pipelines\",\r\n    schemaVersion: \"2.0.0\",\r\n    deploymentSpec: {\r\n      executors: vertexExecutors,\r\n    },\r\n    components: vertexComponents,\r\n    root: pipelineComponentSpec,\r\n  };\r\n  return vertexPipelineSpec;\r\n};\r\n\r\nexport const generateVertexPipelineJobFromGraphComponent = (\r\n  componentSpec: ComponentSpec,\r\n  gcsOutputDirectory: string,\r\n  pipelineArguments?: Map<string, string>,\r\n  pipelineContextName = \"pipeline\"\r\n) => {\r\n  // The pipelineContextName affects caching\r\n\r\n  const pipelineSpec = graphComponentSpecToVertexPipelineSpec(\r\n    componentSpec,\r\n    pipelineContextName\r\n  );\r\n  const inputParameterDefinitions =\r\n    (pipelineSpec.root.inputDefinitions ?? {}).parameters ?? {};\r\n\r\n  let convertedPipelineArguments: Record<string, any> = {};\r\n  if (pipelineArguments !== undefined) {\r\n    for (const [key, value] of Array.from(pipelineArguments.entries())) {\r\n      if (!(key in inputParameterDefinitions)) {\r\n        console.error(\r\n          `A pipeline argument was provided for the input \"${key}\" that does not exist in the pipeline spec.`\r\n        );\r\n        continue;\r\n      }\r\n      convertedPipelineArguments[key] = stringToMlmdValue(\r\n        value,\r\n        inputParameterDefinitions[key].type\r\n      );\r\n    }\r\n  }\r\n\r\n  const pipelineJob: vertex.PipelineJob = {\r\n    // name: \"<>\",\r\n    // Does not show up in the UX\r\n    displayName: componentSpec.name ?? \"Pipeline\",\r\n    // labels: {},\r\n    runtimeConfig: {\r\n      parameters: convertedPipelineArguments,\r\n      gcsOutputDirectory: gcsOutputDirectory,\r\n    },\r\n    pipelineSpec: pipelineSpec,\r\n    // encryptionSpec: {},\r\n    // serviceAccount: \"<>\",\r\n    // network: {},\r\n  };\r\n  return pipelineJob;\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { DragEvent } from 'react';\r\n\r\nimport ComponentLibrary from './ComponentLibrary'\r\nimport ComponentSearch from './ComponentSearch'\r\nimport GraphComponentExporter from './GraphComponentExporter'\r\nimport GoogleCloudSubmitter from './GoogleCloud'\r\nimport VertexAiExporter from './VertexAiExporter'\r\nimport { ComponentSpec } from '../componentSpec';\r\nimport { loadComponentFromUrl, DATA_PASSING_PIPELINE_URL, GOOGLE_CLOUD_OPTIMIZER_PIPELINE_URL } from './samplePipelines';\r\nimport UserComponentLibrary from \"./UserComponentLibrary\";\r\nimport PipelineLibrary from \"./PipelineLibrary\";\r\nimport { componentLibraryUrl } from '../appSettings';\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData('application/reactflow', JSON.stringify(nodeData));\r\n  event.dataTransfer.setData(\r\n    \"DragStart.offset\",\r\n    JSON.stringify({\r\n      offsetX: event.nativeEvent.offsetX,\r\n      offsetY: event.nativeEvent.offsetY,\r\n    })\r\n  );\r\n  event.dataTransfer.effectAllowed = 'move';\r\n};\r\n\r\ninterface SidebarProps {\r\n  componentSpec?: ComponentSpec,\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void,\r\n}\r\n\r\nconst Sidebar = ({\r\n  componentSpec,\r\n  setComponentSpec\r\n}: SidebarProps) => {\r\n  // Do not include the DebugScratch in the production build\r\n  let DebugScratchElement = () => null;\r\n  if (process?.env?.NODE_ENV === \"development\") {\r\n    const DebugScratch = require(\"./DebugScratch\").default;\r\n    DebugScratchElement = () =>\r\n      DebugScratch({\r\n        componentSpec: componentSpec,\r\n        setComponentSpec: setComponentSpec,\r\n      });\r\n  }\r\n\r\n  return (\r\n    <aside className=\"nodeList\">\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Save/Load pipeline</summary>\r\n        <PipelineLibrary componentSpec={componentSpec} setComponentSpec={setComponentSpec}/>\r\n      </details>\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Submit to Google Cloud</summary>\r\n        <GoogleCloudSubmitter componentSpec={componentSpec}/>\r\n      </details>\r\n      <h3>Drag components to the canvas:</h3>\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary><strong>Special</strong></summary>\r\n        <div className=\"react-flow__node react-flow__node-input sidebar-node\" onDragStart={(event: DragEvent) => onDragStart(event, { input: { label: \"Input\" } })} draggable>\r\n          Input\r\n        </div>\r\n        <div className=\"react-flow__node react-flow__node-output sidebar-node\" onDragStart={(event: DragEvent) => onDragStart(event, { output: { label: \"Output\" } })} draggable>\r\n          Output\r\n        </div>\r\n      </details>\r\n      <ComponentLibrary url={componentLibraryUrl} />\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>User components</summary>\r\n        <UserComponentLibrary/>\r\n      </details>\r\n      <details open style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Component search</summary>\r\n        <ComponentSearch />\r\n      </details>\r\n      <details>\r\n        <summary>Debug</summary>\r\n        {componentSpec && <GraphComponentExporter componentSpec={componentSpec}/>}\r\n        {componentSpec && <VertexAiExporter componentSpec={componentSpec}/>}\r\n        <button\r\n          type=\"button\"\r\n          onClick={(e) => {\r\n            loadComponentFromUrl(DATA_PASSING_PIPELINE_URL).then(setComponentSpec);\r\n          }}\r\n        >\r\n          Load Data Passing pipeline\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          onClick={(e) => {\r\n            loadComponentFromUrl(GOOGLE_CLOUD_OPTIMIZER_PIPELINE_URL).then(setComponentSpec);\r\n          }}\r\n        >\r\n          Load Google Cloud Optimizer pipeline\r\n        </button>\r\n        <DebugScratchElement/>\r\n      </details>\r\n    </aside>\r\n  );\r\n};\r\n\r\nexport default Sidebar;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport yaml from \"js-yaml\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\nimport { downloadComponentDataWithCache } from \"../github\";\r\nimport { httpGetWithCache } from \"../cacheUtils\";\r\nimport { ComponentReference, ComponentSpec } from \"../componentSpec\";\r\nimport DraggableComponent from \"./DraggableComponent\";\r\n\r\ntype ComponentLibraryFolder = {\r\n  name: string;\r\n  folders: ComponentLibraryFolder[];\r\n  components: ComponentReference[];\r\n};\r\n\r\ntype ComponentLibraryStruct = {\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n  folders: ComponentLibraryFolder[];\r\n};\r\n\r\nexport const isValidComponentLibraryStruct = (\r\n  obj: object\r\n): obj is ComponentLibraryStruct => \"folders\" in obj;\r\n\r\nconst DraggableComponentRow = ({ componentUrl }: { componentUrl: string }) => {\r\n  const [componentSpec, setComponentSpec] = useState<ComponentSpec | undefined>(\r\n    undefined\r\n  );\r\n  useEffect(() => {\r\n    // TODO: Validate the component\r\n    downloadComponentDataWithCache(componentUrl).then(setComponentSpec);\r\n  }, [componentUrl]);\r\n\r\n  if (componentSpec === undefined) {\r\n    return <div>Loading...</div>;\r\n  } else {\r\n    return (\r\n      <DraggableComponent\r\n        componentReference={{\r\n          url: componentUrl,\r\n          spec: componentSpec,\r\n        }}\r\n      />\r\n    );\r\n  }\r\n};\r\n\r\nconst SingleFolderVis = ({\r\n  folder,\r\n  isOpen = false,\r\n}: {\r\n  folder: ComponentLibraryFolder;\r\n  isOpen?: boolean;\r\n}) => {\r\n  return (\r\n    <details\r\n      key={folder.name}\r\n      open={isOpen}\r\n      style={{\r\n        border: \"1px solid #aaa\",\r\n        borderRadius: \"4px\",\r\n        padding: \"4px\",\r\n        paddingLeft: \"10px\",\r\n      }}\r\n    >\r\n      <summary style={{ borderWidth: \"1px\", padding: \"4px\" }}>\r\n        <strong>{folder.name}</strong>\r\n      </summary>\r\n      {folder.folders &&\r\n        Array.from(folder.folders).map((componentFolder, index) => (\r\n          <SingleFolderVis\r\n            key={componentFolder.name}\r\n            folder={componentFolder}\r\n            isOpen={isOpen && index === 0}\r\n          />\r\n        ))}\r\n      {folder.components &&\r\n        Array.from(folder.components).map(\r\n          (componentReference) =>\r\n            componentReference.url && (\r\n              <DraggableComponentRow\r\n                key={componentReference.url}\r\n                componentUrl={componentReference.url}\r\n              />\r\n            )\r\n        )}\r\n    </details>\r\n  );\r\n};\r\n\r\nconst ComponentLibraryVisFromStruct = ({\r\n  componentLibraryStruct,\r\n}: {\r\n  componentLibraryStruct?: ComponentLibraryStruct;\r\n}) => {\r\n  return (\r\n    <details open>\r\n      <summary\r\n        style={{\r\n          border: \"1px solid #aaa\",\r\n          padding: \"4px\",\r\n          borderRadius: \"4px\",\r\n        }}\r\n      >\r\n        <strong>Component library</strong>\r\n      </summary>\r\n      <div style={{ paddingLeft: \"10px\" }}>\r\n        {componentLibraryStruct &&\r\n          Array.from(componentLibraryStruct.folders).map(\r\n            (componentFolder, index) => (\r\n              <SingleFolderVis\r\n                key={componentFolder.name}\r\n                folder={componentFolder}\r\n                isOpen={index === 0}\r\n              />\r\n            )\r\n          )}\r\n      </div>\r\n    </details>\r\n  );\r\n};\r\n\r\nconst loadComponentLibraryStruct = async (url: string) => {\r\n  const response = await httpGetWithCache(url, \"cache\", true);\r\n  const data = await response.arrayBuffer();\r\n  const componentLibrary = yaml.load(new TextDecoder().decode(data));\r\n  if (typeof componentLibrary !== \"object\" || componentLibrary === null) {\r\n    throw Error(\r\n      `Component library data is not a YAML-encoded object: ${componentLibrary}`\r\n    );\r\n  }\r\n  if (!isValidComponentLibraryStruct(componentLibrary)) {\r\n    throw Error(\r\n      `Invalid Component library data structure: ${componentLibrary}`\r\n    );\r\n  }\r\n  return componentLibrary;\r\n};\r\n\r\nconst ComponentLibraryVisFromUrl = ({ url }: { url: string }) => {\r\n  const [componentLibraryStruct, setComponentLibraryStruct] =\r\n    useState<ComponentLibraryStruct>();\r\n\r\n  useEffect(() => {\r\n    if (componentLibraryStruct === undefined) {\r\n      (async () => {\r\n        const loadedComponentLibrary = await loadComponentLibraryStruct(url);\r\n        setComponentLibraryStruct(loadedComponentLibrary);\r\n      })();\r\n    }\r\n  }, [componentLibraryStruct, url]);\r\n\r\n  return componentLibraryStruct === undefined ? null : (\r\n    <ComponentLibraryVisFromStruct\r\n      componentLibraryStruct={componentLibraryStruct}\r\n    />\r\n  );\r\n};\r\n\r\nexport default ComponentLibraryVisFromUrl;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useState } from \"react\";\r\nimport { ComponentReference } from \"../componentSpec\";\r\nimport {\r\n  isComponentDbEmpty,\r\n  refreshComponentDb,\r\n  searchComponentsByName,\r\n} from \"../github\";\r\nimport DraggableComponent from \"./DraggableComponent\";\r\n\r\nimport { componentSearchConfig } from \"../appSettings\";\r\n\r\nconst SearchPanel = (props: any) => {\r\n  const [error, setError] = useState<string | undefined>(undefined);\r\n  const [firstTime, setFirstTime] = useState(true);\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const [query, setQuery] = useState(\"\");\r\n  const [items, setItems] = useState<ComponentReference[]>([]);\r\n\r\n  const onQueryChange = (e: any) => {\r\n    setQuery(e.target.value);\r\n  };\r\n\r\n  async function fetchData(query: string) {\r\n    // If the DB is populated, return results immediately, then refresh the DB and update the results.\r\n    try {\r\n      if (!(await isComponentDbEmpty())) {\r\n        const componentRefs = await searchComponentsByName(query);\r\n        setIsLoaded(true);\r\n        setItems(componentRefs);\r\n      } else {\r\n        console.debug(\"Component DB is empty. Need to populate the DB first.\");\r\n      }\r\n      await refreshComponentDb(componentSearchConfig);\r\n      setIsLoaded(true);\r\n      const componentRefs = await searchComponentsByName(query);\r\n      setItems(componentRefs);\r\n    } catch (error: any) {\r\n      setError(error.message);\r\n    }\r\n  }\r\n\r\n  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {\r\n    e.preventDefault();\r\n    if (query !== \"\") {\r\n      setFirstTime(false);\r\n      fetchData(query);\r\n    }\r\n    (window as any).gtag?.(\"event\", \"ComponentSearch_search\", {});\r\n  };\r\n\r\n  let results = <span></span>;\r\n  if (firstTime) {\r\n    results = <div>Enter search query</div>;\r\n  } else if (error !== undefined) {\r\n    results = <div>Error: {error}</div>;\r\n  } else if (!firstTime && !isLoaded) {\r\n    results = <div>Searching...</div>;\r\n  } else if (items !== undefined) {\r\n    const componentElements = items.map((componentRef) => (\r\n      <DraggableComponent\r\n        key={componentRef.digest ?? componentRef.url}\r\n        componentReference={componentRef}\r\n      />\r\n    ));\r\n    results = <>{componentElements}</>;\r\n  }\r\n  return (\r\n    <div className=\"nodeList\">\r\n      <form onSubmit={onSubmit}>\r\n        <input type=\"search\" placeholder=\"XGBoost\" onChange={onQueryChange} />\r\n        <input type=\"submit\" />\r\n      </form>\r\n      <div>{results}</div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SearchPanel;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { augmentComponentSpec } from './GraphComponentSpecFlow'\r\nimport { componentSpecToYaml } from \"../componentStore\";\r\n\r\ninterface GraphComponentExporterProps {\r\n  componentSpec: ComponentSpec,\r\n}\r\n\r\nconst GraphComponentExporter = ({\r\n  componentSpec,\r\n}: GraphComponentExporterProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  let componentText = \"\";\r\n  try {\r\n    const graphComponent = augmentComponentSpec(componentSpec, nodes, false, true);\r\n    componentText = componentSpecToYaml(graphComponent);\r\n  } catch(err) {\r\n    componentText = String(err);\r\n  }\r\n\r\n  const componentTextBlob = new Blob([componentText], { type: \"text/yaml\" }); // Or application/x-yaml (which leads to downloading)\r\n  const downloadLink = <a href={URL.createObjectURL(componentTextBlob)} download={\"component.yaml\"}>component.yaml</a>\r\n\r\n  return (\r\n    <details>\r\n      <summary>Graph {downloadLink}</summary>\r\n      <pre style={{overflow: \"auto\"}}>{componentText}</pre>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default GraphComponentExporter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\n/* global gapi */\r\n\r\nimport { useState } from 'react';\r\n\r\nimport { ArgumentType, ComponentSpec } from '../componentSpec';\r\nimport {generateVertexPipelineJobFromGraphComponent} from './vertexAiCompiler'\r\nimport ArgumentsEditor from \"./ArgumentsEditor\";\r\nimport { PipelineJob } from './vertexPipelineSpec';\r\n\r\nconst LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY = \"GoogleCloudSubmitter/gcsOutputDirectory\";\r\nconst LOCAL_STORAGE_PROJECT_ID_KEY = \"GoogleCloudSubmitter/projectId\";\r\nconst LOCAL_STORAGE_REGION_KEY = \"GoogleCloudSubmitter/region\";\r\nconst LOCAL_STORAGE_PROJECT_IDS_KEY = \"GoogleCloudSubmitter/projectIds\";\r\n\r\nvar CLIENT_ID = '640001104961-2m8hs192tmd9f9nssbr5thr5o3uhmita.apps.googleusercontent.com';\r\n     \r\nconst VERTEX_AI_PIPELINES_REGIONS = [\r\n  'us-central1',\r\n  'us-east1',\r\n  'us-west1',\r\n  'europe-west1',\r\n  'europe-west2',\r\n  'europe-west4',\r\n  'asia-east1',\r\n  'asia-southeast1',\r\n  'northamerica-northeast1',\r\n];\r\n\r\nconst VERTEX_AI_PIPELINES_DEFAULT_REGION = 'us-central1';\r\n\r\nconst authorizeGoogleCloudClient = async (\r\n  scopes: string[],\r\n  immediate = false, // Setting immediate to true prevents auth window showing every time. But it needs to be false the first time (when cookies are not set).\r\n  clientId: string = CLIENT_ID,\r\n) => {\r\n  return new Promise<GoogleApiOAuth2TokenObject>(\r\n    (resolve, reject) => {\r\n      gapi.auth.authorize(\r\n        {\r\n          client_id: clientId,\r\n          scope: scopes,\r\n          immediate: immediate,\r\n        },\r\n        (authResult) => {\r\n          // console.debug(\"authorizeGoogleCloudClient: called back\");\r\n          if (authResult === undefined) {\r\n            console.error(\"authorizeGoogleCloudClient failed\");\r\n            reject(\"gapi.auth.authorize result is undefined\");\r\n          } else if (authResult.error) {\r\n            console.error(\r\n              \"authorizeGoogleCloudClient failed\",\r\n              authResult.error\r\n            );\r\n            reject(authResult.error);\r\n          } else {\r\n            // console.debug(\"authorizeGoogleCloudClient: Success\");\r\n            // Working around the Google Auth bug: The request succeeds, but the returned token does not have the requested scopes.\r\n            // See https://github.com/google/google-api-javascript-client/issues/743\r\n            const receivedScopesString = (authResult as any).scope as string | undefined;\r\n            const receivedScopes = receivedScopesString?.split(\" \");\r\n            if (receivedScopes === undefined || !scopes.every((scope) => receivedScopes.includes(scope))) {\r\n              const errorMessage = `Authorization call succeeded, but the returned scopes are ${receivedScopesString}`;\r\n              console.error(errorMessage);\r\n              reject(errorMessage);\r\n            } else {\r\n              resolve(authResult);\r\n            }\r\n          }\r\n        }\r\n      );\r\n    }\r\n  );\r\n};\r\n\r\nconst ensureGoogleCloudAuthorizesScopes = async (scopes: string[]) => {\r\n  try {\r\n    // console.debug('Before ensureGoogleCloudAuthorizesScopes(immediate=true)');\r\n    await authorizeGoogleCloudClient(scopes, true);\r\n    // console.debug('After ensureGoogleCloudAuthorizesScopes(immediate=true)');\r\n    (window as any).gtag?.(\"event\", \"GoogleCloud_auth\", {\r\n      result: \"succeeded\",\r\n      immediate: \"true\"\r\n    });\r\n  } catch (err) {\r\n    // console.error('ensureGoogleCloudAuthorizesScopes(immediate=true)', err);\r\n    try {\r\n      await authorizeGoogleCloudClient(scopes, false);\r\n      (window as any).gtag?.(\"event\", \"GoogleCloud_auth\", {\r\n        result: \"succeeded\",\r\n        immediate: \"false\"\r\n      });\r\n    } catch (err) {\r\n      // console.error('ensureGoogleCloudAuthorizesScopes(immediate=false)', err);\r\n      (window as any).gtag?.(\"event\", \"GoogleCloud_auth\", {\r\n        result: \"failed\",\r\n        immediate: \"false\"\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nconst cloudresourcemanagerListProjects = async (isAuthenticated = false) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: \"https://cloudresourcemanager.googleapis.com/v1/projects/\",\r\n  });\r\n  return response.result;\r\n}\r\n\r\nconst aiplatformCreatePipelineJob = async (projectId: string, region='us-central1', pipelineJob: Record<string, any>) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: `https://${region}-aiplatform.googleapis.com/v1beta1/projects/${projectId}/locations/${region}/pipelineJobs`,\r\n    method: \"POST\",\r\n    body: JSON.stringify(pipelineJob),\r\n  });\r\n  (window as any).gtag?.(\"event\", \"GoogleCloud_submit_pipeline_job\", {\r\n    result: \"succeeded\"\r\n  });\r\n  return response.result;\r\n}\r\n\r\ninterface GoogleCloudSubmitterProps {\r\n  componentSpec?: ComponentSpec,\r\n};\r\n\r\nconst GoogleCloudSubmitter = ({\r\n  componentSpec,\r\n}: GoogleCloudSubmitterProps) => {\r\n  const [projects, setProjects] = useState<string[]>(\r\n    () => JSON.parse(window.localStorage?.getItem(LOCAL_STORAGE_PROJECT_IDS_KEY) ?? \"[]\")\r\n  );\r\n  const [project, setProject] = useState<string>(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_PROJECT_ID_KEY) ?? \"\"\r\n  ); // undefined causes error: https://reactjs.org/docs/forms.html#controlled-components https://stackoverflow.com/a/47012342\r\n  const [region, setRegion] = useState(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_REGION_KEY) ?? VERTEX_AI_PIPELINES_DEFAULT_REGION\r\n  );\r\n  const [error, setError] = useState(\"\");\r\n  const [gcsOutputDirectory, setGcsOutputDirectory] = useState(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY) ?? \"\"\r\n  );\r\n  const [pipelineJobWebUrl, setPipelineJobWebUrl] = useState(\"\");\r\n  const [compilationError, setCompilationError] = useState(\"\");\r\n  const [componentArguments, setComponentArguments] = useState<Record<string, ArgumentType>>({});\r\n\r\n  let vertexPipelineJobJson: string | undefined = undefined;\r\n  let vertexPipelineJob: PipelineJob | undefined = undefined;\r\n\r\n  //useEffect(() => {\r\n  if (componentSpec !== undefined) {\r\n    const defaultInputValues = Object.fromEntries(\r\n      (componentSpec.inputs ?? [])\r\n        .filter((inputSpec) => inputSpec.default !== undefined)\r\n        .map((inputSpec) => [inputSpec.name, String(inputSpec.default)])\r\n    );\r\n    const pipelineArguments = {\r\n      ...defaultInputValues,\r\n      ...componentArguments,\r\n    };\r\n    const pipelineArgumentMap = new Map(\r\n      Object.entries(pipelineArguments).filter(\r\n        // Type guard predicate\r\n        (pair): pair is [string, string] => typeof pair[1] === \"string\"\r\n      )\r\n    );\r\n    try {\r\n      vertexPipelineJob = generateVertexPipelineJobFromGraphComponent(\r\n        componentSpec,\r\n        gcsOutputDirectory,\r\n        pipelineArgumentMap\r\n      );\r\n      vertexPipelineJob.labels = {\r\n        \"sdk\": \"cloud-pipelines-editor\",\r\n        \"cloud-pipelines-editor-version\": \"0-0-1\",\r\n      };\r\n      vertexPipelineJobJson = JSON.stringify(vertexPipelineJob, undefined, 2);\r\n      // Prevent infinite re-renders\r\n      if (compilationError !== \"\") {\r\n        setCompilationError(\"\");\r\n      }\r\n    } catch (err) {\r\n      const errorMessage = err.toString();\r\n      // Prevent infinite re-renders\r\n      if (errorMessage !== compilationError) {\r\n        setCompilationError(err.toString());\r\n      }\r\n    }\r\n  }\r\n  //}, [componentSpec, gcsOutputDirectory]);\r\n\r\n  const vertexPipelineJobUrl = vertexPipelineJobJson && URL.createObjectURL(\r\n    new Blob([vertexPipelineJobJson], { type: \"application/json\" })\r\n  );\r\n\r\n  const readyToSubmit =\r\n    project !== \"\" && region !== \"\" && vertexPipelineJob !== undefined;\r\n\r\n  return (\r\n    <form\r\n      onSubmit={async (e) => {\r\n        e.preventDefault();\r\n        if (vertexPipelineJob === undefined) {\r\n          return;\r\n        }\r\n        setPipelineJobWebUrl(\"\");\r\n        try {\r\n          // setItem might throw exception on iOS in incognito mode\r\n          try {\r\n            window.localStorage?.setItem(LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY, gcsOutputDirectory);\r\n            window.localStorage?.setItem(LOCAL_STORAGE_PROJECT_ID_KEY, project);\r\n            window.localStorage?.setItem(LOCAL_STORAGE_REGION_KEY, region);\r\n          } catch(err) {\r\n            console.error(\"GoogleCloudSubmitter: Error writing properties to the localStorage\", err);\r\n          }\r\n          const result = await aiplatformCreatePipelineJob(project, region, vertexPipelineJob);\r\n          const pipelineJobName: string = result.name;\r\n          const pipelineJobId = pipelineJobName.split('/').slice(-1)[0];\r\n          const pipelineJobWebUrl = `https://console.cloud.google.com/vertex-ai/locations/${region}/pipelines/runs/${pipelineJobId}?project=${project}`;\r\n          setPipelineJobWebUrl(pipelineJobWebUrl);\r\n          setError(\"\");\r\n        } catch (err) {\r\n          console.error(err);\r\n          setError(err?.result?.error?.message ?? \"Error\");\r\n          (window as any).gtag?.(\"event\", \"GoogleCloud_submit_pipeline_job\", {\r\n            result: \"failed\"\r\n          });\r\n        }\r\n      }}\r\n    >\r\n      {componentSpec === undefined ||\r\n      (componentSpec?.inputs?.length ?? 0) === 0 ? undefined : (\r\n        <fieldset\r\n          style={{\r\n            // Reduce the default padding\r\n            padding: \"2px\",\r\n          }}\r\n        >\r\n          <legend>Arguments</legend>\r\n          <ArgumentsEditor\r\n            componentSpec={componentSpec}\r\n            componentArguments={componentArguments}\r\n            setComponentArguments={setComponentArguments}\r\n            shrinkToWidth={true}\r\n          />\r\n        </fieldset>\r\n      )}\r\n      <div style={{\r\n        whiteSpace: \"nowrap\",\r\n        margin: \"5px\",\r\n      }}>\r\n        <label htmlFor=\"project\">Project: </label>\r\n        <input\r\n          id=\"project\"\r\n          required\r\n          type=\"text\"\r\n          list=\"projects\"\r\n          placeholder=\"<my-project-id>\"\r\n          value={project}\r\n          onChange={(e) => setProject(e.target.value)}\r\n        />\r\n        <datalist id=\"projects\">\r\n          {projects.map((projectId) => (\r\n            <option key={projectId} value={projectId} />\r\n          ))}\r\n        </datalist>\r\n        <button\r\n          type=\"button\" // The default button type is \"submit\", not \"button\". WTF!?\r\n          onClick={async (e) => {\r\n            try {\r\n              const result = await cloudresourcemanagerListProjects();\r\n              const projectIds = (result.projects as any[]).map<string>(\r\n                (projectInfo) => projectInfo.projectId\r\n              );\r\n              setProjects(projectIds);\r\n              setError(\"\");\r\n              try {\r\n                window.localStorage?.setItem(LOCAL_STORAGE_PROJECT_IDS_KEY, JSON.stringify(projectIds));\r\n              } catch(err) {\r\n                console.error(\"GoogleCloudSubmitter: Error writing properties to the localStorage\", err);\r\n              }\r\n              (window as any).gtag?.(\"event\", \"GoogleCloud_list_projects\", { result: \"succeeded\" });\r\n            } catch (err) {\r\n              setError(err?.result?.error?.message ?? \"Error\");\r\n              (window as any).gtag?.(\"event\", \"GoogleCloud_list_projects\", { result: \"failed\" });\r\n            }\r\n          }}\r\n        >\r\n          {/*        */}\r\n        </button>\r\n      </div>\r\n      <div style={{\r\n        whiteSpace: \"nowrap\",\r\n        margin: \"5px\",\r\n      }}>\r\n        <label htmlFor=\"region\">Region: </label>\r\n        <input\r\n          id=\"region\"\r\n          required\r\n          type=\"text\"\r\n          list=\"regions\"\r\n          value={region}\r\n          onChange={(e) => setRegion(e.target.value)}\r\n        />\r\n        <datalist id=\"regions\">\r\n          {VERTEX_AI_PIPELINES_REGIONS.map((region) => (\r\n            <option key={region} value={region} />\r\n          ))}\r\n        </datalist>\r\n      </div>\r\n      <div style={{\r\n        whiteSpace: \"nowrap\",\r\n        margin: \"5px\",\r\n      }}>\r\n        <label htmlFor=\"region\">GCS dir: </label>\r\n        <input\r\n          id=\"gcsOutputDirectory\"\r\n          required\r\n          type=\"text\"\r\n          value={gcsOutputDirectory}\r\n          onChange={(e) => setGcsOutputDirectory(e.target.value)}\r\n        />\r\n      </div>\r\n      <div style={{\r\n        whiteSpace: \"nowrap\",\r\n        margin: \"5px\",\r\n      }}>\r\n        <input\r\n          type=\"submit\"\r\n          disabled={!readyToSubmit}\r\n          value=\"Submit pipeline job\"\r\n        />\r\n        {pipelineJobWebUrl !== \"\" && <a href={pipelineJobWebUrl} target=\"_blank\" rel=\"noreferrer\" style={{ margin: \"5px\" }}>Job</a>}\r\n      </div>\r\n      {vertexPipelineJobUrl !== undefined && (\r\n        <div\r\n          style={{\r\n            margin: \"5px\",\r\n          }}\r\n        >\r\n          Or download the{\" \"}\r\n          <a href={vertexPipelineJobUrl} download={\"vertex_pipeline_job.json\"}>\r\n            pipeline_job.json\r\n          </a>{\" \"}\r\n          file, then go to{\" \"}\r\n          <a href=\"https://console.cloud.google.com/vertex-ai/pipelines\">\r\n            Vertex Pipelines\r\n          </a>{\" \"}\r\n          and{\" \"}\r\n          <a href=\"https://cloud.google.com/vertex-ai/docs/pipelines/run-pipeline#console\">\r\n            create a new run\r\n          </a>\r\n          .\r\n        </div>\r\n      )}\r\n      {compilationError !== \"\" && <div>{compilationError}</div>}\r\n      {error !== \"\" && <div>Error: {error}</div>}\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default GoogleCloudSubmitter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\nimport {graphComponentSpecToVertexPipelineSpec} from './vertexAiCompiler'\r\n\r\ninterface VertexAiExporterProps {\r\n  componentSpec: ComponentSpec;\r\n}\r\n\r\nconst VertexAiExporter = ({componentSpec}: VertexAiExporterProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  let vertexPipelineSpecText = \"\";\r\n  try {\r\n    // Augmenting the componentSpec might be useless right now, but it can stabilize the output (e.g. ordering).\r\n    // Also, in the future, the original spec might be included in the vertexPipelineSpec\r\n    componentSpec = augmentComponentSpec(componentSpec, nodes, true, true);\r\n    const vertexPipelineSpec = graphComponentSpecToVertexPipelineSpec(componentSpec);\r\n    vertexPipelineSpecText = JSON.stringify(vertexPipelineSpec, undefined, 2);\r\n  } catch(err) {\r\n    vertexPipelineSpecText = String(err);\r\n  }\r\n\r\n  const vertexPipelineSpecTextBlob = new Blob([vertexPipelineSpecText], { type: \"application/json\" }); // Or application/x-yaml (which leads to downloading)\r\n  // TODO: Call vertexPipelineSpecTextBlobUrl.revokeObjectURL in the future\r\n  const vertexPipelineSpecTextBlobUrl = URL.createObjectURL(vertexPipelineSpecTextBlob);\r\n\r\n  return (\r\n    <details>\r\n      <summary>\r\n        Cloud IR <a\r\n          href={vertexPipelineSpecTextBlobUrl}\r\n          download={\"vertex_pipeline_spec.json\"}\r\n        >\r\n          vertex_pipeline_spec.json\r\n        </a>\r\n      </summary>\r\n      <pre style={{ overflow: \"auto\" }}>{vertexPipelineSpecText}</pre>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default VertexAiExporter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  Button,\r\n  Dialog,\r\n  DialogActions,\r\n  DialogContent,\r\n  DialogTitle,\r\n  Menu,\r\n  MenuItem,\r\n  TextField,\r\n} from \"@material-ui/core\";\r\nimport { useCallback, useState, useEffect, useRef } from \"react\";\r\nimport { useDropzone } from \"react-dropzone\";\r\nimport {\r\n  addComponentToListByText,\r\n  deleteComponentFileFromList,\r\n  ComponentFileEntry,\r\n  getAllComponentFilesFromList,\r\n  addComponentToListByUrl,\r\n} from \"../componentStore\";\r\nimport DraggableComponent from \"./DraggableComponent\";\r\n\r\nconst USER_COMPONENTS_LIST_NAME = \"user_components\";\r\n\r\nconst UserComponentLibrary = () => {\r\n  const [errorMessage, setErrorMessage] = useState(\"\");\r\n  const [componentFiles, setComponentFiles] = useState(\r\n    new Map<string, ComponentFileEntry>()\r\n  );\r\n  const [contextMenuFileName, setContextMenuFileName] = useState<string>();\r\n  const [contextMenuAnchor, setContextMenuAnchor] = useState<HTMLElement>();\r\n  const [isImportComponentDialogOpen, setIsImportComponentDialogOpen] =\r\n    useState(false);\r\n\r\n  const refreshComponents = useCallback(() => {\r\n    getAllComponentFilesFromList(USER_COMPONENTS_LIST_NAME).then(\r\n      setComponentFiles\r\n    );\r\n  }, [setComponentFiles]);\r\n\r\n  useEffect(refreshComponents, [refreshComponents]);\r\n\r\n  const onDrop = useCallback((acceptedFiles: File[]) => {\r\n    acceptedFiles.forEach((file) => {\r\n      const reader = new FileReader();\r\n      reader.onabort = () => console.log(\"file reading was aborted\");\r\n      reader.onerror = () => console.log(\"file reading has failed\");\r\n      reader.onload = async () => {\r\n        const binaryStr = reader.result;\r\n        if (binaryStr === null || binaryStr === undefined) {\r\n          console.error(`Dropped file reader result was ${binaryStr}`);\r\n          return;\r\n        }\r\n        try {\r\n          const componentRefPlusData = await addComponentToListByText(\r\n            USER_COMPONENTS_LIST_NAME,\r\n            binaryStr,\r\n          );\r\n          const componentRef = componentRefPlusData.componentRef;\r\n          console.debug(\"storeComponentText succeeded\", componentRef);\r\n          (window as any).gtag?.(\"event\", \"UserComponents_component_import\", {\r\n            result: \"succeeded\",\r\n          });\r\n          setErrorMessage(\"\");\r\n          refreshComponents();\r\n        } catch (err) {\r\n          setErrorMessage(\r\n            `Error parsing the dropped file as component: ${err.toString()}.`\r\n          );\r\n          console.error(\"Error parsing the dropped file as component\", err);\r\n          (window as any).gtag?.(\"event\", \"UserComponents_component_import\", {\r\n            result: \"failed\",\r\n          });\r\n        }\r\n      };\r\n      reader.readAsArrayBuffer(file);\r\n    });\r\n  }, [refreshComponents]);\r\n\r\n  const onImportFromUrl = useCallback(\r\n    async (url: string) => {\r\n      try {\r\n        const componentFileEntry = await addComponentToListByUrl(\r\n          USER_COMPONENTS_LIST_NAME,\r\n          url\r\n        );\r\n        const componentRef = componentFileEntry.componentRef;\r\n        console.debug(\"addComponentToListByUrl succeeded\", componentRef);\r\n        (window as any).gtag?.(\r\n          \"event\",\r\n          \"UserComponents_component_import_from_url_succeeded\"\r\n        );\r\n        setErrorMessage(\"\");\r\n        refreshComponents();\r\n        setIsImportComponentDialogOpen(false);\r\n      } catch (err) {\r\n        setErrorMessage(\r\n          `Error parsing the file as component: ${err.toString()}.`\r\n        );\r\n        console.error(\"Error importing component from the URL\", err);\r\n        (window as any).gtag?.(\r\n          \"event\",\r\n          \"UserComponents_component_import_from_url_failed\"\r\n        );\r\n      }\r\n    },\r\n    [refreshComponents]\r\n  );\r\n\r\n  const handleContextMenuDelete = async () => {\r\n    if (contextMenuFileName) {\r\n      setContextMenuFileName(undefined);\r\n      await deleteComponentFileFromList(\r\n        USER_COMPONENTS_LIST_NAME,\r\n        contextMenuFileName\r\n      );\r\n      refreshComponents();\r\n    }\r\n  };\r\n\r\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\r\n    onDrop,\r\n    accept: \".yaml\",\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={(e) => setIsImportComponentDialogOpen(true)}\r\n        style={{ marginBottom: \"4px\" }}\r\n      >\r\n        Import from URL\r\n      </button>\r\n      <div {...getRootProps()}>\r\n        <input {...getInputProps()} />\r\n        <div\r\n          style={{\r\n            border: \"1px solid black\",\r\n            padding: \"4px\",\r\n            minHeight: \"3em\",\r\n          }}\r\n        >\r\n          {isDragActive\r\n            ? \"Drop the files here ...\"\r\n            : errorMessage ||\r\n              \"Drag and drop component.yaml files or click to select files\"}\r\n          {Array.from(componentFiles.entries()).map(([fileName, fileEntry]) => (\r\n            <DraggableComponent\r\n              key={fileName}\r\n              componentReference={fileEntry.componentRef}\r\n              onContextMenu={(e) => {\r\n                e.preventDefault();\r\n                setContextMenuAnchor(e.currentTarget);\r\n                setContextMenuFileName(fileName);\r\n              }}\r\n            />\r\n          ))}\r\n        </div>\r\n      </div>\r\n      <Menu\r\n        open={contextMenuFileName !== undefined}\r\n        anchorEl={contextMenuAnchor}\r\n        onClose={() => {\r\n          setContextMenuFileName(undefined);\r\n        }}\r\n      >\r\n        <MenuItem dense={true} onClick={handleContextMenuDelete}>\r\n          Delete\r\n        </MenuItem>\r\n      </Menu>\r\n      <ImportComponentFromUrlDialog\r\n        isOpen={isImportComponentDialogOpen}\r\n        onCancel={() => setIsImportComponentDialogOpen(false)}\r\n        initialValue={\"https://raw.githubusercontent.com/.../component.yaml\"}\r\n        onImport={onImportFromUrl}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default UserComponentLibrary;\r\n\r\ninterface SaveAsDialogProps {\r\n  isOpen: boolean;\r\n  onImport: (name: string) => void;\r\n  onCancel: () => void;\r\n  initialValue: string | undefined;\r\n}\r\n\r\nconst ImportComponentFromUrlDialog = ({\r\n  isOpen,\r\n  onImport,\r\n  onCancel,\r\n  initialValue,\r\n}: SaveAsDialogProps) => {\r\n  const urlInputRef = useRef<HTMLInputElement>();\r\n  return (\r\n    <Dialog open={isOpen} fullWidth>\r\n      <DialogTitle>{\"Import component\"}</DialogTitle>\r\n      <form\r\n        onSubmit={(e) => {\r\n          if (urlInputRef.current) {\r\n            onImport(urlInputRef.current.value);\r\n          }\r\n          e.preventDefault();\r\n        }}\r\n      >\r\n        <DialogContent>\r\n          <TextField\r\n            id=\"name\"\r\n            type=\"text\"\r\n            placeholder={initialValue}\r\n            label=\"Component URL\"\r\n            inputRef={urlInputRef}\r\n            required\r\n            autoFocus\r\n            fullWidth\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={onCancel}>Cancel</Button>\r\n          <Button color=\"primary\" type=\"submit\" autoFocus>\r\n            Import\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useStoreState } from \"react-flow-renderer\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { componentSpecToYaml } from \"../componentStore\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\n\r\ninterface GraphComponentLinkProps {\r\n  componentSpec: ComponentSpec;\r\n  downloadFileName?: string;\r\n  linkText?: string;\r\n  linkRef?: React.Ref<HTMLAnchorElement>;\r\n  style?: React.CSSProperties;\r\n}\r\n\r\nconst GraphComponentLink = ({\r\n  componentSpec,\r\n  downloadFileName = \"component.yaml\",\r\n  linkText = \"component.yaml\",\r\n  linkRef,\r\n  style,\r\n}: GraphComponentLinkProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  try {\r\n    componentSpec = augmentComponentSpec(componentSpec, nodes, false, true);\r\n  } catch (err) {\r\n    if (err?.message?.startsWith(\"The nodes array does not\") !== true) {\r\n      console.error(err);\r\n      return <>err.toString()</>;\r\n    }\r\n  }\r\n  const componentText = componentSpecToYaml(componentSpec);\r\n  const componentTextBlob = new Blob([componentText], { type: \"text/yaml\" }); // Or application/x-yaml (which leads to downloading)\r\n  return (\r\n    <a\r\n      ref={linkRef}\r\n      href={URL.createObjectURL(componentTextBlob)}\r\n      download={downloadFileName}\r\n      style={style}\r\n    >\r\n      {linkText}\r\n    </a>\r\n  );\r\n};\r\n\r\nexport default GraphComponentLink;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useState, useEffect } from \"react\";\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport {\r\n  storeComponentFromUrl,\r\n  ComponentReferenceWithSpec,\r\n} from \"../componentStore\";\r\nimport {\r\n  preloadComponentReferences,\r\n  PRELOADED_PIPELINE_URLS,\r\n} from \"./samplePipelines\";\r\n\r\ninterface PipelineLibraryProps {\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void;\r\n}\r\n\r\nconst SamplePipelineLibrary = ({ setComponentSpec }: PipelineLibraryProps) => {\r\n  const [componentRefs, setComponentRefs] = useState<\r\n    ComponentReferenceWithSpec[]\r\n  >([]);\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      if (componentRefs.length === 0) {\r\n        const loadedComponentRefs = await Promise.all(\r\n          PRELOADED_PIPELINE_URLS.map(async (url) => {\r\n            const componentRefPlusData = await storeComponentFromUrl(url);\r\n            const componentRef = componentRefPlusData.componentRef;\r\n            await preloadComponentReferences(componentRef.spec);\r\n            return componentRef;\r\n          })\r\n        );\r\n        setComponentRefs(loadedComponentRefs);\r\n      }\r\n    })();\r\n  }, [componentRefs.length]);\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        //border: \"1px solid black\",\r\n        overflow: \"auto\",\r\n        whiteSpace: \"nowrap\",\r\n      }}\r\n    >\r\n      <div style={{ overflow: \"auto\", marginLeft: \"10px\" }}>\r\n        {componentRefs.map((componentRef) => (\r\n          <div key={componentRef.digest}>\r\n             {/*    */}\r\n            <button\r\n              className=\"link-button\"\r\n              onClick={(e) => {\r\n                setComponentSpec?.(componentRef.spec);\r\n              }}\r\n            >\r\n              {componentRef.spec.name ?? \"<Pipeline>\"}\r\n            </button>\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SamplePipelineLibrary;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  Button,\r\n  Dialog,\r\n  DialogActions,\r\n  DialogContent,\r\n  DialogTitle,\r\n  Menu,\r\n  MenuItem,\r\n  TextField,\r\n} from \"@material-ui/core\";\r\nimport { useCallback, useState, useEffect, useRef } from \"react\";\r\nimport { useStoreState } from \"react-flow-renderer\";\r\nimport { ComponentSpec, isGraphImplementation } from \"../componentSpec\";\r\nimport {\r\n  loadComponentAsRefFromText,\r\n  getAllComponentFilesFromList,\r\n  ComponentFileEntry,\r\n  addComponentToListByText,\r\n  componentSpecToYaml,\r\n  writeComponentToFileListFromText,\r\n  getComponentFileFromList,\r\n  deleteComponentFileFromList,\r\n} from \"../componentStore\";\r\nimport GraphComponentLink from \"./GraphComponentLink\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\nimport SamplePipelineLibrary from \"./SamplePipelineLibrary\";\r\nimport { preloadComponentReferences } from \"./samplePipelines\";\r\n\r\nconst USER_PIPELINES_LIST_NAME = \"user_pipelines\";\r\n\r\ninterface PipelineLibraryProps {\r\n  componentSpec?: ComponentSpec;\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void;\r\n}\r\n\r\nconst removeSuffixes = (s: string, suffixes: string[]) => {\r\n  for (const suffix of suffixes) {\r\n    if (s.endsWith(suffix)) {\r\n      s = s.substring(0, s.length - suffix.length);\r\n    }\r\n  }\r\n  return s;\r\n};\r\n\r\ninterface SavePipelineAsDialogProps {\r\n  isOpen: boolean;\r\n  onPipelineSave: (name: string, overwrite: boolean) => Promise<void>;\r\n  onCancel: () => void;\r\n  initialName?: string;\r\n}\r\n\r\nconst SavePipelineAsDialog = ({\r\n  isOpen,\r\n  onPipelineSave,\r\n  onCancel,\r\n  initialName,\r\n}: SavePipelineAsDialogProps) => {\r\n  const [fileName, setFileName] = useState<string | undefined>(initialName);\r\n  const [isOverwriteDialogOpen, setIsOverwriteDialogOpen] = useState(false);\r\n\r\n  const handleSave = async (name: string) => {\r\n    setFileName(name);\r\n    try {\r\n      await onPipelineSave(name, false);\r\n    } catch {\r\n      setIsOverwriteDialogOpen(true);\r\n    }\r\n  };\r\n\r\n  const handleOverwriteOk = () => {\r\n    if (fileName) {\r\n      setIsOverwriteDialogOpen(false);\r\n      onPipelineSave(fileName, true);\r\n    }\r\n  };\r\n\r\n  const handleOverwriteCancel = () => {\r\n    setIsOverwriteDialogOpen(false);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <SaveAsDialog\r\n        isOpen={isOpen}\r\n        onSave={handleSave}\r\n        onCancel={onCancel}\r\n        initialValue={fileName}\r\n        inputLabel=\"Pipeline name\"\r\n      />\r\n      <OkCancelDialog\r\n        isOpen={isOpen && isOverwriteDialogOpen}\r\n        title=\"Overwrite?\"\r\n        okButtonText=\"Overwrite\"\r\n        onOk={handleOverwriteOk}\r\n        onCancel={handleOverwriteCancel}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\ninterface OkCancelDialogProps {\r\n  isOpen: boolean;\r\n  title: string;\r\n  okButtonText?: string;\r\n  cancelButtonText?: string;\r\n  onOk: () => void;\r\n  onCancel: () => void;\r\n}\r\n\r\nconst OkCancelDialog = ({\r\n  isOpen,\r\n  title,\r\n  okButtonText = \"OK\",\r\n  cancelButtonText = \"Cancel\",\r\n  onOk,\r\n  onCancel,\r\n}: OkCancelDialogProps) => {\r\n  return (\r\n    <Dialog open={isOpen} aria-labelledby=\"alert-dialog-title\">\r\n      <DialogTitle id=\"alert-dialog-title\">{title}</DialogTitle>\r\n      <DialogActions>\r\n        <Button color=\"primary\" onClick={onCancel}>\r\n          {cancelButtonText}\r\n        </Button>\r\n        <Button color=\"secondary\" onClick={onOk}>\r\n          {okButtonText}\r\n        </Button>\r\n      </DialogActions>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\ninterface SaveAsDialogProps {\r\n  isOpen: boolean;\r\n  onSave: (name: string) => void;\r\n  onCancel: () => void;\r\n  initialValue: string | undefined;\r\n  inputLabel: string;\r\n}\r\n\r\nconst SaveAsDialog = ({\r\n  isOpen,\r\n  onSave,\r\n  onCancel,\r\n  initialValue,\r\n  inputLabel = \"Pipeline name\",\r\n}: SaveAsDialogProps) => {\r\n  const nameInputRef = useRef<HTMLInputElement>();\r\n  return (\r\n    <Dialog open={isOpen} aria-labelledby=\"alert-dialog-title\">\r\n      <DialogTitle id=\"alert-dialog-title\">{\"Save pipeline\"}</DialogTitle>\r\n      <form\r\n        onSubmit={(e) => {\r\n          if (nameInputRef.current) {\r\n            onSave(nameInputRef.current.value);\r\n          }\r\n          e.preventDefault();\r\n        }}\r\n      >\r\n        <DialogContent>\r\n          <TextField\r\n            id=\"name\"\r\n            type=\"text\"\r\n            defaultValue={initialValue}\r\n            label={inputLabel}\r\n            inputRef={nameInputRef}\r\n            required\r\n            autoFocus\r\n            fullWidth\r\n            margin=\"dense\"\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={onCancel}>Cancel</Button>\r\n          <Button color=\"primary\" type=\"submit\" autoFocus>\r\n            Save\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nconst PipelineLibrary = ({\r\n  componentSpec,\r\n  setComponentSpec,\r\n}: PipelineLibraryProps) => {\r\n  // const [errorMessage, setErrorMessage] = useState(\"\");\r\n  const [componentFiles, setComponentFiles] = useState(\r\n    new Map<string, ComponentFileEntry>()\r\n  );\r\n  const [pipelineFile, setPipelineFile] = useState<ComponentFileEntry>();\r\n  const [saveAsDialogIsOpen, setSaveAsDialogIsOpen] = useState(false);\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  const [contextMenuFileName, setContextMenuFileName] = useState<string>();\r\n  const [contextMenuAnchor, setContextMenuAnchor] = useState<HTMLElement>();\r\n\r\n  const refreshPipelines = useCallback(() => {\r\n    getAllComponentFilesFromList(USER_PIPELINES_LIST_NAME).then(\r\n      setComponentFiles\r\n    );\r\n  }, [setComponentFiles]);\r\n\r\n  useEffect(refreshPipelines, [refreshPipelines]);\r\n\r\n  const openPipelineFile = useCallback(\r\n    async (fileEntry: ComponentFileEntry) => {\r\n      // Loading all child components\r\n      // TODO: Move this functionality to the setComponentSpec function\r\n      await preloadComponentReferences(fileEntry.componentRef.spec);\r\n      setComponentSpec?.(fileEntry.componentRef.spec);\r\n      setPipelineFile(fileEntry);\r\n    },\r\n    [setComponentSpec, setPipelineFile]\r\n  );\r\n\r\n  const onDrop = useCallback(\r\n    (acceptedFiles: File[]) => {\r\n      acceptedFiles.forEach((file) => {\r\n        const reader = new FileReader();\r\n        reader.onabort = () => console.log(\"file reading was aborted\");\r\n        reader.onerror = () => console.log(\"file reading has failed\");\r\n        reader.onload = async () => {\r\n          const binaryStr = reader.result;\r\n          if (binaryStr === null || binaryStr === undefined) {\r\n            console.error(`Dropped file reader result was ${binaryStr}`);\r\n            return;\r\n          }\r\n          const fileName =\r\n            removeSuffixes(file.name, [\r\n              \".pipeline.component.yaml\",\r\n              \".component.yaml\",\r\n              \".pipeline.yaml\",\r\n              \".yaml\",\r\n            ]) || \"Pipeline\";\r\n          try {\r\n            const componentRefPlusData1 = await loadComponentAsRefFromText(\r\n              binaryStr\r\n            );\r\n            const componentRef1 = componentRefPlusData1.componentRef;\r\n            if (!isGraphImplementation(componentRef1.spec.implementation)) {\r\n              console.error(\"Dropped component is not a graph component\");\r\n              return;\r\n            }\r\n            // Caching the child components\r\n            await preloadComponentReferences(componentRef1.spec);\r\n            // TODO: Do not load the component twice\r\n            const componentRefPlusData = await addComponentToListByText(\r\n              USER_PIPELINES_LIST_NAME,\r\n              binaryStr,\r\n              fileName\r\n            );\r\n            const componentRef = componentRefPlusData.componentRef;\r\n            console.debug(\"storeComponentText succeeded\", componentRef);\r\n            (window as any).gtag?.(\"event\", \"PipelineLibrary_pipeline_import\", {\r\n              result: \"succeeded\",\r\n            });\r\n            // setErrorMessage(\"\");\r\n            refreshPipelines();\r\n          } catch (err) {\r\n            // setErrorMessage(\r\n            //   `Error parsing the dropped file as component: ${err.toString()}.`\r\n            // );\r\n            console.error(\"Error parsing the dropped file as component\", err);\r\n            (window as any).gtag?.(\"event\", \"PipelineLibrary_pipeline_import\", {\r\n              result: \"failed\",\r\n            });\r\n          }\r\n        };\r\n        reader.readAsArrayBuffer(file);\r\n      });\r\n    },\r\n    [refreshPipelines]\r\n  );\r\n\r\n  const openSaveAsDialog = useCallback(() => {\r\n    setSaveAsDialogIsOpen(true);\r\n  }, [setSaveAsDialogIsOpen]);\r\n\r\n  const closeSaveAsDialog = useCallback(() => {\r\n    setSaveAsDialogIsOpen(false);\r\n  }, [setSaveAsDialogIsOpen]);\r\n\r\n  const handlePipelineSave = useCallback(\r\n    async (name: string, overwrite: boolean = false) => {\r\n      if (!overwrite) {\r\n        const existingFileEntry = await getComponentFileFromList(\r\n          USER_PIPELINES_LIST_NAME,\r\n          name\r\n        );\r\n        if (existingFileEntry !== null) {\r\n          throw Error(`File \"${name}\" already exists.`);\r\n        }\r\n      }\r\n      if (!componentSpec) {\r\n        return;\r\n      }\r\n      const graphComponent = augmentComponentSpec(\r\n        componentSpec,\r\n        nodes,\r\n        false,\r\n        true\r\n      );\r\n      graphComponent.name = name;\r\n      const componentText = componentSpecToYaml(graphComponent);\r\n      const fileEntry = await writeComponentToFileListFromText(\r\n        USER_PIPELINES_LIST_NAME,\r\n        name,\r\n        componentText\r\n      );\r\n      await openPipelineFile(fileEntry);\r\n      closeSaveAsDialog();\r\n      refreshPipelines();\r\n    },\r\n    [\r\n      componentSpec,\r\n      closeSaveAsDialog,\r\n      nodes,\r\n      openPipelineFile,\r\n      refreshPipelines,\r\n    ]\r\n  );\r\n\r\n  const handleContextMenuDelete = async () => {\r\n    if (contextMenuFileName) {\r\n      setContextMenuFileName(undefined);\r\n      await deleteComponentFileFromList(\r\n        USER_PIPELINES_LIST_NAME,\r\n        contextMenuFileName\r\n      );\r\n      refreshPipelines();\r\n    }\r\n  };\r\n\r\n  const handleContextMenuOpen = async () => {\r\n    if (contextMenuFileName) {\r\n      setContextMenuFileName(undefined);\r\n      const fileEntry = await getComponentFileFromList(\r\n        USER_PIPELINES_LIST_NAME,\r\n        contextMenuFileName\r\n      );\r\n      if (!fileEntry) {\r\n        console.error(\r\n          `handleContextMenuOpen: File ${contextMenuFileName} does not exist.`\r\n        );\r\n        return;\r\n      }\r\n      await openPipelineFile(fileEntry);\r\n    }\r\n  };\r\n\r\n  const fileInput = useRef<HTMLInputElement>(null);\r\n  const componentLink = useRef<HTMLAnchorElement>(null);\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        //border: \"1px solid black\",\r\n        overflow: \"auto\",\r\n        whiteSpace: \"nowrap\",\r\n      }}\r\n    >\r\n      <div style={{ margin: \"5px\" }}>\r\n        <button\r\n          onClick={(e) => {\r\n            if (pipelineFile) {\r\n              handlePipelineSave(pipelineFile?.name, true);\r\n            } else {\r\n              openSaveAsDialog();\r\n            }\r\n          }}\r\n        >\r\n          Save\r\n        </button>\r\n        <button onClick={openSaveAsDialog}>Save as</button>\r\n        {componentSpec && (\r\n          <SavePipelineAsDialog\r\n            initialName={componentSpec.name}\r\n            isOpen={saveAsDialogIsOpen}\r\n            onCancel={closeSaveAsDialog}\r\n            onPipelineSave={handlePipelineSave}\r\n          />\r\n        )}\r\n        <input\r\n          ref={fileInput}\r\n          type=\"file\"\r\n          accept=\".yaml\"\r\n          onChange={(e) => onDrop(Array.from(e.target.files ?? []))}\r\n          style={{ display: \"none\" }}\r\n        />\r\n        <button onClick={(e) => fileInput.current?.click()}>+ Import</button>\r\n        <button\r\n          onClick={(e) => {\r\n            componentLink.current?.click();\r\n          }}\r\n        >\r\n          Export\r\n        </button>\r\n        {componentSpec && (\r\n          <GraphComponentLink\r\n            linkRef={componentLink}\r\n            componentSpec={componentSpec}\r\n            linkText=\"\"\r\n            downloadFileName={\r\n              (componentSpec.name ? componentSpec.name + \".\" : \"\") +\r\n              \"pipeline.component.yaml\"\r\n            }\r\n            style={{ textDecoration: \"none\" }}\r\n          />\r\n        )}\r\n      </div>\r\n      <div style={{ overflow: \"auto\", marginLeft: \"10px\" }}>\r\n        {Array.from(componentFiles.entries()).map(([fileName, fileEntry]) => (\r\n          <div key={fileName}>\r\n             {/*    */}\r\n            <button\r\n              className=\"link-button\"\r\n              onClick={(e) => openPipelineFile(fileEntry)}\r\n              style={\r\n                fileName === pipelineFile?.name\r\n                  ? { fontWeight: \"bold\" }\r\n                  : undefined\r\n              }\r\n              onContextMenu={(e) => {\r\n                e.preventDefault();\r\n                setContextMenuAnchor(e.currentTarget);\r\n                setContextMenuFileName(fileName);\r\n              }}\r\n            >\r\n              {fileName}\r\n            </button>\r\n          </div>\r\n        ))}\r\n        <Menu\r\n          open={contextMenuFileName !== undefined}\r\n          anchorEl={contextMenuAnchor}\r\n          onClose={() => {\r\n            setContextMenuFileName(undefined);\r\n          }}\r\n        >\r\n          <MenuItem dense={true} onClick={handleContextMenuOpen}>\r\n            Open\r\n          </MenuItem>\r\n          <MenuItem dense={true} onClick={handleContextMenuDelete}>\r\n            Delete\r\n          </MenuItem>\r\n        </Menu>\r\n      </div>\r\n      <details\r\n        open\r\n        style={{\r\n          border: \"1px solid #aaa\",\r\n          borderRadius: \"4px\",\r\n          padding: \"4px\",\r\n        }}\r\n      >\r\n        <summary>\r\n          <strong>Sample pipelines</strong>\r\n        </summary>\r\n        <SamplePipelineLibrary setComponentSpec={setComponentSpec} />\r\n      </details>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PipelineLibrary;\r\n"],"sourceRoot":""}