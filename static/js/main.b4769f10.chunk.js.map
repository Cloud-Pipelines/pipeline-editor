{"version":3,"sources":["DragNDrop/DebugScratch.tsx","componentStore.ts","DragNDrop/PipelineAutoSaver.ts","DragNDrop/index.tsx","AppFooter.tsx","App.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","index.tsx","cacheUtils.ts","componentSpec.ts","DragNDrop/ArgumentsEditorDialog.tsx","DragNDrop/ComponentTaskNode.tsx","DragNDrop/GraphComponentSpecFlow.tsx","utils.ts","DragNDrop/DraggableComponent.tsx","DragNDrop/ArgumentsEditor.tsx","appSettings.ts","compilers/GoogleCloudVertexAIPipelines/vertexPipelineSpec.ts","compilers/GoogleCloudVertexAIPipelines/vertexAiCompiler.ts","DragNDrop/Sidebar.tsx","DragNDrop/ComponentLibrary.tsx","DragNDrop/GraphComponentExporter.tsx","DragNDrop/VertexAiExporter.tsx","DragNDrop/UserComponentLibrary.tsx","DragNDrop/AppSettingsDialog.tsx","DragNDrop/GoogleCloud.tsx","compilers/Argo/argoCompiler.ts","DragNDrop/KubeflowPipelinesSubmitter.tsx","DragNDrop/PipelineSubmitter.tsx","DragNDrop/GraphComponentLink.tsx","DragNDrop/SamplePipelineLibrary.tsx","DragNDrop/PipelineLibrary.tsx","github.ts","DragNDrop/ComponentSearch.tsx"],"names":["DATA_PASSING_PIPELINE_URL","GOOGLE_CLOUD_OPTIMIZER_PIPELINE_URL","DebugScratch","componentSpec","setComponentSpec","downloadData","downloadDataWithCache","useState","message","setMessage","isDialogOpen","setIsDialogOpen","type","onClick","e","fullyLoadComponentRefFromUrl","then","ref","spec","a","fetch","headers","Headers","Authorization","response","text","responseText","open","aria-labelledby","aria-describedby","id","color","autoFocus","DB_NAME","DIGEST_TO_DATA_DB_TABLE_NAME","DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME","URL_TO_DIGEST_DB_TABLE_NAME","DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME","FILE_STORE_DB_TABLE_NAME_PREFIX","calculateHashDigestHex","data","dataBytes","TextEncoder","encode","crypto","subtle","digest","hashBuffer","hashArray","Array","from","Uint8Array","hashHex","map","b","toString","padStart","join","storeComponentSpec","digestToComponentSpecDb","localForage","createInstance","name","storeName","digestToComponentNameDb","setItem","undefined","loadComponentAsRefFromText","componentText","componentString","TextDecoder","decode","componentBytes","loadedObj","yaml","load","Error","isValidComponentSpec","componentRef","loadComponentFromUrlAsRef","url","preloadComponentReferences","componentMap","Map","implementation","Object","values","graph","tasks","taskSpec","componentUrl","taskComponentSpec","taskComponentRef","get","set","console","error","newComponentRef","fullyLoadComponentRef","recursive","loadedComponentRef","warn","componentSpecToYaml","componentDigest","storeComponentText","digestToComponentTextDb","storeComponentFromUrl","setUrlAsCanonical","urlToDigestDb","digestToDataDb","getItem","existingDigest","componentData","arrayBuffer","digestToCanonicalUrlDb","existingCanonicalUrl","debug","makeNameUniqueByAddingIndex","existingNames","finalName","index","has","writeComponentRefToFile","listName","fileName","upgradeSingleComponentListDb","tableName","componentListDb","existingFile","currentTime","Date","fileEntry","creationTime","modificationTime","addComponentRefToList","Set","keys","uniqueFileName","addComponentToListByUrl","defaultFileName","addComponentToListByText","writeComponentToFileListFromText","getAllComponentFilesFromList","componentFiles","iterate","iterationNumber","getComponentFileFromList","deleteComponentFileFromList","removeItem","dump","lineWidth","componentListVersionKey","componentStoreSettingsDb","componentListTableName","listFormatVersion","includes","log","componentRefListsDb","componentRefList","emptyNameReplacement","add","fileNames","newDigest","newFileEntry","SAVED_COMPONENT_SPEC_KEY","loadPipelineSpecFromSessionStorage","window","sessionStorage","loadedYaml","err","PipelineAutoSaver","nodes","useStoreState","store","length","augmentComponentSpec","startsWith","savePipelineSpecToSessionStorage","DnDFlow","getAppSettings","appSettings","useEffect","restoredComponentSpec","defaultPipelineUrl","defaultPipelineRef","EMPTY_GRAPH_COMPONENT_SPEC","className","GraphComponentSpecFlow","snapToGrid","snapGrid","gap","Sidebar","AppFooter","style","width","height","padding","textAlign","backgroundColor","display","Link","href","underline","target","rel","margin","App","isLocalhost","Boolean","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","URL","process","origin","addEventListener","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration","httpGetDataWithCache","transformer","cacheName","updateIfInCache","caches","cache","needToUpdateCache","newResponse","ok","statusText","responseForCaching","clone","result","put","IMMUTABLE_URL_REGEXPS","isImmutable","some","regexp","loadTextFromData","buffer","loadObjectFromJsonData","obj","JSON","parse","loadObjectFromYamlData","isContainerImplementation","isGraphImplementation","ArgumentsEditorDialog","closeEditor","setArguments","arguments","currentArguments","setCurrentArguments","onSubmit","preventDefault","position","background","border","borderRadius","ArgumentsEditor","componentArguments","setComponentArguments","inputHandlePosition","Position","Top","outputHandlePosition","Bottom","isComponentTaskNode","node","generateHandles","ioSpecs","handleType","idPrefix","inputsWithMissingArguments","handleComponents","numHandles","i","ioSpec","positionPercentString","String","left","top","ioTypeName","classNames","replace","push","generateLabelStyle","labelClasses","labelStyle","handleTitle","description","isConnectable","title","maxLabelWidthPx","maxWidth","ComponentTaskNode","isArgumentsEditorOpen","setIsArgumentsEditorOpen","label","taskId","inputsWithInvalidArguments","inputs","filter","inputSpec","optional","default","inputHandles","inputSpecs","generateInputHandles","outputHandles","outputs","concat","onDoubleClick","SDK_ANNOTATION_VALUE","taskIdToNodeId","inputNameToNodeId","outputNameToNodeId","nodeIdToTaskId","nodeIdToInputName","nodeIdToOutputName","includeSpecs","includePositions","getNodePositionAnnotation","stringify","x","__rf","y","nodeXPositionComparer","n1","n2","deltaX","deltaY","nodeYPositionComparer","inputNodes","sort","outputNodes","taskNodes","inputPositionMap","inputOrderMap","inputOrderComparer","Infinity","outputPositionMap","outputOrderMap","outputOrderComparer","taskPositionMap","taskOrderMap","taskOrderComparer","pairA","pairB","newAnnotations","annotations","NODE_LAYOUT_ANNOTATION_KEY","newInputSpec","outputSpec","newOutputSpec","graphSpec","newTasks","fromEntries","entries","newTaskSpec","rebuildComponentSpec","metadata","rest","nodeTypes","task","memo","isAppleOS","children","reactFlowInstance","setReactFlowInstance","layoutAnnotation","decodedPosition","args","setTaskArguments","edges","flatMap","inputName","argument","taskOutput","outputName","source","sourceHandle","targetHandle","arrowHeadType","ArrowHeadType","ArrowClosed","graphInput","outputEdges","outputValues","elements","replaceComponentSpec","newComponentSpec","replaceGraphSpec","newGraphSpec","taskArguments","setTaskArgument","oldTaskSpecArguments","newTaskSpecArguments","removeTaskArgument","setGraphOutputValue","outputValue","newGraphOutputValues","removeGraphOutputValue","addConnection","connection","targetTaskInputName","sourceTaskOutputName","taskOutputArgument","graphInputArgument","removeEdge","edge","removeNode","inputNameToRemove","newInputs","removeComponentInput","outputNameToRemove","newOutputs","removeComponentOutput","taskIdToRemove","removeTask","onConnect","params","onDragOver","event","dataTransfer","dropEffect","onDrop","droppedData","getData","droppedDataObject","nodeType","nodeData","dragOffsetX","dragOffsetY","dragStartOffsetData","dragStartOffset","offsetX","offsetY","project","clientX","clientY","nodePosition","positionAnnotations","mergedAnnotations","taskSpecWithAnnotation","getUniqueTaskName","getUniqueInputName","getUniqueOutputName","onEdgeUpdate","oldEdge","newConnection","onElementsRemove","elementsToRemove","element","isEdge","isNode","onLoad","_reactFlowInstance","deleteKeyCode","multiSelectionKeyCode","platform","assertDefined","TypeError","notUndefined","DraggableComponent","componentReference","props","draggable","onDragStart","setData","nativeEvent","effectAllowed","shrinkToWidth","borderSpacing","tableLayout","value","placeholder","typeSpec","argumentIsRequiredButMissing","typeSpecString","inputTitle","whiteSpace","overflow","textOverflow","verticalAlign","borderWidth","minWidth","required","pattern","onChange","disabled","COMPONENT_FEED_URLS_DEFAULT_VALUE","GITHUB_SEARCH_LOCATIONS_DEFAULT_VALUE","SettingBackedByLocalStorage","storageKey","defaultValue","_defaultValue","_storageKey","this","stringValue","localStorage","deserialize","valueString","serialize","StringSettingBackedByLocalStorage","StringArraySettingBackedByLocalStorage","AppSettingsBackedByLocalStorage","componentLibraryUrl","pipelineLibraryUrl","componentFeedUrls","gitHubSearchLocations","googleCloudOAuthClientId","getMutableAppSettings","mutableAppSettings","PrimitiveTypeEnum","TriggerStrategy","sanitizePipelineInfoName","pipelineContextName","toLowerCase","typeSpecToVertexPrimitiveTypeEnum","vertex","INT","DOUBLE","STRING","typeSpecToVertexParameterSpec","stringToMlmdValue","constantString","primitiveType","intValue","parseInt","doubleValue","parseFloat","MAKE_ARTIFACT_COMPONENT_ID","MAKE_ARTIFACT_EXECUTOR_ID","MAKE_ARTIFACT_INPUT_NAME","MAKE_ARTIFACT_OUTPUT_NAME","buildMakeArtifactTaskSpec","parameterArgumentSpec","taskInfo","parameters","cachingOptions","enableCache","makeArtifactComponentSpec","executorLabel","inputDefinitions","outputDefinitions","artifacts","artifactType","schemaTitle","makeArtifactExecutorSpec","container","image","command","buildVertexParameterArgumentSpec","taskArgument","runtimeValue","constantValue","componentInputParameter","taskOutputParameter","producerTask","outputParameterKey","buildVertexArtifactArgumentSpec","upstreamCannotBeArtifact","addMakeArtifactTaskAndGetArtifactArgumentSpec","componentInputArtifact","taskOutputArtifact","outputArtifactKey","buildVertexComponentSpecFromContainerComponentSpec","inputsThatHaveParameterArguments","addExecutorAndGetId","containerSpec","resolvedCommandLine","inputsConsumedAsParameter","inputsConsumedAsArtifact","convertArg","arg","inputValue","inputPath","outputPath","if","cond","else","ifCond","ifThen","ifElse","condEvaluatesToTrue","isPresent","unresolvedArgs","envValues","env","key","resolvedArgArray","resolveCommandLine","vertexExecutorId","inputMap","buildVertexComponentSpecFromGraphComponentSpec","addComponentAndGetId","vertexTasks","taskStringToTaskId","addTaskAndGetId","namePrefix","serializedSpec","existingId","usedIds","makeArtifactExecutorId","makeArtifactComponentSpecCopy","makeArtifactComponentsId","makeArtifactTaskSpec","artifactArgumentSpec","vertexTaskSpec","buildVertexTaskSpecFromTaskSpec","inputNamesThatAreUsedBothAsParameterAndArtifact","inputNamesThatAreParametersButAreConsumedAsArtifacts","record","transform","dagOutputArtifactSpecs","artifactSelectors","producerSubtask","dag","buildVertexComponentSpecFromComponentSpec","graphInputsWithParameterArguments","vertexComponentSpec","vertexComponentId","vertexTaskParameterArguments","vertexTaskArtifactArguments","buildVertexPipelineSpecFromGraphComponentSpec","vertexExecutors","executorStringToExecutorId","vertexComponents","componentStringToComponentId","executor","component","pipelineArguments","pipelineComponentSpec","vertexPipelineSpec","pipelineInfo","sdkVersion","schemaVersion","deploymentSpec","executors","components","root","buildVertexPipelineJobFromGraphComponent","gcsOutputDirectory","pipelineSpec","inputParameterDefinitions","defaultInputValuePairs","allPipelineArguments","convertedPipelineArguments","pipelineJob","displayName","runtimeConfig","isSettingsDialogOpen","setIsSettingsDialogOpen","DebugScratchElement","NODE_ENV","require","fontWeight","samplePipelineLibraryUrl","input","output","paddingLeft","isOpen","handleClose","DraggableComponentRow","componentRefWithSpec","setComponentRefWithSpec","FoldersAndComponentsVis","folder","folders","componentFolder","SingleFolderVis","ComponentLibraryVisFromStruct","componentLibraryStruct","loadComponentLibraryStructFromData","componentLibrary","loadComponentLibraryStructFromUrl","ComponentLibraryVisFromUrl","setComponentLibraryStruct","loadedComponentLibrary","GraphComponentExporter","includeComponentSpecs","graphComponent","componentTextBlob","Blob","downloadLink","createObjectURL","download","VertexAiExporter","vertexPipelineSpecText","vertexPipelineSpecTextBlob","vertexPipelineSpecTextBlobUrl","USER_COMPONENTS_LIST_NAME","UserComponentLibrary","errorMessage","setErrorMessage","setComponentFiles","contextMenuFileName","setContextMenuFileName","contextMenuAnchor","setContextMenuAnchor","isImportComponentDialogOpen","setIsImportComponentDialogOpen","refreshComponents","useCallback","acceptedFiles","forEach","file","reader","FileReader","onabort","onerror","onload","binaryStr","componentRefPlusData","gtag","readAsArrayBuffer","onImportFromUrl","componentFileEntry","handleContextMenuDelete","useDropzone","accept","getRootProps","getInputProps","isDragActive","marginBottom","minHeight","onContextMenu","currentTarget","anchorEl","onClose","dense","ImportComponentFromUrlDialog","onCancel","initialValue","onImport","urlInputRef","useRef","fullWidth","current","inputRef","AppSettingsDialog","setComponentLibraryUrl","setPipelineLibraryUrl","setDefaultPipelineUrl","setComponentFeedUrls","setGitHubSearchLocations","setGoogleCloudOAuthClientId","variant","multiline","split","resetToDefault","LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY","LOCAL_STORAGE_PROJECT_ID_KEY","LOCAL_STORAGE_REGION_KEY","LOCAL_STORAGE_PROJECT_IDS_KEY","VERTEX_AI_PIPELINES_REGIONS","authorizeGoogleCloudClient","clientId","scopes","immediate","Promise","resolve","reject","gapi","auth","authorize","client_id","scope","authResult","receivedScopesString","receivedScopes","every","ensureGoogleCloudAuthorizesScopes","oauthToken","cloudresourcemanagerListProjects","client","request","path","aiplatformCreatePipelineJob","projectId","region","pipelineJobId","method","body","GoogleCloudSubmitter","projects","setProjects","setProject","setRegion","setError","setGcsOutputDirectory","pipelineJobWebUrl","setPipelineJobWebUrl","compilationError","setCompilationError","vertexPipelineJob","setVertexPipelineJob","vertexPipelineJsonBlobUrl","setVertexPipelineJsonBlobUrl","labels","sdk","vertexPipelineJobJson","readyToSubmit","toISOString","substring","desiredPipelineJobId","pipelineJobName","slice","htmlFor","list","projectIds","projectInfo","IO_FILE_NAME","sanitizeParameterOrArtifactName","replaceAll","sanitizeID","sanitized1","MAKE_PARAMETER_TEMPLATE_ID","MAKE_PARAMETER_INPUT_NAME","MAKE_PARAMETER_OUTPUT_NAME","buildMakeParameterTaskSpec","artifactArgument","template","dependencies","makeParameterTemplate","CONTAINER_INPUTS_DIR","valueFrom","buildArgoContainerTemplateFromContainerComponentSpec","argoInputName","argoOutputName","CONTAINER_OUTPUTS_DIR","buildArgoTemplateFromComponentSpec","addTemplateAndGetId","argoTasks","taskCopyForHash","addMakeParameterTaskAndGetParameterArgument","makeArtifactTemplateId","argoTask","buildArgoDagTaskFromTaskSpec","argoTaskId","argoInputsConsumedAsParameter","argoInputsConsumedAsArtifact","dagOutputArtifactSources","outputArgoName","upstreamTaskOutputArgoName","upstreamTaskArgoId","buildArgoDagTemplateFromGraphComponentSpec","inputNameToArgoInputName","argoInputNameToInputName","argoTemplate","argoTemplateId","argoTaskParameterArguments","parameter","upstreamCannotBeParameter","argoGraphInputName","convertedParameterArgument","taskOutputArgoOutputName","taskOutputArgoTaskId","buildArgoParameterArgument","argoTaskArtifactArguments","artifact","raw","graphInputArgoName","buildArgoArtifactArgument","argoArgumentValues","upstreamArgoTaskIds","sanitizer","delimiter","newFinalName","buildArgoWorkflowFromGraphComponent","workflowSpec","argoTemplates","templateStringToTemplateId","templateCopyForHash","entrypoint","templates","buildArgoWorkflowSpecFromGraphComponentSpec","templateMap","rootTemplate","inputParameterNames","inputArtifactsNames","pipelineArgumentsWithArgoNames","apiVersion","kind","generateName","LOCAL_STORAGE_ENDPOINT_KEY","LOCAL_STORAGE_AUTH_TOKEN_KEY","kfpSubmitPipelineRun","argoWorkflowSpec","endpoint","authToken","runName","kfpRun","pipeline_spec","workflow_manifest","endsWith","apiUrl","access_token","json","generateKfpRunUrl","runId","KubeflowPipelinesSubmitter","argoWorkflow","setArgoWorkflow","argoWorkflowYamlBlobUrl","setArgoWorkflowYamlBlobUrl","submissionError","setSubmissionError","setEndpoint","setAuthToken","setPipelineRunId","setWorkflowResourceName","pipelineRunWebUrl","setPipelineRunWebUrl","argoWorkflowYaml","quotingType","newArgoWorkflowYamlBlobUrl","currentArgoWorkflowYamlBlobUrl","revokeObjectURL","run","runUrl","runtimeWorkflowManifestString","pipeline_runtime","runtimeWorkflowManifest","resourceName","PipelineSubmitter","setPipelineArguments","stringPipelineArguments","setStringPipelineArguments","newStringPipelineArguments","pair","GoogleCloud","GraphComponentLink","downloadFileName","linkText","linkRef","loadPipelineLibraryStructFromData","pipelineLibrary","loadPipelineLibraryStructFromUrl","SamplePipelineLibrary","componentRefs","setComponentRefs","pipelineUrls","all","loadedComponentRefs","marginLeft","USER_PIPELINES_LIST_NAME","removeSuffixes","s","suffixes","suffix","SavePipelineAsDialog","onPipelineSave","initialName","setFileName","isOverwriteDialogOpen","setIsOverwriteDialogOpen","handleSave","onSave","inputLabel","okButtonText","onOk","OkCancelDialog","cancelButtonText","Dialog","DialogTitle","DialogActions","Button","SaveAsDialog","nameInputRef","DialogContent","TextField","PipelineLibrary","pipelineFile","setPipelineFile","saveAsDialogIsOpen","setSaveAsDialogIsOpen","refreshPipelines","openPipelineFile","componentRef1","openSaveAsDialog","closeSaveAsDialog","handlePipelineSave","handleContextMenuOpen","openSamplePipeline","fileInput","componentLink","files","click","textDecoration","Menu","MenuItem","HASH_TO_CONTENT_DB_TABLE_NAME","HASH_TO_COMPONENT_NAME_DB_TABLE_NAME","URL_TO_HASH_DB_TABLE_NAME","HASH_TO_URL_DB_TABLE_NAME","URL_PROCESSING_VERSION_TABLE_NAME","BAD_HASHES_TABLE_NAME","isValidGitHubCodeSearchResultsStruct","isArray","items","getSingleGitHubCodeSearchPage","query","page","order","defaultDownloadData","encodedQuery","encodeURIComponent","encodedSort","encodedOrder","searchUrl","responseObject","githubHtmlUrlToDownloadUrl","htmlUrl","searchComponentsOnGitHubToGetUrlsAndHashes","searchLocations","urlsAndHashes","queryParts","searchResults","item","html_url","hash","sha","setTimeout","importComponentsFromGitHubSearch","urlsAndHashesIterator","urlToHashDb","hashToUrlDb","hashToContentDb","hashToComponentNameDb","urlProcessingVersionDb","badHashesDb","badHashReason","downloadUrl","cachedHash","urlVersion","Number","isComponentFeedEntry","isComponentFeed","isComponentFeedEntryArray","calculateGitBlobSha1HashHex","dataString","gitDataString","gitDataBytes","importComponentsFromFeed","componentFeedUrl","componentFeedCandidateObject","componentFeed","entry","urlsHashesAndData","error_message","componentSpecObj","refreshComponentDb","componentSearchConfig","ComponentFeedUrls","GitHubSearchLocations","getAllComponentsAsRefs","hashToComponentRef","isComponentDbEmpty","searchComponentsByName","SearchPanel","firstTime","setFirstTime","isLoaded","setIsLoaded","setQuery","setItems","results","componentElements","fetchData"],"mappings":";8aAuBaA,EACX,iJACWC,EACX,yLAgGaC,UAxFM,SAAC,GAIG,EAHvBC,cAGwB,IAFxBC,EAEuB,EAFvBA,iBAEuB,IADvBC,oBACuB,MADRC,IACQ,EACvB,EAA8BC,mBAAS,IAAvC,mBAAOC,EAAP,KAAgBC,EAAhB,KACA,EAAwCF,oBAAS,GAAjD,mBAAOG,EAAP,KAAqBC,EAArB,KAEA,OACE,qCACE,wBACEC,KAAK,SACLC,QAAS,SAACC,GACRC,YACEf,EACAK,GACAW,MAAK,SAAAC,GAAG,cAAIb,QAAJ,IAAIA,OAAJ,EAAIA,EAAmBa,EAAIC,UANzC,wCAWA,wBACEN,KAAK,SACLC,QAAO,uCAAE,WAAOC,GAAP,SAAAK,EAAA,sDACPJ,YACEd,EACAI,GACAW,MAAK,SAAAC,GAAG,cAAIb,QAAJ,IAAIA,OAAJ,EAAIA,EAAmBa,EAAIC,SAJ9B,2CAAF,sDAFT,kDAWA,wBACEL,QAAO,uCAAE,WAAOC,GAAP,iBAAAK,EAAA,sEAEgBC,MAAM,0BAA2B,CACtDC,QAAS,IAAIC,QAAQ,CACnBC,cAAe,UACf,eAAgB,sCALb,cAEDC,EAFC,gBAQoBA,EAASC,OAR7B,OAQDC,EARC,OASPjB,EAAWiB,GATJ,2CAAF,sDADT,sCAeA,+BAAOlB,IACP,cAAC,IAAD,UACE,cAAC,IAAD,wBAEF,wBACEK,QAAS,SAACC,GACRH,GAAgB,IAFpB,yBAOA,eAAC,IAAD,CAEEgB,KAAMjB,EAENkB,kBAAgB,qBAChBC,mBAAiB,2BALnB,UAOE,cAAC,IAAD,CAAaC,GAAG,qBAAhB,SAAsC,kBACtC,cAAC,IAAD,UACE,cAAC,IAAD,CAAmBA,GAAG,2BAAtB,uBAIF,eAAC,IAAD,WACE,cAAC,IAAD,CAAQC,MAAM,UAAUlB,QAAS,SAACC,GAAD,OAAOH,GAAgB,IAAxD,sBAGA,cAAC,IAAD,CACEoB,MAAM,UACNlB,QAAS,SAACC,GAAD,OAAOH,GAAgB,IAChCqB,WAAS,EAHX,8B,wiBC1FJC,EAAU,aACVC,EAA+B,2BAC/BC,EAAyC,2BAEzCC,EAA8B,gBAC9BC,EAAwC,0BAGxCC,EAAkC,cAclCC,EAAsB,uCAAG,WAAOC,GAAP,qBAAArB,EAAA,6DACvBsB,EACY,kBAATD,GAAoB,IAAIE,aAAcC,OAAOH,GAAQA,EAFjC,SAGJI,OAAOC,OAAOC,OAAO,UAAWL,GAH5B,cAGvBM,EAHuB,OAIvBC,EAAYC,MAAMC,KAAK,IAAIC,WAAWJ,IACtCK,EAAUJ,EACbK,KAAI,SAACC,GAAD,OAAOA,EAAEC,SAAS,IAAIC,SAAS,EAAG,QACtCC,KAAK,IAPqB,kBAQtBL,GARsB,2CAAH,sDAWtBM,EAAkB,uCAAG,WACzBZ,EACA3C,GAFyB,iBAAAgB,EAAA,6DAInBwC,EAA0BC,IAAYC,eAAe,CACzDC,KAAM7B,EACN8B,UAAW5B,IAEP6B,EAA0BJ,IAAYC,eAAe,CACzDC,KAAM7B,EACN8B,UAxC2C,6BA8BpB,SAYnBJ,EAAwBM,QAAQnB,EAAQ3C,GAZrB,eAaE+D,IAAvB/D,EAAc2D,KAbO,gCAcjBE,EAAwBC,QAAQnB,EAAQ3C,EAAc2D,MAdrC,2CAAH,wDAkBXK,EAA0B,uCAAG,WACxCC,GADwC,yBAAAjD,EAAA,yDAGlCkD,EACqB,kBAAlBD,EACHA,GACA,IAAIE,aAAcC,OAAOH,GACzBI,EACqB,kBAAlBJ,GACH,IAAI1B,aAAcC,OAAOyB,GACzBA,EAGmB,kBADnBK,EAAYC,IAAKC,KAAKN,KACuB,OAAdI,EAbG,sBAchCG,MAAM,+CAAD,OAAgDH,IAdrB,UAgBnCI,YAAqBJ,GAhBc,sBAiBhCG,MAAM,6DAAD,OACoDH,IAlBzB,cAqBlCtE,EAA+BsE,EArBG,UAuBnBlC,EAAuBiC,GAvBJ,eAuBlC1B,EAvBkC,OAwBlCgC,EAA2C,CAC/C5D,KAAMf,EACN2C,OAAQA,EACRrB,KAAM4C,GA3BgC,kBA6BjCS,GA7BiC,4CAAH,sDAgC1BC,EAAyB,uCAAG,WACvCC,GADuC,6BAAA7D,EAAA,6DAEvCd,EAFuC,+BAENC,IAFM,SAIZD,EAAa2E,EAAKb,GAJN,cAIjCW,EAJiC,QAK1BE,IAAMA,EALoB,kBAMhCF,GANgC,2CAAH,sDASzBG,EAA0B,uCAAG,WACxC9E,GADwC,2CAAAgB,EAAA,yDAExCd,EAFwC,+BAEPC,SAIZ4D,KAHrBgB,EAHwC,0BAOtCA,EAAe,IAAIC,OAEjB,UAAWhF,EAAciF,gBATW,uBAUfC,OAAOC,OAC5BnF,EAAciF,eAAeG,MAAMC,OAXC,4CAU3BC,EAV2B,KAa9BC,EAAeD,EAASX,aAAaE,SAEjBd,KADtByB,EAAoBF,EAASX,aAAa5D,MAdV,yBAgBCgD,IAA/BuB,EAASX,aAAarD,KAhBQ,kCAiBDsD,EAC7BU,EAASX,aAAarD,KACtBpB,GAnB8B,QAiB1BuF,EAjB0B,OAqBhCD,EAAoBC,EAAiB1E,KArBL,gCAsBNgD,IAAjBwB,EAtBuB,yBAwBNxB,KAD1ByB,EAAoBT,EAAaW,IAAIH,IAvBL,kCAyBCX,EAC7BW,EACArF,GA3B4B,QAyBxBuF,EAzBwB,OA6B9BD,EAAoBC,EAAiB1E,KACrCgE,EAAaY,IAAIJ,EAAcC,GA9BD,gBAiCRzB,IAAtByB,EAjC8B,iBAmChCI,QAAQC,MACN,0CACAP,EAASX,cArCqB,+BAwChCW,EAASX,aAAa5D,KAAOyE,EAxCG,UAyC1BV,EACJQ,EAASX,aAAa5D,KACtBb,EACA6E,GA5C8B,4DAkDjC/E,GAlDiC,4CAAH,sDAqD1BY,EAA4B,uCAAG,WAC1CiE,GAD0C,iCAAA7D,EAAA,6DAE1Cd,EAF0C,+BAETC,IAFS,SAIfyE,EAA0BC,EAAK3E,GAJhB,cAIpCyE,EAJoC,gBAKdG,EAC1BH,EAAa5D,KACbb,GAPwC,cAKpCF,EALoC,OASpC8F,EAToC,2BAUrCnB,GAVqC,IAWxC5D,KAAMf,IAXkC,kBAanC8F,GAbmC,2CAAH,sDAgB5BC,EAAqB,uCAAG,WACnCpB,GADmC,uCAAA3D,EAAA,yDAEnCd,EAFmC,+BAEFC,IACjC6F,IAHmC,sCAMTjC,IAAtBY,EAAa5D,KANkB,yBAOPgD,IAAtBY,EAAarD,KAPgB,iCAQE0C,EAC/BW,EAAarD,MATgB,OAQzB2E,EARyB,OAW/BH,EAAe,2BACVnB,GADU,IAEb5D,KAAMkF,EAAmBlF,KACzB4B,OAAQsD,EAAmBtD,OAC3BrB,KAAM2E,EAAmB3E,OAfI,gCAkBNyC,IAArBY,EAAaE,IAlBc,kCAmBID,EAC/BD,EAAaE,IACb3E,GArB2B,QAmBvB+F,EAnBuB,OAuB7BH,EAAe,2BACVnB,GADU,IAEb5D,KAAMkF,EAAmBlF,KACzB4B,OAAQsD,EAAmBtD,OAC3BrB,KAAM2E,EAAmB3E,OA3BE,8BA8BvBmD,MAAM,+EAAD,OACsEE,IA/BpD,uCAoCjCiB,QAAQM,KAAK,sDACPjC,EAAgBkC,EAAoBxB,EAAa5D,MArCtB,UAsCHqB,EAAuB6B,GAtCpB,QAsC3BmC,EAtC2B,OAuCjCN,EAAe,2BACVnB,GADU,IAEb5D,KAAM4D,EAAa5D,KACnB4B,OAAQyD,EACR9E,KAAM2C,IA3CyB,eA8C/B+B,GACFlB,EAA2BgB,EAAgB/E,KAAMb,GA/ChB,kBAiD5B4F,GAjD4B,4CAAH,sDAoDrBO,EAAkB,uCAAG,WAChCpC,GADgC,mBAAAjD,EAAA,6DAG1BqD,EACqB,kBAAlBJ,GACH,IAAI1B,aAAcC,OAAOyB,GACzBA,EAN0B,SAOLD,EACzBC,GAR8B,cAO1BU,EAP0B,OAU1B2B,EAA0B7C,IAAYC,eAAe,CACzDC,KAAM7B,EACN8B,UAAW7B,IAZmB,SAc1BuE,EAAwBxC,QAC5Ba,EAAahC,OACb0B,GAhB8B,uBAkB1Bd,EAAmBoB,EAAahC,OAAQgC,EAAa5D,MAlB3B,gCAoBzB4D,GApByB,4CAAH,sDAgFlB4B,EAAqB,uCAAG,WACnC1B,GADmC,qDAAA7D,EAAA,6DAEnCwF,EAFmC,gCAI7BC,EAAgBhD,IAAYC,eAAe,CAC/CC,KAAM7B,EACN8B,UAAW3B,IAEPuB,EAA0BC,IAAYC,eAAe,CACzDC,KAAM7B,EACN8B,UAAW5B,IAEP0E,EAAiBjD,IAAYC,eAAe,CAChDC,KAAM7B,EACN8B,UAAW7B,IAdsB,SAiBN0E,EAAcE,QAAgB9B,GAjBxB,UAkBZ,QADjB+B,EAjB6B,0CAmBLpD,EAAwBmD,QAClDC,GApB+B,eAmB3B5G,EAnB2B,iBAsBL0G,EAAeC,QACzCC,GAvB+B,WAsB3BC,EAtB2B,OAyBX,OAAlB7G,GAA4C,OAAlB6G,EAzBG,wBA0BzBlC,EAA2C,CAC/CE,IAAKA,EACLlC,OAAQiE,EACR7F,KAAMf,EACNsB,MAAM,IAAI6C,aAAcC,OAAOyC,IA9BF,kBAgCxBlC,GAhCwB,QAkC/BiB,QAAQC,MAAR,wDACmDhB,EADnD,yCACuF+B,EADvF,uCAlC+B,yBAyCZ3F,MAAM4D,GAzCM,eAyC7BxD,EAzC6B,iBA0CPA,EAASyF,cA1CF,eA0C7BD,EA1C6B,iBA2CRR,EAAmBQ,GA3CX,YA2C7BlC,EA3C6B,QA4CtBE,IAAMA,OAEJd,KADTpB,EAASgC,EAAahC,QA7CO,wBA+CjCiD,QAAQC,MAAR,gGA/CiC,kBAkD1BlB,GAlD0B,eAoDZ,OAAnBiC,GAA2BjE,IAAWiE,GACxChB,QAAQC,MAAR,wDACmDhB,EADnD,kCACgF+B,EADhF,+BACqHjE,EADrH,MAIIoE,EAAyBtD,IAAYC,eAAe,CACxDC,KAAM7B,EACN8B,UAAW1B,IA3DsB,UA6DA6E,EAAuBJ,QACxDhE,GA9DiC,WAgEN,QAHvBqE,EA7D6B,0CAiE3BD,EAAuBjD,QAAQnB,EAAQkC,GAjEZ,mCAmE7BA,IAAQmC,EAnEqB,oBAoE/BpB,QAAQqB,MACN,qCAA8BtE,EAA9B,mCAA+DkC,EAA/D,8CAAwGmC,EAAxG,OACGR,EAAoB,+BAAiC,MAEtDA,EAxE2B,kCAyEvBO,EAAuBjD,QAAQnB,EAAQkC,GAzEhB,yBA+E7B4B,EAAc3C,QAAQe,EAAKlC,GA/EE,iCAgF5BgC,GAhF4B,4CAAH,sDAoG5BuC,EAA8B,SAClCvD,EACAwD,GAIA,IAFA,IAAIC,EAAYzD,EACZ0D,EAAQ,EACLF,EAAcG,IAAIF,IAEvBA,EAAYzD,EAAO,OADnB0D,GAC+BjE,WAEjC,OAAOgE,GAGHG,EAAuB,uCAAG,WAC9BC,EACAC,EACA9C,GAH8B,yBAAA3D,EAAA,sEAKxB0G,EAA6BF,GALL,cAMxBG,EAAYxF,EAAkCqF,EAC9CI,EAAkBnE,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAW+D,IATiB,SAWHC,EAAgBjB,QACzCc,GAZ4B,cAWxBI,EAXwB,OAcxBC,EAAc,IAAIC,KAClBlB,GAAgB,IAAItE,aAAcC,OAAOmC,EAAarD,MAG1D0G,EADmB,OAAjBH,EACU,CACVlD,aAAcA,EACdhB,KAAM8D,EACNQ,aAAcH,EACdI,iBAAkBJ,EAClBzF,KAAMwE,GAGC,2BACJgB,GADI,IAEPlE,KAAM8D,EACNS,iBAAkBJ,EAClBzF,KAAMwE,EACNlC,aAAcA,IA/BY,UAkCxBiD,EAAgB9D,QAAQ2D,EAAUO,GAlCV,iCAmCvBA,GAnCuB,4CAAH,0DAsCvBG,EAAqB,uCAAG,WAC5BX,EACA7C,GAF4B,mCAAA3D,EAAA,6DAG5ByG,EAH4B,+BAGT,YAHS,SAKtBC,EAA6BF,GALP,cAMtBG,EAAYxF,EAAkCqF,EAC9CI,EAAkBnE,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAW+D,IATe,KAWFS,IAXE,SAWgBR,EAAgBS,OAXhC,0BAWtBlB,EAXsB,eAYtBmB,EAAiBpB,EAA4BO,EAAUN,GAZjC,kBAarBI,EACLC,EACAc,EACA3D,IAhB0B,4CAAH,wDAoBd4D,EAAuB,uCAAG,WACrCf,EACA3C,GAFqC,+BAAA7D,EAAA,6DAGrCwH,EAHqC,+BAGX,YAHW,SAKVjC,EAAsB1B,GALZ,cAK/BF,EAL+B,yBAM9BwD,EACLX,EACA7C,EAF0B,UAG1BA,EAAa5D,KAAK4C,YAHQ,QAGA6E,IATS,2CAAH,wDAavBC,EAAwB,uCAAG,WACtCjB,EACAvD,EACAwD,GAHsC,+BAAAzG,EAAA,6DAItCwH,EAJsC,+BAIZ,YAJY,SAMXnC,EAAmBpC,GANR,cAMhCU,EANgC,yBAO/BwD,EACLX,EACA7C,EAF0B,iBAG1B8C,QAH0B,IAG1BA,IAAY9C,EAAa5D,KAAK4C,YAHJ,QAGY6E,IAVF,2CAAH,0DAcxBE,EAAgC,uCAAG,WAC9ClB,EACAC,EACAxD,GAH8C,eAAAjD,EAAA,sEAKnBqF,EAAmBpC,GALA,cAKxCU,EALwC,yBAMvC4C,EACLC,EACAC,EACA9C,IAT4C,2CAAH,0DA6BhCgE,EAA4B,uCAAG,WAAOnB,GAAP,mBAAAxG,EAAA,sEACpC0G,EAA6BF,GADO,cAEpCG,EAAYxF,EAAkCqF,EAC9CI,EAAkBnE,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAW+D,IAETiB,EAAiB,IAAI5D,IAPiB,SAQpC4C,EAAgBiB,SACpB,SAACb,EAAWP,EAAUqB,GACpBF,EAAejD,IAAI8B,EAAUO,MAVS,gCAanCY,GAbmC,2CAAH,sDAgB5BG,EAAwB,uCAAG,WACtCvB,EACAC,GAFsC,iBAAAzG,EAAA,sEAIhC0G,EAA6BF,GAJG,cAKhCG,EAAYxF,EAAkCqF,EAC9CI,EAAkBnE,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAW+D,IARyB,kBAU/BC,EAAgBjB,QAA4Bc,IAVb,2CAAH,wDAaxBuB,EAA2B,uCAAG,WACzCxB,EACAC,GAFyC,iBAAAzG,EAAA,sEAInC0G,EAA6BF,GAJM,cAKnCG,EAAYxF,EAAkCqF,EAC9CI,EAAkBnE,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAW+D,IAR4B,kBAUlCC,EAAgBqB,WAAWxB,IAVO,2CAAH,wDAyB3BtB,EAAsB,SAACnG,GAClC,OAAOuE,IAAK2E,KAAKlJ,EAAe,CAAEmJ,UAAW,OAIzCzB,EAA4B,uCAAG,WAAOF,GAAP,mFAAAxG,EAAA,6DAC7BoI,EAA0B,iCAAmC5B,EAC7D6B,EAA2B5F,IAAYC,eAAe,CAC1DC,KAAM7B,EACN8B,UAhkB2C,6BAkkBvC0F,EAAyBnH,EAAkCqF,EAC3DI,EAAkBnE,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAW0F,IATsB,SAY1BD,EAAyB1C,QAAgByC,GAZf,sJAajC,EAbiC,WAW/BG,EAX+B,KAc9B,CAAC,EAAG,EAAG,EAAG,GAAGC,SAASD,GAdQ,uBAe3B9E,MAAM,2DAAD,OACkD8E,EADlD,0BACqF/B,IAhB/D,WAmBT,IAAtB+B,EAnB+B,wBAoBjC3D,QAAQ6D,IAAR,0DAA+DjC,IACzDkC,EAAsBjG,IAAYC,eAAe,CACrDC,KAAM7B,EACN8B,UAplBoC,wBA6jBL,UA0BxB8F,EAAoB/C,QAAQa,GA1BJ,uJA0BkB,GA1BlB,QAyB3BmC,EAzB2B,KA4B7BxC,EAAgB,IAAIiB,IAClBwB,EACS,mBAAbpC,EAAgC,WAAa,YA9Bd,cA+BNmC,GA/BM,kEA+BtBhF,EA/BsB,QAgCzB8C,EAhCyB,UAgCd9C,EAAa5D,KAAK4C,YAhCJ,QAgCYiG,EACrCtB,EAAiBpB,EACrBO,EACAN,GAEIa,EAAkC,CACtCrD,aAAcA,GAtCe,UAwCzBiD,EAAgB9D,QAAQwE,EAAgBN,GAxCf,QAyC/Bb,EAAc0C,IAAIvB,GAzCa,kKA2C3Be,EAAyBvF,QAAQsF,EAAyB,GA3C/B,QA4CjCG,EAAoB,EACpB3D,QAAQ6D,IAAR,yDACoDjC,EADpD,uBAC2E+B,IA9C1C,WAiDT,IAAtBA,EAjD+B,yBAkD3B7C,EAAiBjD,IAAYC,eAAe,CAChDC,KAAM7B,EACN8B,UAAW7B,IApDoB,UAsDT6F,EAAgBS,OAtDP,QAsD3ByB,EAtD2B,qBAuDVA,GAvDU,kEAuDtBrC,EAvDsB,kBAwDPG,EAAgBjB,QACtCc,GAzD6B,WA2Db,QAHZO,EAxDyB,+BA4DvBvD,MAAM,SAAD,OAAUgD,EAAV,qCA5DkB,eA8D3B9C,EAAeqD,EAAUrD,aA9DE,UA+Dd+B,EAAeC,QAC9BqB,EAAUrD,aAAahC,QAhEM,WAkElB,QAHTN,EA/D2B,gCAmE7BuD,QAAQC,MAAR,yDACoD4B,EADpD,yBAC6EO,EAAUrD,aAAahC,OADpG,MAGMsB,EAAgBkC,EAAoB6B,EAAUrD,aAAa5D,MACjEsB,GAAO,IAAIE,aAAcC,OAAOyB,GAvEH,UAwEL7B,EAAuBC,GAxElB,cAwEvB0H,EAxEuB,OAyE7BpF,EAAahC,OAASoH,EACtBnE,QAAQM,KAAR,yBACoBuB,EADpB,4CACgEO,EAAUrD,aAAahC,OADvF,wBAC6GoH,EAD7G,MAIMtF,MAAM,kDAAD,OACyCgD,EADzC,yBACkEO,EAAUrD,aAAahC,OADzF,MA9EkB,eAkFzBmF,EAAc,IAAIC,KAClBiC,EAAqC,CACzCrG,KAAM8D,EACNQ,aAAcH,EACdI,iBAAkBJ,EAClBzF,KAAMA,EACNsC,aAAcA,GAxFe,UA0FzBiD,EAAgB9D,QAAQ2D,EAAUuC,GA1FT,6JA4FjCT,EAAoB,EA5Fa,WA6F3BF,EAAyBvF,QAC7BsF,EACAG,GA/F+B,SAiGjC3D,QAAQ6D,IAAR,yDACoDjC,EADpD,uBAC2E+B,IAlG1C,YAqGT,IAAtBA,EArG+B,oCAuGT3B,EAAgBS,OAvGP,SAuG3ByB,EAvG2B,qBAwGVA,GAxGU,qEAwGtBrC,EAxGsB,mBAyGPG,EAAgBjB,QACtCc,GA1G6B,YA4Gb,QAHZO,EAzGyB,gCA6GvBvD,MAAM,SAAD,OAAUgD,EAAV,qCA7GkB,gBA+G1BO,EAAUrD,aAAarD,OAC1B0G,EAAUrD,aAAarD,MAAO,IAAI6C,aAAcC,OAAO4D,EAAU3F,OAhHpC,WAkHzBuF,EAAgB9D,QAAQ2D,EAAUO,GAlHT,mKAoHjCuB,EAAoB,EApHa,WAqH3BF,EAAyBvF,QAC7BsF,EACAG,GAvH+B,SAyHjC3D,QAAQ6D,IAAR,yDACoDjC,EADpD,uBAC2E+B,IA1H1C,oGAAH,uD,mLCvkB5BU,EAA2B,2BAuBpBC,EAAqC,WAChD,IACE,IAAMjG,EAAgBkG,OAAOC,eAAezD,QAC1CsD,GAEF,GAAsB,OAAlBhG,EAAwB,CAC1B,IAAMoG,EAAa9F,IAAKC,KAAKP,GAC7B,GAAmB,OAAfoG,GAA6C,kBAAfA,EAGhC,OAD2BA,GAI/B,MAAOC,GACP1E,QAAQC,MAAMyE,KAQLC,EAAoB,SAAC,GAI3B,IAHLvK,EAGI,EAHJA,cAIMwK,EAAQC,aAAc,SAACC,GAAD,OAAWA,EAAMF,SAM7C,YAHczG,IAAVyG,GAAuBA,EAAMG,OAAS,GAnDI,SAC9C3K,EACAwK,GAEA,SACgBzG,IAAVyG,IACmB,IAAjBA,EAAMG,QACR/E,QAAQM,KAAK,yCAEflG,EAAgB4K,YAAqB5K,EAAewK,GAAO,GAAM,IAEnE,IAAMvG,EAAgBkC,YAAoBnG,GAC1CmK,OAAOC,eAAetG,QAAQmG,EAA0BhG,GACxD,MAAOqG,GAAW,IAAD,GAE4C,KAAtD,OAAHA,QAAG,IAAHA,GAAA,UAAAA,EAAKjK,eAAL,eAAcwK,WAAW,8BAC3BjF,QAAQC,MAAMyE,IAoChBQ,CAAiC9K,EAAewK,GAE3C,M,gBCuBMO,EA7DC,WACd,MAA0C3K,qBAA1C,mBAAOJ,EAAP,KAAsBC,EAAtB,KACA,EAAsBG,mBAAS4K,eAAxBC,EAAP,oBAEM/K,EAAeC,IA0BrB,OAxBA+K,qBAAU,WACR,sBAAC,gCAAAlK,EAAA,8DAE+B+C,KADxBoH,EAAwBjB,KAD/B,uBAGGjK,EAAiBkL,GAHpB,iCAMOC,EAAqBH,EAAYG,mBANxC,kBAQoCxK,YAC/BwK,EACAlL,GAVL,OAQSmL,EART,OAYGpL,EAAiBoL,EAAmBtK,MAZvC,kDAcG6E,QAAQC,MAAR,mDAC8CuF,IAE9CxF,QAAQC,MAAR,MACA5F,EAAiBqL,KAlBpB,yDAAD,KAqBC,CAACL,EAAYG,mBAAoBlL,SAEd6D,IAAlB/D,EACK,6BAIP,qBAAKuL,UAAU,UAAf,SACE,eAAC,IAAD,WACE,qBAAKA,UAAU,oBAAf,SACE,eAACC,EAAA,EAAD,CACExL,cAAeA,EACfC,iBAAkBA,EAClBwL,YAAY,EACZC,SAAU,CA5CJ,OAwCR,UAME,cAAC,IAAD,IACA,cAAC,IAAD,IACA,cAAC,IAAD,CAAYC,IAhDN,UAmDV,cAACC,EAAA,EAAD,CACE5L,cAAeA,EACfC,iBAAkBA,EAClBgL,YAAaA,EACb/K,aAAcA,IAEhB,cAAC,EAAD,CAAmBF,cAAeA,U,SCjC3B6L,MA7Cf,WACE,OACE,wBACEN,UAAU,SACVO,MAAO,CACLC,MAAO,OACPC,OAAQ,OACRC,QAAS,MACTC,UAAW,SACXC,gBAAiB,cAPrB,SAUE,sBAAKL,MAAO,CAAEM,QAAS,gBAAvB,UACE,cAACC,EAAA,EAAD,CACEC,KAAK,+BACLC,UAAU,QACVC,OAAO,SACPC,IAAI,WACJX,MAAO,CAAEY,OAAQ,OALnB,mBASA,cAACL,EAAA,EAAD,CACEC,KAAK,4DACLC,UAAU,QACVC,OAAO,SACPC,IAAI,WACJX,MAAO,CAAEY,OAAQ,OALnB,2BASA,cAACL,EAAA,EAAD,CACEC,KAAK,6CACLC,UAAU,QACVC,OAAO,SACPC,IAAI,WACJX,MAAO,CAAEY,OAAQ,OALnB,kCCpBOC,MATf,WACE,OACE,sBAAKpB,UAAU,MAAMO,MAAO,CAAEC,MAAO,OAAQC,OAAQ,qBAArD,UACE,cAAC,EAAD,IACA,cAAC,EAAD,QCJAY,EAAcC,QACW,cAA7B1C,OAAO2C,SAASC,UAEe,UAA7B5C,OAAO2C,SAASC,UAEhB5C,OAAO2C,SAASC,SAASC,MAAM,2DAyCnC,SAASC,EAAgBC,EAAeC,GACtCC,UAAUC,cACPC,SAASJ,GACTrM,MAAK,SAAC0M,GACLA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBG,QACfR,UAAUC,cAAcQ,YAI1BjI,QAAQ6D,IACN,+GAKE0D,GAAUA,EAAOW,UACnBX,EAAOW,SAASP,KAMlB3H,QAAQ6D,IAAI,sCAGR0D,GAAUA,EAAOY,WACnBZ,EAAOY,UAAUR,WAO5BS,OAAM,SAACnI,GACND,QAAQC,MAAM,4CAA6CA,MChGjE,IAYeoI,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBtN,MAAK,YAAkD,IAA/CuN,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOF,GACPG,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAQN,OCiBdO,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SFLnB,SAAkB1B,GACvB,GAA6C,kBAAmBC,UAAW,CAGzE,GADkB,IAAI0B,IAAIC,mBAAwB5E,OAAO2C,SAASR,MACpD0C,SAAW7E,OAAO2C,SAASkC,OAIvC,OAGF7E,OAAO8E,iBAAiB,QAAQ,WAC9B,IAAM/B,EAAK,UAAM6B,mBAAN,sBACPnC,IAgEV,SAAiCM,EAAeC,GAE9ClM,MAAMiM,EAAO,CACXhM,QAAS,CAAE,iBAAkB,YAE5BL,MAAK,SAACQ,GAEL,IAAM6N,EAAc7N,EAASH,QAAQwE,IAAI,gBAEnB,MAApBrE,EAAS8N,QACO,MAAfD,IAA8D,IAAvCA,EAAYE,QAAQ,cAG5ChC,UAAUC,cAAcgC,MAAMxO,MAAK,SAAC0M,GAClCA,EAAa+B,aAAazO,MAAK,WAC7BsJ,OAAO2C,SAASyC,eAKpBtC,EAAgBC,EAAOC,MAG1Ba,OAAM,WACLpI,QAAQ6D,IAAI,oEAtFV+F,CAAwBtC,EAAOC,GAI/BC,UAAUC,cAAcgC,MAAMxO,MAAK,WACjC+E,QAAQ6D,IACN,+GAMJwD,EAAgBC,EAAOC,OEhB/BsC,GAKAxB,K,2MC/BMyB,EAAoB,uCAAG,WAC3B7K,EACA8K,GAF2B,yCAAA3O,EAAA,6DAG3B4O,EAH2B,+BAGP,QACpBC,EAJ2B,yCAMPC,OAAOtO,KAAKoO,GANL,cAMrBG,EANqB,gBAONA,EAAM/C,MAAMnI,GAPN,UAOvBxD,EAPuB,OAQvB2O,GAAoB,OACPjM,IAAb1C,IAA0BwO,EATH,4CAWG5O,MAAM4D,GAXT,YAWjBoL,EAXiB,QAYNC,GAZM,uBAaf,IAAIzL,MAAJ,uCAC4BwL,EAAYd,OADxC,aACmDc,EAAYE,aAdhD,QAiBvB9O,EAAW4O,EACXD,GAAoB,EAlBG,2DAoBNjM,IAAb1C,EApBmB,2CA0BrB+O,EAAqB/O,EAASgP,QA1BT,KA4BZV,EA5BY,UA4BMtO,EAASyF,cA5Bf,uBA4BrBwJ,GA5BqB,eA6BvBN,EA7BuB,kCA8BnBD,EAAMQ,IAAI1L,EAAKuL,GA9BI,iCAgCpBE,GAhCoB,2DAAH,wDAwCnB,SAAepQ,EAAtB,oC,4CAAO,WACL2E,EACA8K,GAFK,iBAAA3O,EAAA,sEAIkBC,MAAM4D,GAJxB,WAICxD,EAJD,QAKS6O,GALT,sBAMG,IAAIzL,MAAJ,uCAC4BpD,EAAS8N,OADrC,aACgD9N,EAAS8O,aAP5D,mBAUUR,EAVV,SAU4BtO,EAASyF,cAVrC,0BAUCwJ,GAVD,gCAWEA,GAXF,6C,sBAcP,IAAME,EAAwB,CAC5B,sFACA,yEAGK,SAAerQ,EAAtB,oC,4CAAO,WACL0E,EACA8K,GAFK,eAAA3O,EAAA,6DAICyP,EAAcD,EAAsBE,MAAK,SAACC,GAAD,OAAY9L,EAAImI,MAAM2D,MAJhE,kBAKEjB,EAAqB7K,EAAK8K,EAAa,SAAUc,IALnD,4C,sBAUP,SAASG,EAAiBC,GACxB,OAAO,IAAI1M,aAAcC,OAAOyM,GAG3B,SAASC,EAAuBD,GACrC,IAAME,EAAMC,KAAKC,MAAML,EAAiBC,IACxC,GAAmB,kBAARE,QAA4BhN,IAARgN,GAA6B,OAARA,EAClD,OAAOA,EAET,MAAMtM,MAAM,4CAAD,cAAoDsM,EAApD,MAGN,SAASG,EAAuBL,GACrC,IAAME,EAAMxM,IAAKC,KAAKoM,EAAiBC,IACvC,GAAmB,kBAARE,QAA4BhN,IAARgN,GAA6B,OAARA,EAClD,OAAOA,EAET,MAAMtM,MAAM,4CAAD,cAAoDsM,EAApD,Q,gCChGb,sGAySO,IAAMrM,EAAuB,SAACqM,GAAD,MACnB,kBAARA,GAAoB,mBAAoBA,GAEpCI,EAA4B,SACvClM,GADuC,MAEO,cAAeA,GAElDmM,EAAwB,SACnCnM,GADmC,MAEO,UAAWA,I,kNCvOxCoM,EAzDe,SAAC,GAII,IAHjC/L,EAGgC,EAHhCA,SACAgM,EAEgC,EAFhCA,YACAC,EACgC,EADhCA,aAEA,EAAgDnR,mBAAQ,eAEjDkF,EAASkM,YAFhB,mBAAOC,EAAP,KAAyBC,EAAzB,KAIM1R,EAAgBsF,EAASX,aAAa5D,KAC5C,YAAsBgD,IAAlB/D,GACF4F,QAAQC,MACN,iEACAP,GAEK,8BAIP,uBACEqM,SAAQ,uCAAE,WAAOhR,GAAP,SAAAK,EAAA,sDACRL,EAAEiR,iBADM,2CAAF,sDAKR9F,MAAO,CACL+F,SAAU,QACVC,WAAY,QACZC,OAAQ,kBACRC,aAAc,MACd/F,QAAS,QAXb,UAgBE,0DAA6BjM,EAAc2D,QAC3C,cAACsO,EAAA,EAAD,CACEjS,cAAeA,EACfkS,mBAAoBT,EACpBU,sBAAuBT,IAEzB,wBAAQjR,KAAK,SAASC,QAAS4Q,EAA/B,mBAGA,wBACE7Q,KAAK,SACLC,QAAS,SAACC,GACI,OAAZ4Q,QAAY,IAAZA,KAAeE,GACJ,OAAXH,QAAW,IAAXA,QAJJ,uBC1CAc,EAAsBC,IAASC,IAC/BC,EAAuBF,IAASG,OAQzBC,EAAsB,SAACC,GAAD,MACnB,SAAdA,EAAKjS,WAAiCsD,IAAd2O,EAAKrQ,MAAsB,aAAcqQ,EAAKrQ,MAExE,SAASsQ,EACPC,EACAC,EACAhB,EACAiB,EACAC,GAIA,IAFA,IAAIC,EAAmB,GACjBC,EAAaL,EAAQjI,OAClBuI,EAAI,EAAGA,EAAID,EAAYC,IAAK,CAAC,IAAD,IAC7BC,EAASP,EAAQM,GACjBvR,EAAKmR,EAAWK,EAAOxP,KAEvByP,EAAwBC,OAAO,MADXH,EAAI,IAAMD,EAAa,KACc,IACzDnH,EACJ+F,IAAaQ,IAASC,KAAOT,IAAaQ,IAASG,OAC/C,CAAEc,KAAMF,GACR,CAAEG,IAAKH,GAEPI,EAAU,oBAAGL,EAAO1S,YAAV,aAAG,EAAa2C,kBAAhB,QAA8B,MAC1CqQ,EAAa,CAAC,iBAAUX,GAAV,OAAqBU,GAAaE,QAAQ,KAAM,OAChD,OAACX,QAAD,IAACA,IAA8B,IAAIvJ,SAAS2J,EAAOxP,OAEnE8P,EAAWE,KA9BmB,oBAgChCF,EAAaA,EAAWvQ,KAAI,SAACqI,GAAD,OAAeA,EAAUmI,QAAQ,KAAM,QAEnE,MAAmCE,EAAmB/B,EAAUoB,GAAhE,mBAAOY,EAAP,KAAqBC,EAArB,KACMC,EACJZ,EAAOxP,KAAO,MAAQ6P,EAAa,MAAQL,EAAOa,aAAe,IACnEhB,EAAiBW,KACf,cAAC,IAAD,CAEElT,KAAMoS,EACNhB,SAAUA,EACVlQ,GAAIA,EACJmK,MAAOA,EACPmI,eAAe,EACfC,MAAOH,EACPxI,UAAWkI,EAAWnQ,KAAK,KAR7B,SAUE,qBAAKiI,UAAWsI,EAAc/H,MAAOgI,EAArC,SACGX,EAAOxP,QAVLhC,IAeX,OAAOqR,EAIT,SAASY,EACP/B,EACAoB,GAEA,IAAIkB,EA5DmB,IA8DnBN,EAAe,QAmBnB,OAfIhC,IAAaQ,IAASC,KAAOT,IAAaQ,IAASG,QACjDS,EAAa,IAEfkB,EArEmB,KAqEmBlB,EAAa,IAGjDkB,EAAkB,KACpBA,EAAkB,GAClBN,GAAgB,kBAGlBM,EAAkB,GAIb,CAACN,EAD0B,CAAEO,SAAS,GAAD,OAAKD,EAAL,QAkB9C,IAAME,EAAoB,SAAC,GAAiD,IAAD,QAA9ChS,EAA8C,EAA9CA,KAC3B,EAA0DjC,oBAAS,GAAnE,mBAAOkU,EAAP,KAA8BC,EAA9B,KAEMjP,EAAWjD,EAAKiD,SAChBtF,EAAgBsF,EAASX,aAAa5D,KAC5C,QAAsBgD,IAAlB/D,EACF,OAAQ,6BAGV,IAAMwU,EAAK,UAAGxU,EAAc2D,YAAjB,QAAyB,cAChCuQ,EAAQ,YAAc7R,EAAKoS,OAC3BzU,EAAc2D,OAChBuQ,GAAS,gBAAkBlU,EAAc2D,MAEvC2B,EAASX,aAAaE,MACxBqP,GAAS,UAAY5O,EAASX,aAAaE,KAEzCS,EAASX,aAAahC,SACxBuR,GAAS,aAAe5O,EAASX,aAAahC,QAE5C3C,EAAcgU,cAChBE,GAAS,kBAAoBlU,EAAcgU,aAE7C,IAAMU,GAA6B,UAAC1U,EAAc2U,cAAf,QAAyB,IACzDC,QACC,SAACC,GAAD,aACyB,IAAvBA,EAAUC,eACY/Q,IAAtB8Q,EAAUE,WACRF,EAAUlR,QAAV,UAAmB2B,EAASkM,iBAA5B,QAAyC,QAE9CtO,KAAI,SAAC2R,GAAD,OAAeA,EAAUlR,QAC1BqR,EA7CR,SAA8BC,EAAyBP,GACrD,OAAO/B,EAAgBsC,EAAY,SAAU7C,EAAqB,SAAUsC,GA4CvDQ,CAAoB,UAAClV,EAAc2U,cAAf,QAAyB,GAAID,GAChES,EAzCCxC,EAyCoC,UAAC3S,EAAcoV,eAAf,QAA0B,GAzCjC,SAAU7C,EAAsB,WA0C9DS,EAAmBgC,EAAaK,OAAOF,GAM7C,OACE,sBACEG,cAAe,WACbf,GAA0BD,IAE5BJ,MAAOA,EAJT,UAQGM,EACAxB,EACAsB,GACC,cAAC,EAAD,CACEhP,SAAUA,EACVgM,YAlBqB,WAC3BiD,GAAyB,IAkBnBhD,aAAclP,EAAKkP,mB,0HC3IvBgE,EAAuB,+CAEhBjK,EAA4C,CACvDrG,eAAgB,CACdG,MAAO,CACLC,MAAO,MAKPmQ,EAAiB,SAAC7T,GAAD,MAAgB,QAAUA,GAC3C8T,EAAoB,SAAC9R,GAAD,MAAkB,SAAWA,GACjD+R,EAAqB,SAAC/R,GAAD,MAAkB,UAAYA,GAEnDgS,EAAiB,SAAChU,GAAD,OAAgBA,EAAG+R,QAAQ,SAAU,KACtDkC,EAAoB,SAACjU,GAAD,OAAgBA,EAAG+R,QAAQ,UAAW,KAC1DmC,EAAqB,SAAClU,GAAD,OAAgBA,EAAG+R,QAAQ,WAAY,KAErD9I,EAAuB,SAClC5K,EACAwK,GAGI,IAAD,MAFHsL,EAEG,wDADHC,IACG,yDACH/V,EAAa,eAAQA,GAErB,IAAMgW,EAA4B,SAACtD,GAAD,OAChC1B,KAAKiF,UAAU,CAEbC,EAAGxD,EAAKyD,KAAKtE,SAASqE,EACtBE,EAAG1D,EAAKyD,KAAKtE,SAASuE,EACtBrK,MAAO2G,EAAKyD,KAAKpK,MACjBC,OAAQ0G,EAAKyD,KAAKnK,UAGhBqK,EAAwB,SAACC,EAAUC,GACvC,IAAMC,EAASF,EAAGH,KAAKtE,SAASqE,EAAIK,EAAGJ,KAAKtE,SAASqE,EAC/CO,EAASH,EAAGH,KAAKtE,SAASuE,EAAIG,EAAGJ,KAAKtE,SAASuE,EACrD,OAAkB,IAAXI,EAAeA,EAASC,GAE3BC,EAAwB,SAACJ,EAAUC,GACvC,IAAMC,EAASF,EAAGH,KAAKtE,SAASqE,EAAIK,EAAGJ,KAAKtE,SAASqE,EAC/CO,EAASH,EAAGH,KAAKtE,SAASuE,EAAIG,EAAGJ,KAAKtE,SAASuE,EACrD,OAAkB,IAAXK,EAAeA,EAASD,GAK3BG,EAAanM,EAChBoK,QAAO,SAAClC,GAAD,MAAwB,UAAdA,EAAKjS,QACtBmW,KAAKP,GACFQ,EAAcrM,EACjBoK,QAAO,SAAClC,GAAD,MAAwB,WAAdA,EAAKjS,QACtBmW,KAAKP,GACFS,EAAYtM,EACfoK,OAAOnC,GACPmE,KAAKF,GAEFK,EAAmB,IAAI/R,IAC3B2R,EAAWzT,KAAI,SAACwP,GAAD,MAAU,CACvBkD,EAAkBlD,EAAK/Q,IACvBqU,EAA0BtD,QAGxBsE,EAAgB,IAAIhS,IACxB2R,EAAWzT,KAAI,SAACwP,EAAMrL,GAAP,MAAiB,CAACuO,EAAkBlD,EAAK/Q,IAAK0F,OAEzD4P,EAAqB,SAACjW,EAAcmC,GAAf,eACzB,UAAC6T,EAActR,IAAI1E,EAAE2C,aAArB,QAA8BuT,MAA9B,UACCF,EAActR,IAAIvC,EAAEQ,aADrB,QAC8BuT,MAC1BC,EAAoB,IAAInS,IAC5B6R,EAAY3T,KAAI,SAACwP,GAAD,MAAU,CACxBmD,EAAmBnD,EAAK/Q,IACxBqU,EAA0BtD,QAGxB0E,EAAiB,IAAIpS,IACzB6R,EAAY3T,KAAI,SAACwP,EAAMrL,GAAP,MAAiB,CAACwO,EAAmBnD,EAAK/Q,IAAK0F,OAE3DgQ,EAAsB,SAACrW,EAAemC,GAAhB,eAC1B,UAACiU,EAAe1R,IAAI1E,EAAE2C,aAAtB,QAA+BuT,MAA/B,UACCE,EAAe1R,IAAIvC,EAAEQ,aADtB,QAC+BuT,MAC3BI,EAAkB,IAAItS,IAC1B8R,EAAU5T,KAAI,SAACwP,GAAD,MAAU,CACtBiD,EAAejD,EAAK/Q,IACpBqU,EAA0BtD,QAGxB6E,EAAe,IAAIvS,IACvB8R,EAAU5T,KAAI,SAACwP,EAAMrL,GAAP,MAAiB,CAACsO,EAAejD,EAAK/Q,IAAK0F,OAErDmQ,EAAoB,SACxBC,EACAC,GAFwB,eAIxB,UAACH,EAAa7R,IAAI+R,EAAM,WAAxB,QAA+BP,MAA/B,UACCK,EAAa7R,IAAIgS,EAAM,WADxB,QAC+BR,MAqDjC,GAnDAlX,EAAc2U,OAAd,UAAuB3U,EAAc2U,cAArC,aAAuB,EACnBzR,KAAI,SAAC2R,GACL,IAAKkC,EAAiBzP,IAAIuN,EAAUlR,QAAUqT,EAAc1P,IAAIuN,EAAUlR,MACxE,MAAMc,MAAM,4CAAD,OAA6CoQ,EAAUlR,OAEpE,IAAIgU,EAAc,eAAQ9C,EAAU+C,aAChC7B,EACF4B,EAAeE,mBAA8Bd,EAAiBrR,IAC5DmP,EAAUlR,aAGLgU,EAAeE,mBAExB,IAAIC,EAAuB,2BACtBjD,GADsB,IAEzB+C,YAAaD,IAKf,OAH2C,IAAvCzS,OAAOmD,KAAKsP,GAAgBhN,eACvBmN,EAAaF,YAEfE,KAERlB,KAAKK,GAERjX,EAAcoV,QAAd,UAAwBpV,EAAcoV,eAAtC,aAAwB,EACpBlS,KAAI,SAAC6U,GACL,IAAKZ,EAAkB7P,IAAIyQ,EAAWpU,QAAUyT,EAAe9P,IAAIyQ,EAAWpU,MAC5E,MAAMc,MAAM,6CAAD,OAA8CsT,EAAWpU,OAEtE,IAAIgU,EAAc,eAAQI,EAAWH,aACjC7B,EACF4B,EAAeE,mBAA8BV,EAAkBzR,IAC7DqS,EAAWpU,aAGNgU,EAAeE,mBAExB,IAAIG,EAAyB,2BACxBD,GADwB,IAE3BH,YAAaD,IAQf,YALqB5T,IAAnB4T,GACuC,IAAvCzS,OAAOmD,KAAKsP,GAAgBhN,eAErBqN,EAAcJ,YAEhBI,KAERpB,KAAKS,IAEHjG,YAAsBpR,EAAciF,gBACvC,OAAOjF,EAGT,IAAIiY,EAAoB,eAAQjY,EAAciF,eAAeG,OACvD8S,EAAWhT,OAAOiT,YACtBjT,OAAOkT,QAAQH,EAAU5S,OAAS,IAC/BnC,KAAI,YAAyB,IAAD,mBAAtBuR,EAAsB,KAAdnP,EAAc,KAC3B,IAAKgS,EAAgBhQ,IAAImN,KAAY8C,EAAajQ,IAAImN,GACpD,MAAMhQ,MAAM,2CAAD,OAA4CgQ,IAEzD,IAAIkD,EAAc,eAAQrS,EAASsS,aAC/B7B,EACF4B,EAAeE,mBACbP,EAAgB5R,IAAI+O,UAEfkD,EAAeE,mBAExB,IAAIQ,EAAqB,2BACpB/S,GADoB,IAEvBsS,YAAaD,IAmBf,YAhBqB5T,IAAnB4T,GACuC,IAAvCzS,OAAOmD,KAAKsP,GAAgBhN,eAErB0N,EAAYT,YAIlB9B,QACiC/R,IAAlCsU,EAAY1T,aAAa5D,WACQgD,IAAjCsU,EAAY1T,aAAaE,MAEzBwT,EAAY1T,aAAZ,eAAgC0T,EAAY1T,qBACrC0T,EAAY1T,aAAa5D,aAG3BsX,EAAY1T,aAAarD,KACzB,CAACmT,EAAQ4D,MAEjBzB,KAAKY,SAEOzT,IAAbmU,IACFD,EAAU5S,MAAQ6S,GAEpBlY,EAAa,2BACRA,GADQ,IAEXiF,eAAe,2BAAMjF,EAAciF,gBAArB,IAAqCG,MAAO6S,MAe5D,IAAMK,EAAuB,SAAC,GAAD,IAC3B3U,EAD2B,EAC3BA,KACAqQ,EAF2B,EAE3BA,YACAuE,EAH2B,EAG3BA,SACA5D,EAJ2B,EAI3BA,OACAS,EAL2B,EAK3BA,QACAnQ,EAN2B,EAM3BA,eACGuT,EAPwB,oCAAC,+DASxB7U,GAAQ,CAAEA,KAAMA,IAChBqQ,GAAe,CAAEA,YAAaA,IAC9BuE,GAAY,CAAEA,SAAUA,IACxB5D,GAAU,CAAEA,OAAQA,IACpBS,GAAW,CAAEA,QAASA,IAbC,IAc3BnQ,eAAgBA,GACbuT,IAIL,OAFAxY,EAAgBsY,EA7BhBtY,EAAa,2BACRA,GADQ,IAEXuY,SAAS,2BACJvY,EAAcuY,UADX,IAENX,YAAY,2BAAD,QAAC,EACP5X,EAAcuY,gBADR,aACN,EAAwBX,aADlB,kBA7MU,MA+MGrC,UA4BxBrO,EAA8B,SAACvD,EAAcwD,GAGjD,IAFA,IAAIC,EAAYzD,EACZ0D,EAAQ,EACLF,EAAcG,IAAIF,IAEvBA,EAAYzD,EAAO,OADnB0D,GAC+BjE,WAEjC,OAAOgE,GAgGHqR,EAAY,CAChBC,KDhMaC,eAAKtE,IC0qBduE,GAFSpN,IAregB,SAAC,GAKI,IAAD,UAJjCqN,EAIiC,EAJjCA,SAIiC,IAHjC7Y,qBAGiC,MAHjB,CAAEiF,eAAgB,CAAEG,MAAO,CAAEC,MAAO,MAGnB,EAFjCpF,EAEiC,EAFjCA,iBACGuY,EAC8B,iBACjC,EAAkDpY,qBAAlD,mBAAO0Y,EAAP,KAA0BC,EAA1B,KAEA,KAAO,UAAW/Y,EAAciF,gBAE9B,OAAO,6BAET,IAAIgT,EAAYjY,EAAciF,eAAeG,MAEvCoF,EAAQtF,OAAOkT,QAAQH,EAAU5S,OAAOnC,KAC5C,YAAyB,IAAD,mBAAtBuR,EAAsB,KAAdnP,EAAc,KAClBuM,EAAuB,CAAEqE,EAAG,EAAGE,EAAG,GACtC,QAA6BrS,IAAzBuB,EAASsS,YACX,IACE,IAAMoB,EAAmB1T,EAASsS,YAChC,mBAEIqB,EAAkBjI,KAAKC,MAAM+H,GACnCnH,EAAW,CAAEqE,EAAG+C,EAAe,EAAO7C,EAAG6C,EAAe,GACxD,MAAO3O,IAGX,MAAO,CACL3I,GAAI6T,EAAef,GACnBpS,KAAM,CACJiD,SAAUA,EACVmP,OAAQA,EACRlD,aAAc,SAAC2H,GAAD,OAAUC,EAAiB1E,EAAQyE,KAEnDrH,SAAUA,EACVpR,KAAM,WAKNkW,GAAa,UAAC3W,EAAc2U,cAAf,QAAyB,IAAIzR,KAC9C,SAAC2R,GACC,IAAIhD,EAAuB,CAAEqE,EAAG,EAAGE,EAAG,GACtC,QAA8BrS,IAA1B8Q,EAAU+C,YACZ,IACE,IAAMoB,EAAmBnE,EAAU+C,YACjC,mBAEIqB,EAAkBjI,KAAKC,MAAM+H,GACnCnH,EAAW,CAAEqE,EAAG+C,EAAe,EAAO7C,EAAG6C,EAAe,GACxD,MAAO3O,IAEX,MAAO,CACL3I,GAAI8T,EAAkBZ,EAAUlR,MAChCtB,KAAM,CAAEmS,MAAOK,EAAUlR,MACzBkO,SAAUA,EACVpR,KAAM,YAKNoW,GAAc,UAAC7W,EAAcoV,eAAf,QAA0B,IAAIlS,KAChD,SAAC6U,GACC,IAAIlG,EAAuB,CAAEqE,EAAG,EAAGE,EAAG,GACtC,QAA+BrS,IAA3BgU,EAAWH,YACb,IACE,IAAMoB,EAAmBjB,EAAWH,YAClC,mBAEIqB,EAAkBjI,KAAKC,MAAM+H,GACnCnH,EAAW,CAAEqE,EAAG+C,EAAe,EAAO7C,EAAG6C,EAAe,GACxD,MAAO3O,IAEX,MAAO,CACL3I,GAAI+T,EAAmBqC,EAAWpU,MAClCtB,KAAM,CAAEmS,MAAOuD,EAAWpU,MAC1BkO,SAAUA,EACVpR,KAAM,aAKN2Y,EAAgBlU,OAAOkT,QAAQH,EAAU5S,OAAOgU,SACpD,YAAyB,IAAD,qBAAtB5E,EAAsB,KAAdnP,EAAc,KACtB,OAAOJ,OAAOkT,QAAP,UAAe9S,EAASkM,iBAAxB,QAAqC,IAAI6H,SAC9C,YAA4B,IAAD,mBAAzBC,EAAyB,KAAdC,EAAc,KACzB,GAAwB,kBAAbA,EACT,MAAO,GAET,GAAI,eAAgBA,EAAU,CAC5B,IAAMC,EAAaD,EAASC,WAS5B,MAAO,CARY,CACjB7X,GAAG,GAAD,OAAK6X,EAAW/E,OAAhB,YAA0B+E,EAAWC,WAArC,YAAmDhF,EAAnD,YAA6D6E,GAC/DI,OAAQlE,EAAegE,EAAW/E,QAClCkF,aAAa,UAAD,OAAYH,EAAWC,YACnCjN,OAAQgJ,EAAef,GACvBmF,aAAa,SAAD,OAAWN,GACvBO,cAAeC,IAAcC,cAG1B,GAAI,eAAgBR,EAAU,CACnC,IAAMS,EAAaT,EAASS,WAW5B,MAAO,CAVY,CACjBrY,GAAG,SAAD,OAAWqY,EAAWV,UAAtB,YAAmC7E,EAAnC,YAA6C6E,GAC/CI,OAAQjE,EAAkBuE,EAAWV,WAGrCK,aAAc,KACdnN,OAAQgJ,EAAef,GACvBmF,aAAa,SAAD,OAAWN,GACvBO,cAAeC,IAAcC,cAK/B,OADAnU,QAAQC,MAAM,wCAAyC0T,GAChD,SAOXU,EAAsB/U,OAAOkT,QAAP,UAAeH,EAAUiC,oBAAzB,QAAyC,IAAIhX,KACvE,YAA6B,IAAD,mBAA1BuW,EAA0B,KACpBD,EADoB,KACEA,WAW5B,MAVmB,CACjB7X,GAAG,GAAD,OAAK6X,EAAW/E,OAAhB,YAA0B+E,EAAWC,WAArC,mBAA0DA,GAC5DC,OAAQlE,EAAegE,EAAW/E,QAClCkF,aAAa,UAAD,OAAYH,EAAWC,YACnCjN,OAAQkJ,EAAmB+D,GAG3BG,aAAc,KACdC,cAAeC,IAAcC,gBAM7BI,EAAY3P,EAAmB6K,OAAOsB,GAAYtB,OAAOwB,GAAaxB,OAAO+D,GAAO/D,OAAO4E,GAE3FG,EAAuB,SAACC,GAC5Bra,EAAgBqa,EAChBpa,EAAiBoa,IAGbC,EAAmB,SAACC,GACxBtC,EAAYsC,EACZH,EAAqB,2BAAKpa,GAAN,IAAqBiF,eAAgB,CAAEG,MAAO6S,OAG9DkB,EAAmB,SACvB1E,EACA+F,GAEA,IAAID,EAAuB,2BACtBtC,GADsB,IAEzB5S,MAAM,eAAM4S,EAAU5S,SAExBkV,EAAalV,MAAMoP,GAAnB,2BACKwD,EAAU5S,MAAMoP,IADrB,IAEEjD,UAAWgJ,IAEbF,EAAiBC,IAGbE,EAAkB,SACtBhG,EACA6E,EACAC,GAEA,IACMmB,EADczC,EAAU5S,MAAMoP,GACKjD,UACrCmJ,EAAkD,eACjDD,QAEY3W,IAAbwV,SACKoB,EAAqBrB,GAE5BqB,EAAqBrB,GAAaC,EAEpCJ,EAAiB1E,EAAQkG,IAGrBC,EAAqB,SAACnG,EAAgB6E,GAAjB,OACzBmB,EAAgBhG,EAAQ6E,OAAWvV,IAE/B8W,EAAsB,SAC1BpB,EACAqB,GAEA,IAAIC,EAAoB,eAAQ9C,EAAUiC,mBACtBnW,IAAhB+W,SACKC,EAAqBtB,GAE5BsB,EAAqBtB,GAAcqB,EAErC7C,EAAS,2BAAQA,GAAR,IAAmBiC,aAAca,IAC1CT,EAAiBrC,IAGb+C,EAAyB,SAACvB,GAAD,OAC7BoB,EAAoBpB,IAEhBwB,EAAgB,SAACC,GAAmC,IAAD,IACvD,GAA0B,OAAtBA,EAAWxB,QAAyC,OAAtBwB,EAAW1O,OAA7C,CAQA,IAAM2O,EAAmB,UAAGD,EAAWtB,oBAAd,aAAG,EAAyBlG,QAAQ,UAAW,IAClE0H,EAAoB,UAAGF,EAAWvB,oBAAd,aAAG,EAAyBjG,QAAQ,WAAY,IAE1E,QAA6B3P,IAAzBqX,EAAoC,CAEtC,IAAMC,EAAyC,CAC7C7B,WAAY,CACV/E,OAAQkB,EAAeuF,EAAWxB,QAClCD,WAAY2B,SAIYrX,IAAxBoX,EAEFV,EACE9E,EAAeuF,EAAW1O,QAC1B2O,EACAE,GAIFR,EACEhF,EAAmBqF,EAAW1O,QAC9B6O,OAIC,CAEL,IACMC,EAAyC,CAC7CtB,WAAY,CACVV,UAHmB1D,EAAkBsF,EAAWxB,eAMxB3V,IAAxBoX,EAEFV,EACE9E,EAAeuF,EAAW1O,QAC1B2O,EACAG,GAKF1V,QAAQC,MACN,uEACAqV,SAtDJtV,QAAQC,MACN,uDACAqV,IA8DAK,EAAa,SAACC,GAAgB,IAAD,EAC3BlC,EAAS,UAAGkC,EAAK5B,oBAAR,aAAG,EAAmBlG,QAAQ,UAAW,SAEtC3P,IAAduV,EACFsB,EAAmBjF,EAAe6F,EAAKhP,QAAS8M,GAEhD0B,EAAuBnF,EAAmB2F,EAAKhP,UAuE7CiP,EAAa,SAAC/I,GAElB,GAAkB,UAAdA,EAAKjS,MArEkB,SAACib,GAG5B,IAH2D,IAAD,EAG1D,MAAiCxW,OAAOkT,QAAQH,EAAU5S,OAA1D,eACE,IADG,0BAAOoP,EAAP,KAAenP,EAAf,KACH,MAAoCJ,OAAOkT,QAAP,UAClC9S,EAASkM,iBADyB,QACZ,IADxB,eAEG,CAAC,IAAD,EAFE,sBAAO8H,EAAP,KAAkBC,EAAlB,KAGqB,kBAAbA,GAAyB,eAAgBA,GAC9CA,EAASS,WAAWV,YAAcoC,GACpCd,EAAmBnG,EAAQ6E,GAQnC,IAAMqC,GAAY,UAAC3b,EAAc2U,cAAf,QAAyB,IAAIC,QAC7C,SAACC,GAAD,OAAeA,EAAUlR,OAAS+X,KAEpC1b,EAAa,2BAAQA,GAAR,IAAuB2U,OAAQgH,IAC5CvB,EAAqBpa,GAkDnB4b,CADkBhG,EAAkBlD,EAAK/Q,UAEpC,GAAkB,WAAd+Q,EAAKjS,KAAmB,EAhDP,SAACob,GAAgC,IAAD,EAC5Db,EAAuBa,GAEvB,IAAMC,GAAa,UAAC9b,EAAcoV,eAAf,QAA0B,IAAIR,QAC/C,SAACmD,GAAD,OAAgBA,EAAWpU,OAASkY,KAEtC7b,EAAa,2BAAQA,GAAR,IAAuBoV,QAAS0G,IAC7C1B,EAAqBpa,GA2CnB+b,CADmBlG,EAAmBnD,EAAK/Q,UAEtC,GAAkB,SAAd+Q,EAAKjS,KAAiB,EAzChB,SAACub,GAGlB,IAH8C,IAAD,EAG7C,MAAiC9W,OAAOkT,QAAQH,EAAU5S,OAA1D,eACE,IADG,0BAAOoP,EAAP,KAAenP,EAAf,KACH,MAAoCJ,OAAOkT,QAAP,UAClC9S,EAASkM,iBADyB,QACZ,IADxB,eAEG,CAAC,IAAD,EAFE,sBAAO8H,EAAP,KAAkBC,EAAlB,KAGqB,kBAAbA,GAAyB,eAAgBA,GAC9CA,EAASC,WAAW/E,SAAWuH,GACjCpB,EAAmBnG,EAAQ6E,GAQnC,IAAMyB,EAAuB7V,OAAOiT,YAClCjT,OAAOkT,QAAP,UAAeH,EAAUiC,oBAAzB,QAAyC,IAAItF,QAC3C,oDAA4B4E,WAAW/E,SAAWuH,MAGtD/D,EAAS,2BAAQA,GAAR,IAAmBiC,aAAca,IAG1C,IAAIR,EAAuB,2BACtBtC,GADsB,IAEzB5S,MAAM,eAAM4S,EAAU5S,gBAEjBkV,EAAalV,MAAM2W,GAC1B1B,EAAiBC,GAaf0B,CADetG,EAAejD,EAAK/Q,UAGnCiE,QAAQ6D,IAAI,qCAAsCiJ,IAuGtD,OACE,cAAC,IAAD,2BACM8F,GADN,IAEE2B,SAAUA,EACV1B,UAAWA,EACXyD,UAzMc,SAACC,GACjBlB,EAAckB,IAyMZC,WApFe,SAACC,GAClBA,EAAMzK,iBACNyK,EAAMC,aAAaC,WAAa,QAmF9BC,OAhFW,SAACH,GAGd,GAFAA,EAAMzK,iBAEFkH,EAAmB,CACrB,IAAM2D,EAAcJ,EAAMC,aAAaI,QAAQ,yBAC/C,GAAoB,KAAhBD,EACF,OAEF,IAAME,EAAoB3L,KAAKC,MAAMwL,GAC/BG,EAAW1X,OAAOmD,KAAKsU,GAAmB,GAC1CE,EAAWF,EAAkBC,GAG/BE,EAAc,EACdC,EAAc,EACZC,EAAsBX,EAAMC,aAAaI,QAAQ,oBACvD,GAA4B,KAAxBM,EAA4B,CAAC,IAAD,IACxBC,EAAkBjM,KAAKC,MAAM+L,GACnCF,EAAW,UAAGG,EAAgBC,eAAnB,QAA8B,EACzCH,EAAW,UAAGE,EAAgBE,eAAnB,QAA8B,EAK3C,IAAItL,EAAWiH,EAAkBsE,QAAQ,CACvClH,EAAGmG,EAAMgB,QAAUP,EACnB1G,EAAGiG,EAAMiB,QAAUP,IAGfQ,EAAe,CAAErH,EAAGrE,EAASqE,EAAGE,EAAGvE,EAASuE,GAC5CoH,EAAsB,CAC1B,kBAAmBxM,KAAKiF,UAAUsH,IAEpC,GAAiB,SAAbX,EAAqB,CAAC,IAAD,IACjBtX,EAAWuX,EACXY,EAAiB,2BAClBnY,EAASsS,aACT4F,GAELlY,EAASsS,YAAc6F,EACvB,IAAMC,EAAgC,2BACjCpY,GADiC,IAEpCsS,YAAa6F,IAEThJ,EA9fY,SACxBwD,GAGA,OAAO/Q,EADJ,uDADY,OAIb,IAAIkB,IAAIlD,OAAOmD,KAAK4P,EAAU5S,SAwfXsY,CACb1F,EAD8B,oBAE9B3S,EAASX,aAAa5D,YAFQ,aAE9B,EAA4B4C,YAFE,QAEM,SAEtCsU,EAAS,2BAAQA,GAAR,IAAmB5S,MAAM,eAAM4S,EAAU5S,UACxCA,MAAMoP,GAAUiJ,EAC1BpD,EAAiBrC,QACZ,GAAiB,UAAb2E,EAAsB,CAAC,IAAD,EAEzB/H,EAAuB,CAC3BlR,KA5hBiB,SACzB3D,GAEI,IAAD,EACH,OAAOkH,EADJ,uDADY,QAIb,IAAIkB,IAAJ,UAAQpI,EAAc2U,cAAtB,aAAQ,EAAsBzR,KAAI,SAAC2R,GAAD,OAAeA,EAAUlR,UAohBvCia,CAAmB5d,GAGjC4X,YAAa4F,GAET7I,GAAS,UAAC3U,EAAc2U,cAAf,QAAyB,IAAIU,OAAO,CAACR,IACpD7U,EAAa,2BAAQA,GAAR,IAAuB2U,OAAQA,IAC5CyF,EAAqBpa,QAChB,GAAiB,WAAb4c,EAAuB,CAAC,IAAD,EAE1B7E,EAAyB,CAC7BpU,KA3hBkB,SAC1B3D,GAEI,IAAD,EACH,OAAOkH,EADJ,uDADY,SAIb,IAAIkB,IAAJ,UAAQpI,EAAcoV,eAAtB,aAAQ,EAAuBlS,KAAI,SAAC6U,GAAD,OAAgBA,EAAWpU,UAmhBzCka,CAAoB7d,GAGnC4X,YAAa4F,GAETpI,GAAU,UAACpV,EAAcoV,eAAf,QAA0B,IAAIC,OAAO,CAAC0C,IACtD/X,EAAa,2BAAQA,GAAR,IAAuBoV,QAASA,IAC7CgF,EAAqBpa,MAavB8d,aA9FiB,SAACC,EAAeC,GACnCzC,EAAWwC,GACX9C,EAAc+C,IA6FZC,iBA5GqB,SAACC,GAAgC,IAAD,gBACjCA,GADiC,IACvD,2BAAwC,CAAC,IAA9BC,EAA6B,QAClCC,YAAOD,IACT5C,EAAW4C,IAHwC,kDAMjCD,GANiC,IAMvD,2BAAwC,CAAC,IAA9BC,EAA6B,QAClCE,YAAOF,IACT1C,EAAW0C,IARwC,gCA6GrDG,OA3FW,SAACC,GAAD,OACbxF,EAAqBwF,IA2FnBC,cAAa,UACXhG,EAAKgG,qBADM,QACY5F,IAAc,YAAc,SAErD6F,sBAAqB,UACnBjG,EAAKiG,6BADc,QACY7F,IAAc,UAAY,UAd7D,SAiBGC,MAOW,kBAChB1O,OAAOiD,UAAUsR,SAAS7T,WAAW,QACrCV,OAAOiD,UAAUsR,SAAS7T,WAAW,WACrCV,OAAOiD,UAAUsR,SAAS7T,WAAW,SACrCV,OAAOiD,UAAUsR,SAAS7T,WAAW,W,gCCh2BhC,SAAS8T,EAAiB5N,GAC/B,QAAYhN,IAARgN,EACF,MAAM6N,UAAU,uBAElB,OAAO7N,EAGF,SAAS8N,EAAgB3I,GAC9B,YAAanS,IAANmS,EAhBT,qE,kFCgEe4I,IAhCY,SAAC,GAGI,IAAD,QAQa,EAV1CC,EAE6B,EAF7BA,mBACGC,EAC0B,iBACzB9K,GAAQ,UAAA6K,EAAmBhe,YAAnB,eAAyB4C,OAAQ,IACzCob,EAAmBla,MACrBqP,GAAS,UAAY6K,EAAmBla,KAEtCka,EAAmBpc,SACrBuR,GAAS,aAAe6K,EAAmBpc,QAE7C,UAAIoc,EAAmBhe,YAAvB,aAAI,EAAyBiT,eAC3BE,GAAS,6BAAoB6K,EAAmBhe,YAAvC,aAAoB,EAAyBiT,cAExD,OACE,6CACEzI,UAAU,sDACV0T,WAAS,EACTC,YAAa,SAAC7C,GAIZ,OA1CY,SAACA,EAAkBQ,GACrCR,EAAMC,aAAa6C,QAAQ,wBAAyBnO,KAAKiF,UAAU4G,IACnER,EAAMC,aAAa6C,QACjB,mBACAnO,KAAKiF,UAAU,CACbiH,QAASb,EAAM+C,YAAYlC,QAC3BC,QAASd,EAAM+C,YAAYjC,WAG/Bd,EAAMC,aAAa+C,cAAgB,OAiCtBH,CAAY7C,EAAO,CAAE3D,KAHD,CACzB/T,aAAcoa,MAIlB7K,MAAOA,GACH8K,GAVN,iCAYGD,EAAmBhe,YAZtB,aAYG,EAAyB4C,YAZ5B,QAYoC,iB,kDCsGzBsO,IAjIS,SAAC,GAKI,IAAD,EAJ1BjS,EAI0B,EAJ1BA,cACAkS,EAG0B,EAH1BA,mBACAC,EAE0B,EAF1BA,sBAE0B,IAD1BmN,qBAC0B,SAC1B,OACE,qBACE/T,UAAU,2BACVO,MAAO,CACLM,QAAS,QACTmT,cAAe,MAEfC,YAAaF,EAAgB,QAAU,OAEvCvT,MAAO,QARX,UAWG,UAAC/L,EAAc2U,cAAf,QAAyB,IAAIzR,KAAI,SAAC2R,GAAe,IAAD,EACzCyE,EAAYzE,EAAUlR,KACxB8b,OAA4B1b,EAC5B2b,OAAkC3b,EAChCwV,EAAWrH,EAAmBoH,QACnBvV,IAAbwV,EACFkG,EAAQ5K,EAAUE,QAEM,kBAAbwE,EACTkG,EAAQlG,EAERmG,EADS,eAAgBnG,EACd,qBAAiBA,EAASC,WAAW/E,OAArC,cAAiD8E,EAASC,WAAWC,WAArE,KACF,eAAgBF,EACd,4BAAwBA,EAASS,WAAWV,UAA5C,KAEG,cAIlB,IA/CkBqG,EA+CZC,IACFtG,KAAapH,KACQ,IAAvB2C,EAAUC,eACY/Q,IAAtB8Q,EAAUE,QAEN8K,QAnDK9b,KADO4b,EAqDC9K,EAAUpU,MAnD1B,MAEe,kBAAbkf,EACFA,EAEF3O,KAAKiF,UAAU0J,MA+CU,IAAvB9K,EAAUC,SAAoB,IAAM,IAEjCgL,EAAU,UAAMxG,EAAN,aAAoBuG,EAApB,cACdhL,EAAUb,aAAe,IAG3B,OACE,sBAEElI,MAAO,CACLM,QAAS,aAHb,UAME,uBACE8H,MAAO4L,EACPhU,MAAO,CACLI,UAAW,QACXE,QAAS,aACT2T,WAAY,SACZC,SAAU,SACVC,aAAc,YAPlB,SAUE,iCACG3G,EADH,KAEE,sBACExN,MAAO,CACLmU,aAAc,WACdD,SAAU,SACV5L,SAAU,OACVhI,QAAS,eACT8T,cAAe,UAEjBhM,MAAO2L,EART,SAUGA,IAZL,SAiBF,uBACE/T,MAAO,CACLM,QAAS,aAET+T,YAAa,MAEbC,SAAU,OACVhM,SAAU,QAEZsL,YAAaA,EACbW,SAAUT,EACVH,MAAK,UAAEA,SAAF,QAAW,GAChBa,aAA+BzL,EAAUpU,KACzC8f,SAAU,SAAC5f,GACTuR,EAAmBoH,GAAa3Y,EAAE6L,OAAOiT,MACzCtN,EAAsB,eAAKD,OAG/B,qBACEpG,MAAO,CACLM,QAAS,aAGTL,MAAO,QALX,SAQE,wBACEtL,KAAK,SACLyT,MAAM,mBACNxT,QAAS,SAACC,UACDuR,EAAmBoH,GAC1BnH,EAAsB,eAAKD,KAE7BsO,WAAYlH,KAAapH,GAP3B,wBA1DGoH,U,wIC5DXmH,EAAoC,CACxC,sHAKIC,EAAwC,CAC5C,oDAkBaC,E,WAIb,WAAYC,EAAoBC,GAAkB,yBAHlDC,mBAGiD,OAFjDC,iBAEiD,EAC/CC,KAAKF,cAAgBD,EACrBG,KAAKD,YAAcH,E,uCAGrB,WAME,IACE,IAAMK,EAAc9W,OAAO+W,aAAava,QAAQqa,KAAKD,aACrD,GAAoB,OAAhBE,EACF,OAAOD,KAAKG,YAAYF,GAE1B,MAAO3W,GACP1E,QAAQC,MACN,8FAEFD,QAAQC,MAAMyE,GAGhB,OAAO0W,KAAKF,e,IAGd,SAAUrB,GACR,IAAM2B,EAAcJ,KAAKK,UAAU5B,GAE/B2B,IADuBJ,KAAKK,UAAUL,KAAKF,eAE7C3W,OAAO+W,aAAajY,WAAW+X,KAAKD,aAEpC5W,OAAO+W,aAAapd,QAAQkd,KAAKD,YAAaK,K,4BAOlD,WAEE,OADAjX,OAAO+W,aAAajY,WAAW+X,KAAKD,aAC7BC,KAAKF,gB,0BAGd,WACE,OAAyD,OAAlD3W,OAAO+W,aAAava,QAAQqa,KAAKD,iB,KAItCO,E,+JACJ,SAAU7B,GACR,OAAOA,I,yBAET,SAAYwB,GACV,OAAOA,M,GALqCN,GAS1CY,E,+JAGJ,SAAU9B,GACR,OAAOzO,KAAKiF,UAAUwJ,K,yBAExB,SAAYwB,GACV,OAAOjQ,KAAKC,MAAMgQ,O,GAP+BN,GAoB/Ca,E,sCACJC,oBAAsB,IAAIH,EAxH1B,yCAFAvS,2C,KA8HA2S,mBAAqB,IAAIJ,EAvHzB,uCAFAvS,0C,KA6HA3D,mBAAqB,IAAIkW,EAtHoB,2BAD7C,oK,KA2HAK,kBAAoB,IAAIJ,EApHxB,sCAsHEd,G,KAEFmB,sBAAwB,IAAIL,EAlH5B,0CAoHEb,G,KAEFmB,yBAA2B,IAAIP,EAjH/B,2CAFA,6EAkIWQ,EAAwB,kBACnC,IAAIN,GAEOxW,EAAiB,WAC5B,IAAM+W,EAAqBD,IAC3B,MAAO,CACLL,oBAAqBM,EAAmBN,oBAAoBhC,MAC5DiC,mBAAoBK,EAAmBL,mBAAmBjC,MAC1DrU,mBAAoB2W,EAAmB3W,mBAAmBqU,MAC1DkC,kBAAmBI,EAAmBJ,kBAAkBlC,MACxDmC,sBAAuBG,EAAmBH,sBAAsBnC,MAChEoC,yBAA0BE,EAAmBF,yBAAyBpC,S,wGC6I9DuC,EA0FPC,E,wCA1FOD,K,wDAAAA,E,UAAAA,E,gBAAAA,E,iBAAAA,M,cA0FPC,K,4DAAAA,E,4DAAAA,E,6DAAAA,M,KCpXL,IAAMC,EAA2B,SAACC,GAChC,OAAOA,EAAoBC,cAAc1O,QAAQ,KAAM,MAkHnD2O,EAAoC,SACxC1C,GAEA,GAAwB,kBAAbA,EAAuB,CAChC,GAAI,CAAC,WAAWnW,SAASmW,EAASyC,eAChC,OAAOE,EAAyBC,IAElC,GAAI,CAAC,QAAS,UAAU/Y,SAASmW,EAASyC,eACxC,OAAOE,EAAyBE,OAGpC,OAAOF,EAAyBG,QAG5BC,EAAgC,SACpC/C,GAEA,MAAO,CACLlf,KAAM4hB,EAAkC1C,KAyBtCgD,EAAoB,SACxBC,EACAC,GAEA,OAAQA,GACN,KAAKP,EAAyBG,OAC5B,MAAO,CACLxB,YAAa2B,GAEjB,KAAKN,EAAyBC,IAC5B,MAAO,CACLO,SAAUC,SAASH,IAEvB,KAAKN,EAAyBE,OAC5B,MAAO,CACLQ,YAAaC,WAAWL,IAE5B,QACE,MAAMne,MAAM,0BAAD,OAA2Boe,MAItCK,EAA6B,iBAC7BC,EAA4B,iBAC5BC,EAA2B,YAC3BC,EAA4B,WAE5BC,EAA4B,SAChCC,GAkBA,MAhB0C,CACxC5e,aAAc,CACZhB,KAAMuf,GAERM,SAAU,CACR7f,KAAM,iBAERgR,OAAQ,CACN8O,WAAW,eACRL,EAA2BG,IAGhCG,eAAgB,CACdC,aAAa,KAMbC,EAAkD,CACtDC,cAAeV,EACfW,iBAAkB,CAChBL,WAAW,eACRL,EAA2B,CAC1B3iB,KAAM6hB,EAAyBG,UAIrCsB,kBAAmB,CACjBC,UAAU,eACPX,EAA4B,CAC3BY,aAAc,CACZC,YAAa,uBAOjBC,EAAgD,CACpDC,UAAW,CACTC,MAAO,SACPC,QAAS,CACP,KACA,MACA,sDAHO,iCAImBlB,EAJnB,yCAKmBC,EALnB,gBAUb,SAASkB,EACPC,EACA3P,GAEA,QAAqB9Q,IAAjBygB,EACF,QAA0BzgB,IAAtB8Q,EAAUE,QACZyP,EAAe3P,EAAUE,YACpB,CACL,IAA2B,IAAvBF,EAAUC,SAQZ,MAAMrQ,MAAM,iDAAD,OACwCoQ,EAAUlR,KADlD,MALXiC,QAAQC,MAAR,iBACYgP,EAAUlR,KADtB,+EAGA6gB,EAAe,GASrB,GAA4B,kBAAjBA,EAST,MARS,CACPC,aAAc,CACZC,cAAe/B,EACb6B,EACAnC,EAAkCxN,EAAUpU,SAK7C,GAAI,eAAgB+jB,EAIzB,MAHS,CACPG,wBAAyBH,EAAaxK,WAAWV,WAG9C,GAAI,eAAgBkL,EAOzB,MANS,CACPI,oBAAqB,CACnBC,aAAcL,EAAahL,WAAW/E,OACtCqQ,mBAAoBN,EAAahL,WAAWC,aAKhD,MAAMhV,MAAM,mCAAD,OAAoC+f,EAApC,MAIf,SAASO,EACPP,EACA3P,EACAmQ,EACAC,GAMA,QAAqBlhB,IAAjBygB,EAEF,QAA0BzgB,IAAtB8Q,EAAUE,QACZyP,EAAe3P,EAAUE,YACpB,CACL,IAA2B,IAAvBF,EAAUC,SAQZ,MAAMrQ,MAAM,iDAAD,OACwCoQ,EAAUlR,KADlD,MALXiC,QAAQC,MAAR,iBACYgP,EAAUlR,KADtB,+EAGA6gB,EAAe,GAQrB,IAAIlU,EACJ,GAA4B,kBAAjBkU,EAgBT,OADAlU,EAJE2U,EAV0D,CAC1DR,aAAc,CACZC,cAAe,CAEbzD,YAAauD,KAQf,iBAIC,GAAI,eAAgBA,EAAc,CAEvC,GAAIQ,EAUF1U,EAJE2U,EAL0D,CAC1DN,wBAAyBH,EAAaxK,WAAWV,WAM/C,qBAAuBkL,EAAaxK,WAAWV,gBAInDhJ,EAAS,CACP4U,uBAAwBV,EAAaxK,WAAWV,WAGpD,OAAOhJ,EACF,GAAI,eAAgBkU,EAOzB,OANAlU,EAAS,CACP6U,mBAAoB,CAClBN,aAAcL,EAAahL,WAAW/E,OACtC2Q,kBAAmBZ,EAAahL,WAAWC,aAK/C,MAAMhV,MAAM,mCAAD,OAAoC+f,EAApC,MAIf,IAAM7F,EAAgB,SAAI5N,GACxB,QAAYhN,IAARgN,EACF,MAAM6N,UAAU,uBAElB,OAAO7N,GAWT,SAASsU,EACPrlB,EACAwa,EACA8K,EACAC,GAIC,IAAD,MACA,IAAKpU,YAA0BnR,EAAciF,gBAC3C,MAAMR,MAAM,4DAGd,IAAM+gB,EAAgBxlB,EAAciF,eAAemf,UAE7CqB,EApYmB,SACzBzlB,EACAwa,EACA8K,GACgC,IAAD,IAC/B,IAAKnU,YAA0BnR,EAAciF,gBAC3C,MAAMR,MAAM,yDAEd,IAAM+gB,EAAgBxlB,EAAciF,eAAemf,UAE7CsB,EAA4B,IAAItd,IAChCud,EAA2B,IAAIvd,IAC/Bwd,EAAa,SAAbA,EAAcC,GAClB,GAAkB,iBAAPA,EACT,MAAO,CAACA,GACH,GAAI,eAAgBA,EAAK,CAC9B,IAAMvM,EAAYuM,EAAIC,WACtB,OAAKR,EAAiChe,IAAIgS,IAUxCoM,EAA0B7b,IAAIyP,GACvB,CAAC,0BAAD,OAA2BA,EAA3B,WAJPqM,EAAyB9b,IAAIyP,GACtB,CAAC,yBAAD,OAA0BA,EAA1B,gBAKJ,GAAI,cAAeuM,EAAK,CAC7B,IAAMvM,EAAYuM,EAAIE,UAEtB,OADAJ,EAAyB9b,IAAIyP,GACtB,CAAC,yBAAD,OAA0BA,EAA1B,cACF,GAAI,eAAgBuM,EAAK,CAC9B,IAAMpM,EAAaoM,EAAIG,WACvB,MAAO,CAAC,0BAAD,OAA2BvM,EAA3B,cACF,GAAI,OAAQoM,EAAK,CACtB,MAAiC,CAACA,EAAII,GAAGC,KAAML,EAAII,GAAGplB,KAAMglB,EAAII,GAAGE,MAA5DC,EAAP,KAAeC,EAAf,KAAuBC,EAAvB,KAEIC,GAAsB,EAC1B,GAAsB,kBAAXH,EACTG,EAA+C,SAAzBH,EAAOhE,mBACxB,GAAsB,mBAAXgE,EAChBG,EAAsBH,OACjB,GAAI,cAAeA,EAExBG,EADkBH,EAAOI,aACUhM,MAC9B,MAAI,eAAgB4L,GAezB,MAAM3hB,MAAM,8BAAgC2hB,GAd5C,IAAM9M,EAAY8M,EAAON,WACzB,GAAMxM,KAAakB,EAEZ,CACL,IAAMgK,EAAehK,EAAclB,GACnC,GAA4B,kBAAjBkL,EAGT,MAAM/f,MACJ,yFAHF8hB,EAAqD,SAA/B/B,EAAapC,mBAJrCmE,GAAsB,EAc1B,IAAME,EAAiBF,EAAsBF,EAASC,EACtD,YAAuBviB,IAAnB0iB,EACK,GAEFA,EAAepN,QAAQuM,GACzB,GAAI,WAAYC,EAErB,MAAO,CADYA,EAAIxQ,OACJgE,QAAQuM,GAAYtiB,KAAK,KAE5C,MAAMmB,MAAM,0CAAD,OAA2CohB,KAIpDa,EACJlB,EAAcmB,KACdzhB,OAAOiT,YACLjT,OAAOkT,QAAQoN,EAAcmB,KAAKzjB,KAAI,YAAmB,IAAD,mBAAhB0jB,EAAgB,KAAXnH,EAAW,KAChDoH,EAAmBjB,EAAWnG,GACpC,GAAgC,IAA5BoH,EAAiBlc,OACnB,MAAMlG,MAAM,sEAAD,OAC6DoiB,IAI1E,MAAO,CAACD,EADcC,EAAiB,QAY7C,MAP2C,CACzCvC,QAAO,UAAEkB,EAAclB,eAAhB,aAAE,EAAuBjL,QAAQuM,GACxC1M,KAAI,UAAEsM,EAActM,YAAhB,aAAE,EAAoBG,QAAQuM,GAClCe,IAAKD,EACLhB,0BAA2BA,EAC3BC,yBAA0BA,GAkSAmB,CAC1B9mB,EACAwa,EACA8K,GAiBIyB,EAAmBxB,EAduB,CAC9CnB,UAAW,CACTC,MAAOmB,EAAcnB,MACrBC,QAASmB,EAAoBnB,QAC7BpL,KAAMuM,EAAoBvM,KAC1ByN,IACElB,EAAoBkB,KACpBzhB,OAAOkT,QAAQqN,EAAoBkB,KAAKzjB,KAAI,yCAAoB,CAC9DS,KAD0C,KAE1C8b,MAF0C,WAON,UAE1Czf,EAAc2D,YAF4B,QAEpB,aAGlBqjB,EAAW,IAAIhiB,KACnB,UAAChF,EAAc2U,cAAf,QAAyB,IAAIzR,KAAI,SAAC2R,GAAD,MAAe,CAACA,EAAUlR,KAAMkR,OAsCnE,MANkD,CAChDiP,iBA9B4D,CAC5DL,WAAYve,OAAOiT,YACjBrV,MAAMC,KAAK0iB,EAAoBC,0BAA0BvgB,UAAUjC,KACjE,SAACoW,GAAD,YAAe,CACbA,EACAoJ,EAA6B,UAACsE,EAASthB,IAAI4T,UAAd,aAAC,EAAyB7Y,WAI7DujB,UAAW9e,OAAOiT,YAChBrV,MAAMC,KAAK0iB,EAAoBE,yBAAyBxgB,UAAUjC,KAChE,SAACoW,GAAD,YAAe,CACbA,GAC4B,UAAC0N,EAASthB,IAAI4T,UAAd,OAAC,EAAyB7Y,KApSvD,CACLwjB,aAVyB,CACzBC,YAAa,2BA8TbH,kBAZ8D,CAC9DN,WAAY,GACZO,UAAW9e,OAAOiT,aAChB,UAACnY,EAAcoV,eAAf,QAA0B,IAAIlS,KAAI,SAAC6U,GAAD,MAAgB,CAChDA,EAAWpU,MACkBoU,EAAWtX,KA/SvC,CACLwjB,aAVyB,CACzBC,YAAa,2BAgUbL,cAAekD,GAKnB,SAASE,EACPjnB,EACAwa,EACA8K,EACAC,EAIA2B,GAIC,IAAD,MACA,IAAK9V,YAAsBpR,EAAciF,gBACvC,MAAMR,MAAM,wDA0Dd,IAvDA,IAAMwT,EAAYjY,EAAciF,eAAeG,MAEzCsgB,EAA4B,IAAItd,IAChCud,EAA2B,IAAIvd,IAEjC+e,EAAuD,GACrDC,EAAqB,IAAIpiB,IAEzBqiB,EAAkB,SACtB3O,GAEI,IADJ4O,EACG,uDADkB,OAEfC,EAAiBvW,KAAKiF,UAAUyC,GAChC8O,EAAaJ,EAAmB1hB,IAAI6hB,GAC1C,QAAmBxjB,IAAfyjB,EACF,OAAOA,EAET,IAAMC,EAAU,IAAIrf,IAAIlD,OAAOmD,KAAK8e,IAC9BxlB,EAAKuF,EAA4BogB,EAAYG,GAGnD,OAFAL,EAAmBzhB,IAAI4hB,EAAgB5lB,GACvCwlB,EAAYxlB,GAAM+W,EACX/W,GAGHsjB,EAAgD,SACpD1B,GAEI,IADJ+D,EACG,uDADkB,gBAGfI,EAAyBnC,EAC7BpB,EACAhB,GAEIwE,EAA6B,2BAC9B/D,GAD8B,IAEjCC,cAAe6D,IAEXE,EAA2BV,EAC/BS,EACAzE,GAEI2E,EAAuBvE,EAC3BC,GAEFsE,EAAqBljB,aAAahB,KAAOikB,EACzC,IAAMnT,EAAS4S,EAAgBQ,EAAsBP,GAC/CQ,EAAoD,CACxD3C,mBAAoB,CAClBN,aAAcpQ,EACd2Q,kBAAmB/B,IAGvB,OAAOyE,GAGT,MAAiC5iB,OAAOkT,QAAQH,EAAU5S,OAA1D,eAAkE,CAA7D,0BAAOoP,EAAP,KAAenP,EAAf,KACH,QAAmCvB,IAA/BuB,EAASX,aAAa5D,KACxB,MAAM0D,MAAM,SAAD,OAAUgQ,EAAV,gDAEb,IAAK,IAAD,EACIsT,EAAiBC,EACrB1iB,EAASX,aAAa5D,KAD8B,UAEpDuE,EAASkM,iBAF2C,QAE9B,GACtB8T,EACAC,EACA2B,EACAjC,GAEF,GAAIxQ,KAAU0S,EACZ,MAAM1iB,MAAM,YAAD,OACGgQ,EADH,4FAIb0S,EAAY1S,GAAUsT,EAEtB,cAAuB7iB,OAAOC,OAAP,oBACrB4iB,EAAepT,cADM,aACrB,EAAuB8O,kBADF,QACgB,IADvC,eAEG,CAAC,IAAD,IAFQlK,EAAQ,UAGwBxV,IAArCwV,EAASoL,yBACXe,EAA0B7b,IAAI0P,EAASoL,yBAG3C,cAAuBzf,OAAOC,OAAP,oBACrB4iB,EAAepT,cADM,aACrB,EAAuBqP,iBADF,QACe,IADtC,eAEG,CAAC,IAAD,IAFQzK,EAAQ,KAGb,2BAA4BA,GAC9BoM,EAAyB9b,IAAI0P,EAAS2L,yBAG1C,MAAO5a,GAIP,MAHIA,aAAe7F,QACjB6F,EAAIjK,QAAU,+BAAwBoU,EAAxB,MAAqCnK,EAAIjK,SAEnDiK,GAKV,IAAM2d,EAAkDnlB,MAAMC,KAC5D2iB,GACA9Q,QAAO,SAACsB,GAAD,OAAOyP,EAAyBre,IAAI4O,MAC7C,GAAI+R,EAAgDtd,OAAS,EAC3D,MAAMlG,MAAM,6CAAD,OACoCzE,EAAc2D,KADlD,mEACiHskB,EADjH,iCAIb,IAAMC,EAAuDplB,MAAMC,KACjEuiB,GACA1Q,QAAO,SAACsB,GAAD,OAAOyP,EAAyBre,IAAI4O,MAC7C,GAAIgS,EAAqDvd,OAAS,EAChE,MAAMlG,MAAM,6CAAD,OACoCzE,EAAc2D,KADlD,iEAC+GukB,EAD/G,iCAKb,IA7NAC,EACAC,EA4NMC,GA7NNF,EA6NoD,UAClDlQ,EAAUiC,oBADwC,QACxB,GA7N5BkO,EA8NE,SAAC/M,GASC,MAR6C,CAC3CiN,kBAAmB,CACjB,CACEC,gBAAiBlN,EAAmB7B,WAAW/E,OAC/C2Q,kBAAmB/J,EAAmB7B,WAAWC,eAjO3DvU,OAAOiT,YACLjT,OAAOkT,QAAQ+P,GAAQjlB,KAAI,mCAAE0jB,EAAF,KAAOnH,EAAP,WAAkB,CAACmH,EAAKwB,EAAU3I,SAwOzDuH,EAAW,IAAIhiB,KACnB,UAAChF,EAAc2U,cAAf,QAAyB,IAAIzR,KAAI,SAAC2R,GAAD,MAAe,CAACA,EAAUlR,KAAMkR,OAuCnE,MAXkD,CAChDiP,iBA1B4D,CAC5DL,WAAYve,OAAOiT,YACjBrV,MAAMC,KAAK2iB,EAA0BvgB,UAAUjC,KAAI,SAACoW,GAAD,YAAe,CAChEA,EACAoJ,EAA6B,UAACsE,EAASthB,IAAI4T,UAAd,aAAC,EAAyB7Y,WAG3DujB,UAAW9e,OAAOiT,YAChBrV,MAAMC,KAAK4iB,EAAyBxgB,UAAUjC,KAAI,SAACoW,GAAD,YAAe,CAC/DA,GAC4B,UAAC0N,EAASthB,IAAI4T,UAAd,OAAC,EAAyB7Y,KA9drD,CACLwjB,aAVyB,CACzBC,YAAa,2BAufbH,kBAZ8D,CAE9DC,UAAW9e,OAAOiT,aAChB,UAACnY,EAAcoV,eAAf,QAA0B,IAAIlS,KAAI,SAAC6U,GAAD,MAAgB,CAChDA,EAAWpU,MACkBoU,EAAWtX,KAxevC,CACLwjB,aAVyB,CACzBC,YAAa,2BAwfbsE,IAAK,CACHnjB,MAAO8hB,EACP/R,QAAS,CACP4O,UAAWqE,KAQnB,SAASI,EACPzoB,EACAwa,EACA8K,EACAC,EAIA2B,GAKA,GAAI/V,YAA0BnR,EAAciF,gBAC1C,OAAOogB,EACLrlB,EACAwa,EACA8K,EACAC,GAEG,GAAInU,YAAsBpR,EAAciF,gBAC7C,OAAOgiB,EACLjnB,EACAwa,EACA8K,EACAC,EACA2B,GAGF,MAAMziB,MAAM,8CAAD,OACqCzE,EAAciF,iBAKlE,IAAM+iB,EAAkC,SACtChoB,EAEAwa,EACAkO,EACAnD,EAIA2B,EAIAjC,GAII,IAAD,gBAIGK,EAAmC,IAAIld,KAC3C,UAACpI,EAAc2U,cAAf,QAAyB,IACtBzR,KAAI,SAAC2R,GAAD,OAAeA,EAAUlR,QAC7BiR,QAAO,SAAC0E,GACP,IAAMkL,EAAehK,EAAclB,GACnC,YAAqBvV,IAAjBygB,IAIwB,kBAAjBA,OAGP,eAAgBA,KAEhBkE,EAAkCphB,IAChCkd,EAAaxK,WAAWV,iBAU9B0N,EAAW,IAAIhiB,KACnB,UAAChF,EAAc2U,cAAf,QAAyB,IAAIzR,KAAI,SAAC2R,GAAD,MAAe,CAACA,EAAUlR,KAAMkR,OAG7D8T,EACJF,EACEzoB,EACAwa,EACA8K,EACAC,EACA2B,GAGE0B,EAAoB1B,EACxByB,EAD4C,UAE5C3oB,EAAc2D,YAF8B,QAEtB,aAGlBklB,EAA+B3jB,OAAOiT,YAC1CjT,OAAOmD,KAAP,oBAAYsgB,EAAoB7E,wBAAhC,aAAY,EAAsCL,kBAAlD,QAAgE,IAAIvgB,KAClE,SAACoW,GAAD,MAAe,CACbA,EACAiL,EACE/J,EAAclB,GACdqF,EAAcqI,EAASthB,IAAI4T,UAM7BwP,EAA8B5jB,OAAOiT,YACzCjT,OAAOmD,KAAP,oBAAYsgB,EAAoB7E,wBAAhC,aAAY,EAAsCE,iBAAlD,QAA+D,IAAI9gB,KACjE,SAACoW,GAAD,MAAe,CACbA,EACAyL,EACEvK,EAAclB,GACdqF,EAAcqI,EAASthB,IAAI4T,IAC3BgM,EAAiChe,IAAIgS,GACrC2L,QAgCR,MA1BgD,CAC9CzB,SAAU,CAER7f,KAAI,UAAE3D,EAAc2D,YAAhB,QAAwB,aAE9BgR,OAAQ,CACN8O,WAAYoF,EACZ7E,UAAW8E,GAGbpF,eAAgB,CACdC,aAAa,GAEfhf,aAAc,CACZhB,KAAMilB,KAeN1hB,EAA8B,SAClCvD,EACAwD,GAIA,IAFA,IAAIC,EAAYzD,EACZ0D,EAAQ,EACLF,EAAcG,IAAIF,IAEvBA,EAAYzD,EAAO,OADnB0D,GAC+BjE,WAEjC,OAAOgE,GAGI2hB,EAAgD,SAC3D/oB,GAEI,IAAD,IADHmiB,EACG,uDADmB,WAElB6G,EAAuD,GACrDC,EAA6B,IAAIjkB,IACnCkkB,EAAyD,GACvDC,EAA+B,IAAInkB,IAEnCugB,EAAsB,SAC1B6D,GAEI,IADJ9B,EACG,uDADkB,WAEfC,EAAiBvW,KAAKiF,UAAUmT,GAChC5B,EAAayB,EAA2BvjB,IAAI6hB,GAClD,QAAmBxjB,IAAfyjB,EACF,OAAOA,EAET,IAAMC,EAAU,IAAIrf,IAAIlD,OAAOmD,KAAK2gB,IAC9BrnB,EAAKuF,EAA4BogB,EAAYG,GAGnD,OAFAwB,EAA2BtjB,IAAI4hB,EAAgB5lB,GAC/CqnB,EAAgBrnB,GAAMynB,EACfznB,GAGHulB,EAAuB,SAC3BmC,GAEI,IADJ/B,EACG,uDADkB,YAEfC,EAAiBvW,KAAKiF,UAAUoT,GAChC7B,EAAa2B,EAA6BzjB,IAAI6hB,GACpD,QAAmBxjB,IAAfyjB,EACF,OAAOA,EAET,IAAMC,EAAU,IAAIrf,IAAIlD,OAAOmD,KAAK6gB,IAC9BvnB,EAAKuF,EAA4BogB,EAAYG,GAGnD,OAFA0B,EAA6BxjB,IAAI4hB,EAAgB5lB,GACjDunB,EAAiBvnB,GAAM0nB,EAChB1nB,GAIH+mB,EAAoC,IAAItgB,KAC5C,UAACpI,EAAc2U,cAAf,QAAyB,IAAIzR,KAAI,SAAC2R,GAAD,OAAeA,EAAUlR,SAGtD2lB,EAAkDpkB,OAAOiT,aAC7D,UAACnY,EAAc2U,cAAf,QAAyB,IAAIzR,KAAI,SAAC2R,GAChC,IAAM0E,EAAyB,CAC7BS,WAAY,CAAEV,UAAWzE,EAAUlR,OAErC,MAAO,CAACkR,EAAUlR,KAAM4V,OAGtBgQ,EAAwBd,EAC5BzoB,EACAspB,EACAZ,EACAnD,EACA2B,GAGIsC,EAA0C,CAC9CC,aAAc,CACZ9lB,KAAMue,EAAyBC,IAEjCuH,WAAY,kBACZC,cAAe,QACfC,eAAgB,CACdC,UAAWb,GAEbc,WAAYZ,EACZa,KAAMR,GAER,OAAOC,GAGIQ,EAA2C,SACtDhqB,EACAiqB,EACAX,GAEI,IAAD,QADHnH,EACG,uDADmB,WAIhB+H,EAAenB,EACnB/oB,EACAmiB,GAEIgI,EAAyB,WAC7B,UAACD,EAAaH,KAAKjG,wBAAnB,QAAuC,IAAIL,kBADd,QAC4B,GAG3D6F,EAAoBA,GAAqB,IAAItkB,IAa7C,IAZA,IAAMolB,GAAyB,UAACpqB,EAAc2U,cAAf,QAAyB,IACrDC,QAAO,SAACC,GAAD,YAAqC9Q,IAAtB8Q,EAAUE,WAChC7R,KAAI,SAAC2R,GAAD,MAAiC,CACpCA,EAAUlR,KACV0P,OAAOwB,EAAUE,aAEfsV,EAAuB,IAAIrlB,IAC/BolB,EAAuB/U,OAAOvS,MAAMC,KAAKumB,EAAkBlR,aAIzDkS,EAAkD,GACtD,MAA2BxnB,MAAMC,KAAKsnB,EAAqBjS,WAA3D,eAAuE,CAAlE,0BAAOwO,EAAP,KAAYnH,EAAZ,KACGmH,KAAOuD,EAMbG,EAA2B1D,GAAOjE,EAChClD,EACA0K,EAA0BvD,GAAKnmB,MAP/BmF,QAAQC,MAAR,0DACqD+gB,EADrD,gDAWJ,IAAM2D,EAAkC,CAGtCC,YAAW,UAAExqB,EAAc2D,YAAhB,QAAwB,WAEnC8mB,cAAe,CACbhH,WAAY6G,EACZL,mBAAoBA,GAEtBC,aAAcA,GAKhB,OAAOK,I,8IC58BHrL,EAAc,SAAC7C,EAAkBQ,GACrCR,EAAMC,aAAa6C,QAAQ,wBAAyBnO,KAAKiF,UAAU4G,IACnER,EAAMC,aAAa6C,QACjB,mBACAnO,KAAKiF,UAAU,CACbiH,QAASb,EAAM+C,YAAYlC,QAC3BC,QAASd,EAAM+C,YAAYjC,WAG/Bd,EAAMC,aAAa+C,cAAgB,QA6GtBzT,IAnGC,SAAC,GAKI,IAAD,IAJlB5L,EAIkB,EAJlBA,cACAC,EAGkB,EAHlBA,iBACAgL,EAEkB,EAFlBA,YAEkB,IADlB/K,oBACkB,MADHC,IACG,EAClB,EAAwDC,oBAAS,GAAjE,mBAAOsqB,EAAP,KAA6BC,EAA7B,KAGIC,EAAsB,kBAAM,MAChC,GAA+B,iBAApB,QAAP,EAAA7b,SAAA,0LAAc8b,UAChB,IACE,IAAM9qB,EAAe+qB,EAAQ,KAAkB/V,QAC/C6V,EAAsB,kBACpB7qB,EAAa,CACXC,cAAeA,EACfC,iBAAkBA,EAClBC,aAAcA,KAElB,MAAOS,IAGX,OACE,wBAAO4K,UAAU,WAAjB,UACE,0BAASO,MAAO,CAAEiG,OAAQ,iBAAkBC,aAAc,MAAO/F,QAAS,OAA1E,UACE,yBAASH,MAAO,CAAEqU,YAAa,MAAOlU,QAAS,MAAO8e,WAAY,QAAlE,gCACA,cAAC,IAAD,CACE/qB,cAAeA,EACfC,iBAAkBA,EAClB+qB,yBAA0B/f,EAAYyW,mBACtCxhB,aAAcA,OAGlB,0BAAS4L,MAAO,CAAEiG,OAAQ,iBAAkBC,aAAc,MAAO/F,QAAS,OAA1E,UACE,yBAASH,MAAO,CAAEqU,YAAa,MAAOlU,QAAS,MAAO8e,WAAY,QAAlE,0BACA,cAAC,IAAD,CACE/qB,cAAeA,EACf6hB,yBAA0B5W,EAAY4W,8BAG1C,gEACA,0BAAS/V,MAAO,CAAEiG,OAAQ,iBAAkBC,aAAc,MAAO/F,QAAS,OAA1E,UACE,kCAAS,+CACT,qBAAKV,UAAU,uDAAuD2T,YAAa,SAAC7C,GAAD,OAAsB6C,EAAY7C,EAAO,CAAE4O,MAAO,CAAEzW,MAAO,YAAcyK,WAAS,EAArK,mBAGA,qBAAK1T,UAAU,wDAAwD2T,YAAa,SAAC7C,GAAD,OAAsB6C,EAAY7C,EAAO,CAAE6O,OAAQ,CAAE1W,MAAO,aAAeyK,WAAS,EAAxK,uBAIF,0BAASzd,MAAI,EAAb,UACE,yBAASsK,MAAO,CAAEiG,OAAQ,iBAAkBC,aAAc,MAAO/F,QAAS,OAA1E,SACE,yDAEF,qBAAKH,MAAO,CAAEqf,YAAa,QAA3B,SACE,cAAC,IAAD,CACEtmB,IAAKoG,EAAYwW,oBACjBvhB,aAAcA,SAIpB,0BAAS4L,MAAO,CAAEiG,OAAQ,iBAAkBC,aAAc,MAAO/F,QAAS,OAA1E,UACE,yBAASH,MAAO,CAAEqU,YAAa,MAAOlU,QAAS,MAAO8e,WAAY,QAAlE,6BACA,cAAC,IAAD,OAEF,0BAASvpB,MAAI,EAACsK,MAAO,CAAEiG,OAAQ,iBAAkBC,aAAc,MAAO/F,QAAS,OAA/E,UACE,yBAASH,MAAO,CAAEqU,YAAa,MAAOlU,QAAS,MAAO8e,WAAY,QAAlE,8BACA,cAAC,IAAD,CACEpJ,kBAAmB1W,EAAY0W,kBAC/BC,sBAAuB3W,EAAY2W,sBACnC1hB,aAAcA,OAIjBwqB,GACC,cAAC,IAAD,CACEU,OAAQV,EACRW,YAAa,WACXV,GAAwB,MAI9B,oCACE,gEACA,wBACEjqB,QAAS,SAACC,GACRgqB,GAAwB,IAF5B,sBAOC3qB,GAAiB,cAAC,IAAD,CAAwBA,cAAeA,IACxDA,GAAiB,cAAC,IAAD,CAAkBA,cAAeA,IACnD,cAAC4qB,EAAD,a,2HC3FKU,EAAwB,SAAC,GAGH,IAFjC3mB,EAEgC,EAFhCA,aAEgC,IADhCzE,oBACgC,MADjBC,IACiB,EAChC,EAAwDC,wBAEtD2D,GAFF,mBAAOwnB,EAAP,KAA6BC,EAA7B,KAWA,OARAtgB,qBAAU,WAGRnF,YAAsBpB,EAAczE,GAAcW,KAChD2qB,KAED,CAAC7mB,EAAczE,SAEW6D,IAAzBwnB,EACK,6CAEA,cAAC,IAAD,CAAoBxM,mBAAoBwM,KAItCE,EAA0B,SAAC,GAQjC,IAPLC,EAOI,EAPJA,OAOI,IANJN,cAMI,aALJlrB,oBAKI,MALWC,IAKX,EACJ,OACE,qCACGurB,EAAOC,SACN7oB,MAAMC,KAAK2oB,EAAOC,SAASzoB,KAAI,SAAC0oB,EAAiBvkB,GAAlB,OAC7B,cAACwkB,EAAD,CAEEH,OAAQE,EACRR,OAAQA,GAAoB,IAAV/jB,EAClBnH,aAAcA,GAHT0rB,EAAgBjoB,SAM1B+nB,EAAO5B,YACNhnB,MAAMC,KAAK2oB,EAAO5B,YAAY5mB,KAAI,SAAC6b,GAAD,OAChC,cAACuM,EAAD,CAME3mB,aAAcoa,EACd7e,aAAcA,GALZ6e,EAAmBpc,QACnBoc,EAAmBla,KACnBka,EAAmBzd,aAUpBuqB,EAAkB,SAAC,GAQzB,IAPLH,EAOI,EAPJA,OAOI,IANJN,cAMI,aALJlrB,oBAKI,MALWC,IAKX,EACJ,OACE,0BAEEqB,KAAM4pB,EACNtf,MAAO,CACLiG,OAAQ,iBACRC,aAAc,MACd/F,QAAS,MACTkf,YAAa,QAPjB,UAUE,yBACErf,MAAO,CACLqU,YAAa,MACblU,QAAS,MAGTgU,aAAc,WAEdD,SAAU,SACVD,WAAY,UAGd7L,MAAOwX,EAAO/nB,KAZhB,SAcE,iCAAS+nB,EAAO/nB,SAElB,cAAC8nB,EAAD,CACEC,OAAQA,EACRN,OAAQA,EACRlrB,aAAcA,MA5BXwrB,EAAO/nB,OAkCLmoB,EAAgC,SAAC,GAMvC,IALLC,EAKI,EALJA,uBAKI,IAJJ7rB,oBAII,MAJWC,IAIX,EACJ,OACE,mCACG2C,MAAMC,KAAKgpB,EAAuBJ,SAASzoB,KAC1C,SAAC0oB,EAAiBvkB,GAAlB,OACE,cAACwkB,EAAD,CAEEH,OAAQE,EACRR,OAAkB,IAAV/jB,EACRnH,aAAcA,GAHT0rB,EAAgBjoB,YAW3BqoB,EAAkC,uCAAG,WAAO3pB,GAAP,eAAArB,EAAA,yDACnCirB,EAAmB/a,YAAuB7O,GAtId,YAuIC4pB,EAFM,sBAGjCxnB,MAAM,6CAAD,OACoCwnB,IAJR,gCAOlCA,GAPkC,2CAAH,sDAUlCC,EAAiC,uCAAG,WACxCrnB,GADwC,6BAAA7D,EAAA,6DAExCd,EAFwC,+BAEPC,IAFO,SAITD,EAC7B2E,EACAmnB,GANsC,cAIlCC,EAJkC,yBAQjCA,GARiC,2CAAH,sDAgDxBE,IAhCoB,SAAC,GAGI,IAFtCtnB,EAEqC,EAFrCA,IAEqC,IADrC3E,oBACqC,MADtBC,IACsB,EACrC,EAA4DC,qBAA5D,mBAAO2rB,EAAP,KAA+BK,EAA/B,KAkBA,OAdAlhB,qBAAU,gBACuBnH,IAA3BgoB,GACF,sBAAC,4BAAA/qB,EAAA,+EAGWkrB,EAAkCrnB,EAAK3E,GAHlD,OAESmsB,EAFT,OAIGD,EAA0BC,GAJ7B,gDAMGzmB,QAAQC,MAAR,MANH,wDAAD,KAUD,CAACkmB,EAAwBlnB,EAAK3E,SAEC6D,IAA3BgoB,EACL,mEAEA,cAACD,EAAD,CACEC,uBAAwBA,EACxB7rB,aAAcA,M,iFChLLosB,IAzBgB,SAAC,GAEI,IADlCtsB,EACiC,EADjCA,cAEMwK,EAAQC,aAAc,SAACC,GAAD,OAAWA,EAAMF,SAC7C,EAAkCpK,oBAAS,GAApCmsB,EAAP,oBAEItoB,EAAgB,GACpB,IACE,IAAMuoB,EAAiB5hB,YAAqB5K,EAAewK,EAAO+hB,GAAuB,GACzFtoB,EAAgBkC,YAAoBqmB,GACpC,MAAMliB,GACNrG,EAAgBoP,OAAO/I,GAGzB,IAAMmiB,EAAoB,IAAIC,KAAK,CAACzoB,GAAgB,CAAExD,KAAM,cACtDksB,EAAe,mBAAGrgB,KAAMwC,IAAI8d,gBAAgBH,GAAoBI,SAAU,iBAA3D,4BAErB,OACE,oCACE,6CAAgBF,KAChB,qBAAK7gB,MAAO,CAACkU,SAAU,QAAvB,SAAiC/b,S,gCCzCvC,mCAqDe6oB,IAjCU,SAAC,GAA4C,IAA3C9sB,EAA0C,EAA1CA,cACnBwK,EAAQC,aAAc,SAACC,GAAD,OAAWA,EAAMF,SAEzCuiB,EAAyB,GAC7B,IAGE/sB,EAAgB4K,YAAqB5K,EAAewK,GAAO,GAAM,GACjE,IAAMgf,EAAqBT,YAA8C/oB,GACzE+sB,EAAyB/b,KAAKiF,UAAUuT,OAAoBzlB,EAAW,GACvE,MAAMuG,GACNyiB,EAAyB1Z,OAAO/I,GAGlC,IAAM0iB,EAA6B,IAAIN,KAAK,CAACK,GAAyB,CAAEtsB,KAAM,qBAExEwsB,EAAgCne,IAAI8d,gBAAgBI,GAE1D,OACE,oCACE,gDACW,mBACP1gB,KAAM2gB,EACNJ,SAAU,4BAFH,0CAOX,qBAAK/gB,MAAO,CAAEkU,SAAU,QAAxB,SAAmC+M,S,gLCnBnCG,EAA4B,kBAkKnBC,IAhKc,WAC3B,MAAwC/sB,mBAAS,IAAjD,mBAAOgtB,EAAP,KAAqBC,EAArB,KACA,EAA4CjtB,mBAC1C,IAAI4E,KADN,mBAAO4D,EAAP,KAAuB0kB,EAAvB,KAGA,EAAsDltB,qBAAtD,mBAAOmtB,EAAP,KAA4BC,EAA5B,KACA,EAAkDptB,qBAAlD,mBAAOqtB,EAAP,KAA0BC,EAA1B,KACA,EACEttB,oBAAS,GADX,mBAAOutB,EAAP,KAAoCC,EAApC,KAGMC,EAAoBC,uBAAY,WACpCnlB,YAA6BukB,GAA2BrsB,KACtDysB,KAED,CAACA,IAEJpiB,oBAAU2iB,EAAmB,CAACA,IAE9B,IAAMrR,EAASsR,uBAAY,SAACC,GAC1BA,EAAcC,SAAQ,SAACC,GACrB,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,QAAU,kBAAMxoB,QAAQ6D,IAAI,6BACnCykB,EAAOG,QAAU,kBAAMzoB,QAAQ6D,IAAI,4BACnCykB,EAAOI,OAAP,sBAAgB,0CAAAttB,EAAA,yDAEI,QADZutB,EAAYL,EAAO5d,cACevM,IAAdwqB,EAFZ,uBAGZ3oB,QAAQC,MAAR,yCAAgD0oB,IAHpC,mDAOuB9lB,YACjCykB,EACAqB,GATU,OAONC,EAPM,OAWN7pB,EAAe6pB,EAAqB7pB,aAC1CiB,QAAQqB,MAAM,+BAAgCtC,GAC9C,QAAC,GAAD,EAACwF,QAAeskB,YAAhB,gBAAuB,QAAS,kCAAmC,CACjEne,OAAQ,cAEV+c,EAAgB,IAChBQ,IAjBY,kDAmBNT,EACW,kBAAR,EAAP,SAAiC,KAAIhqB,WAAaiQ,OAAO,EAAD,IAC1Dga,EAAgB,gDAAD,OACmCD,EADnC,MAGfxnB,QAAQC,MAAM,8CAAd,MACA,QAAC,GAAD,EAACsE,QAAeskB,YAAhB,gBAAuB,QAAS,kCAAmC,CACjEne,OAAQ,WA1BE,0DA8BhB4d,EAAOQ,kBAAkBT,QAE1B,CAACJ,IAEEc,EAAkBb,sBAAW,uCACjC,WAAOjpB,GAAP,2BAAA7D,EAAA,+EAEqCuH,YAC/B2kB,EACAroB,GAJN,OAEU+pB,EAFV,OAMUjqB,EAAeiqB,EAAmBjqB,aACxCiB,QAAQqB,MAAM,oCAAqCtC,GACnD,QAAC,GAAD,EAACwF,QAAeskB,YAAhB,gBACE,QACA,sDAEFpB,EAAgB,IAChBQ,IACAD,GAA+B,GAdnC,kDAgBUR,EACW,kBAAR,EAAP,SAAiC,KAAIhqB,WAAaiQ,OAAO,EAAD,IAC1Dga,EAAgB,wCAAD,OAC2BD,EAD3B,MAGfxnB,QAAQC,MAAM,yCAAd,MACA,QAAC,GAAD,EAACsE,QAAeskB,YAAhB,gBACE,QACA,mDAxBN,0DADiC,sDA6BjC,CAACZ,IAGGgB,EAAuB,uCAAG,sBAAA7tB,EAAA,0DAC1BusB,EAD0B,uBAE5BC,OAAuBzpB,GAFK,SAGtBiF,YACJkkB,EACAK,GAL0B,OAO5BM,IAP4B,2CAAH,qDAW7B,EAAsDiB,YAAY,CAChEtS,SACAuS,OAAQ,UAFFC,EAAR,EAAQA,aAAcC,EAAtB,EAAsBA,cAAeC,EAArC,EAAqCA,aAKrC,OACE,gCACE,wBACExuB,QAAS,SAACC,GAAD,OAAOitB,GAA+B,IAC/C9hB,MAAO,CAAEqjB,aAAc,OAFzB,6BAMA,gDAASH,KAAT,cACE,qCAAWC,MACX,sBACEnjB,MAAO,CACLiG,OAAQ,kBACR9F,QAAS,MACTmjB,UAAW,OAJf,UAOGF,EACG,0BACA9B,GACA,8DACHtqB,MAAMC,KAAK6F,EAAewP,WAAWlV,KAAI,mCAAEuE,EAAF,KAAYO,EAAZ,YACxC,cAAC,IAAD,CAEE+W,mBAAoB/W,EAAUrD,aAC9B0qB,cAAe,SAAC1uB,GACdA,EAAEiR,iBACF8b,EAAqB/sB,EAAE2uB,eACvB9B,EAAuB/lB,KALpBA,aAWb,cAAC,IAAD,CACEjG,UAA8BuC,IAAxBwpB,EACNgC,SAAU9B,EACV+B,QAAS,WACPhC,OAAuBzpB,IAJ3B,SAOE,cAAC,IAAD,CAAU0rB,OAAO,EAAM/uB,QAASmuB,EAAhC,sBAIF,cAACa,EAAD,CACEtE,OAAQuC,EACRgC,SAAU,kBAAM/B,GAA+B,IAC/CgC,aAAc,uDACdC,SAAUlB,QAelB,IAAMe,EAA+B,SAAC,GAKZ,IAJxBtE,EAIuB,EAJvBA,OACAyE,EAGuB,EAHvBA,SACAF,EAEuB,EAFvBA,SACAC,EACuB,EADvBA,aAEME,EAAcC,mBACpB,OACE,eAAC,IAAD,CAAQvuB,KAAM4pB,EAAQ4E,WAAS,EAA/B,UACE,cAAC,IAAD,UAAc,qBACd,uBACEre,SAAU,SAAChR,GACLmvB,EAAYG,SACdJ,EAASC,EAAYG,QAAQxQ,OAE/B9e,EAAEiR,kBALN,UAQE,cAAC,IAAD,UACE,cAAC,IAAD,CACEjQ,GAAG,OACHlB,KAAK,OACLif,YAAakQ,EACbpb,MAAM,gBACN0b,SAAUJ,EACVzP,UAAQ,EACRxe,WAAS,EACTmuB,WAAS,MAGb,eAAC,IAAD,WACE,cAAC,IAAD,CAAQtvB,QAASivB,EAAjB,oBACA,cAAC,IAAD,CAAQ/tB,MAAM,UAAUnB,KAAK,SAASoB,WAAS,EAA/C,+B,iHCtFKsuB,IA1HW,SAAC,GAAqD,IAAnD/E,EAAkD,EAAlDA,OAAQC,EAA0C,EAA1CA,YAC7BpgB,EAAc6W,cAEpB,EAAsD1hB,mBACpD6K,EAAYwW,oBAAoBhC,OADlC,mBAAOgC,EAAP,KAA4B2O,EAA5B,KAGA,EAAoDhwB,mBAClD6K,EAAYyW,mBAAmBjC,OADjC,mBAAOiC,EAAP,KAA2B2O,EAA3B,KAGA,EAAoDjwB,mBAClD6K,EAAYG,mBAAmBqU,OADjC,mBAAOrU,EAAP,KAA2BklB,EAA3B,KAGA,EAAkDlwB,mBAChD6K,EAAY0W,kBAAkBlC,OADhC,mBAAOkC,EAAP,KAA0B4O,EAA1B,KAGA,EAA0DnwB,mBACxD6K,EAAY2W,sBAAsBnC,OADpC,mBAAOmC,EAAP,KAA8B4O,EAA9B,KAGA,EAAgEpwB,mBAC9D6K,EAAY4W,yBAAyBpC,OADvC,mBAAOoC,EAAP,KAAiC4O,EAAjC,KA2BA,OACE,eAAC,IAAD,CAAQjvB,KAAM4pB,EAAQoE,QAASnE,EAA/B,UACE,cAAC,IAAD,uBACA,eAAC,IAAD,WAEE,cAAC,IAAD,CACE1pB,GAAG,wBACH6S,MAAM,wBACNkc,QAAQ,WACRhkB,OAAO,SACPsjB,WAAS,EACTvQ,MAAOgC,EACPlB,SAAU,SAAC5f,GAAD,OAAOyvB,EAAuBzvB,EAAE6L,OAAOiT,UAEnD,cAAC,IAAD,CACE9d,GAAG,uBACH6S,MAAM,uBACNkc,QAAQ,WACRhkB,OAAO,SACPsjB,WAAS,EACTvQ,MAAOiC,EACPnB,SAAU,SAAC5f,GAAD,OAAO0vB,EAAsB1vB,EAAE6L,OAAOiT,UAElD,cAAC,IAAD,CACE9d,GAAG,uBACH6S,MAAM,uBACNkc,QAAQ,WACRhkB,OAAO,SACPsjB,WAAS,EACTvQ,MAAOrU,EACPmV,SAAU,SAAC5f,GAAD,OAAO2vB,EAAsB3vB,EAAE6L,OAAOiT,UAElD,cAAC,IAAD,CACE9d,GAAG,6BACH6S,MAAM,6BACNkc,QAAQ,WACRhkB,OAAO,SACPsjB,WAAS,EACTW,WAAS,EACTlR,MAAOkC,EAAkBre,KAAK,MAC9Bid,SAAU,SAAC5f,GAAD,OAAO4vB,EAAqB5vB,EAAE6L,OAAOiT,MAAMmR,MAAM,UAE7D,cAAC,IAAD,CACEjvB,GAAG,oCACH6S,MAAM,sCACNkc,QAAQ,WACRhkB,OAAO,SACPsjB,WAAS,EACTW,WAAS,EACTlR,MAAOmC,EAAsBte,KAAK,MAClCid,SAAU,SAAC5f,GAAD,OAAO6vB,EAAyB7vB,EAAE6L,OAAOiT,MAAMmR,MAAM,UAEjE,cAAC,IAAD,CACEjvB,GAAG,yBACH6S,MAAM,+BACNkc,QAAQ,WACRhkB,OAAO,SACPsjB,WAAS,EACTvQ,MAAOoC,EACPtB,SAAU,SAAC5f,GAAD,OAAO8vB,EAA4B9vB,EAAE6L,OAAOiT,aAG1D,eAAC,IAAD,WACE,cAAC,IAAD,CAAQ/e,QAAS2qB,EAAazpB,MAAM,UAApC,oBAGA,cAAC,IAAD,CAAQlB,QAzFK,WACjBuK,EAAYwW,oBAAoBhC,MAAQgC,EACxCxW,EAAYyW,mBAAmBjC,MAAQiC,EACvCzW,EAAYG,mBAAmBqU,MAAQrU,EACvCH,EAAY0W,kBAAkBlC,MAAQkC,EACtC1W,EAAY2W,sBAAsBnC,MAAQmC,EAC1C3W,EAAY4W,yBAAyBpC,MAAQoC,EAC7CwJ,KAkFiCzpB,MAAM,UAAnC,kBAGA,cAAC,IAAD,CAAQlB,QAlFM,WAClB0vB,EAAuBnlB,EAAYwW,oBAAoBoP,kBACvDR,EAAsBplB,EAAYyW,mBAAmBmP,kBACrDP,EAAsBrlB,EAAYG,mBAAmBylB,kBACrDN,EAAqBtlB,EAAY0W,kBAAkBkP,kBACnDL,EACEvlB,EAAY2W,sBAAsBiP,kBAEpCJ,EACExlB,EAAY4W,yBAAyBgP,mBAyELjvB,MAAM,YAApC,2B,gGC1HFkvB,EAAyC,0CACzCC,EAA+B,iCAC/BC,EAA2B,8BAC3BC,EAAgC,kCAEhCC,EAA8B,CAClC,cACA,WACA,WACA,eACA,eACA,eACA,aACA,kBACA,2BAKIC,EAA0B,uCAAG,WACjCC,EACAC,GAFiC,2BAAArwB,EAAA,6DAGjCswB,EAHiC,kDAK1B,IAAIC,SACT,SAACC,EAASC,GACRC,KAAKC,KAAKC,UACR,CACEC,UAAWT,EACXU,MAAOT,EACPC,UAAWA,IAEb,SAACS,GAEC,QAAmBhuB,IAAfguB,EACFnsB,QAAQC,MAAM,qCACd4rB,EAAO,gDACF,GAAIM,EAAWlsB,MACpBD,QAAQC,MACN,oCACAksB,EAAWlsB,OAEb4rB,EAAOM,EAAWlsB,WACb,CAIL,IAAMmsB,EAAwBD,EAAmBD,MAC3CG,EAAc,OAAGD,QAAH,IAAGA,OAAH,EAAGA,EAAsBpB,MAAM,KACnD,QAAuB7sB,IAAnBkuB,GAAiCZ,EAAOa,OAAM,SAACJ,GAAD,OAAWG,EAAezoB,SAASsoB,MAKnFN,EAAQO,OALoF,CAC5F,IAAM3E,EAAY,oEAAgE4E,GAClFpsB,QAAQC,MAAMunB,GACdqE,EAAOrE,YAjCc,2CAAH,wDA4CnB+E,EAAiC,uCAAG,WAC/CtQ,EACAwP,GAF+C,6BAAArwB,EAAA,+EAMpBmwB,EACvBtP,EACAwP,GACA,GAT2C,cAMvCe,EANuC,OAY7C,QAAC,GAAD,EAACjoB,QAAeskB,YAAhB,gBAAuB,QAAS,mBAAoB,CAClDne,OAAQ,YACRghB,UAAW,SAdgC,kBAgBtCc,GAhBsC,2DAoBlBjB,EACvBtP,EACAwP,GACA,GAvByC,eAoBrCe,EApBqC,OAyB3C,QAAC,GAAD,EAACjoB,QAAeskB,YAAhB,gBAAuB,QAAS,mBAAoB,CAClDne,OAAQ,YACRghB,UAAW,UA3B8B,kBA6BpCc,GA7BoC,mCAgC3C,QAAC,GAAD,EAACjoB,QAAeskB,YAAhB,gBAAuB,QAAS,mBAAoB,CAClDne,OAAQ,SACRghB,UAAW,UAlC8B,iEAAH,wDAwCxCe,EAAgC,uCAAG,WACvCxQ,GADuC,eAAA7gB,EAAA,sEAGjCmxB,EACJtQ,EACA,CAAC,mDALoC,uBAOhB6P,KAAKY,OAAOC,QAAQ,CACzCC,KAAM,6DAR+B,cAOjCnxB,EAPiC,yBAUhCA,EAASiP,QAVuB,2CAAH,sDAahCmiB,EAA2B,uCAAG,WAClCC,GADkC,uCAAA1xB,EAAA,6DAElC2xB,EAFkC,+BAEzB,cACTpI,EAHkC,uBAIlC1I,EAJkC,uBAKlC+Q,EALkC,gCAO5BT,EACJtQ,EACA,CAAC,mDAT+B,uBAWX6P,KAAKY,OAAOC,QAAQ,CACzCC,KAAK,WAAD,OAAaG,EAAb,uDAAkED,EAAlE,sBAAyFC,EAAzF,uCAA8HC,GAClIC,OAAQ,OACRC,KAAM9hB,KAAKiF,UAAUsU,KAdW,cAW5BlpB,EAX4B,OAgBlC,QAAC,GAAD,EAAC8I,QAAeskB,YAAhB,gBAAuB,QAAS,kCAAmC,CACjEne,OAAQ,cAjBwB,kBAmB3BjP,EAASiP,QAnBkB,4CAAH,sDAsQlByiB,EA1Oc,SAAC,GAII,IAHhC/yB,EAG+B,EAH/BA,cACAspB,EAE+B,EAF/BA,kBACAzH,EAC+B,EAD/BA,yBAEA,EAAgCzhB,oBAC9B,0BAAM4Q,KAAKC,MAAL,oBAAW9G,OAAO+W,oBAAlB,aAAW,EAAqBva,QAAQsqB,UAAxC,QAA0E,SADlF,mBAAO+B,EAAP,KAAiBC,EAAjB,KAGA,EAA8B7yB,oBAC5B,8CAAM+J,OAAO+W,oBAAb,aAAM,EAAqBva,QAAQoqB,UAAnC,QAAoE,MADtE,mBAAO3T,EAAP,KAAgB8V,EAAhB,KAGA,EAA4B9yB,oBAC1B,8CAAM+J,OAAO+W,oBAAb,aAAM,EAAqBva,QAAQqqB,UAAnC,QA3IuC,iBA0IzC,mBAAO2B,EAAP,KAAeQ,EAAf,KAGA,EAA0B/yB,mBAAS,IAAnC,mBAAOyF,EAAP,KAAcutB,EAAd,KACA,EAAoDhzB,oBAClD,8CAAM+J,OAAO+W,oBAAb,aAAM,EAAqBva,QAAQmqB,UAAnC,QAA8E,MADhF,mBAAO7G,EAAP,KAA2BoJ,EAA3B,KAGA,EAAkDjzB,wBAEhD2D,GAFF,mBAAOuvB,EAAP,KAA0BC,EAA1B,KAGA,EAAgDnzB,wBAC9C2D,GADF,mBAAOyvB,EAAP,KAAyBC,EAAzB,KAGA,EAAkDrzB,wBAEhD2D,GAFF,mBAAO2vB,EAAP,KAA0BC,EAA1B,KAGA,EAAkEvzB,wBAEhE2D,GAFF,mBAAO6vB,EAAP,KAAkCC,EAAlC,KAIA3oB,qBAAU,WACR,QAAsBnH,IAAlB/D,EACF,IACE,IAAM0zB,EAAoB1J,YACxBhqB,EACAiqB,EACAX,GAEFmK,OAAoB1vB,GACpB2vB,EAAkBI,OAAS,CACzBC,IAAK,yBACL,iCAAkC,SAEpCJ,EAAqBD,GACrB,IAAMM,EAAwBhjB,KAAKiF,UACjCyd,OACA3vB,EACA,GAEI6vB,EAA4B9kB,IAAI8d,gBACpC,IAAIF,KAAK,CAACsH,GAAwB,CAAEvzB,KAAM,sBAE5CozB,EAA6BD,GAC7B,MAAOtpB,GACP,IAAM8iB,EACW,kBAAR9iB,GAAoBA,aAAe7F,MACtC6F,EAAIlH,WACJiQ,OAAO/I,GACbmpB,EAAoBrG,GACpBuG,OAAqB5vB,GACrB8vB,OAA6B9vB,MAGhC,CAAC/D,EAAespB,EAAmBW,IAEtC,IAAMgK,EACQ,KAAZ7W,GAA6B,KAAXuV,QAAuC5uB,IAAtB2vB,EAErC,OACE,uBACE/hB,SAAQ,uCAAE,WAAOhR,GAAP,2CAAAK,EAAA,yDACRL,EAAEiR,sBACwB7N,IAAtB2vB,EAFI,iDAKRH,OAAqBxvB,GALb,SAQN,IACE,UAAAoG,OAAO+W,oBAAP,SAAqBpd,QAAQgtB,EAAwC7G,GACrE,UAAA9f,OAAO+W,oBAAP,SAAqBpd,QAAQitB,EAA8B3T,GAC3D,UAAAjT,OAAO+W,oBAAP,SAAqBpd,QAAQktB,EAA0B2B,GACvD,MAAMroB,GACN1E,QAAQC,MAAM,qEAAsEyE,GAbhF,OAeAkgB,IACJ,iBAACxqB,QAAD,IAACA,OAAD,EAACA,EAAe2D,YAAhB,QAAwB,YACxB,KACA,IAAIoE,MAAOmsB,cAAcxgB,QAAQ,IAAK,KAAKA,QAAQ,IAAK,KACxDygB,UAAU,EAAG,KACTC,EAAuB5J,EAC1BpI,cACA1O,QAAQ,cAAe,KACvBA,QAAQ,MAAO,IAClBggB,EAAkBlJ,YAAcA,EAxB1B,UAyBeiI,EACnBrV,EACAuV,EACAe,EACA7R,EACAuS,GA9BI,QAyBA9jB,EAzBA,OAgCA+jB,EAA0B/jB,EAAO3M,KACjCivB,EAAgByB,EAAgBzD,MAAM,KAAK0D,OAAO,GAAG,GACrDhB,EAlCA,+DAkC4EX,EAlC5E,2BAkCqGC,EAlCrG,oBAkC8HxV,GACpImW,EAAqBD,GACrBF,EAAS,IApCH,kDAsCNxtB,QAAQC,MAAR,MACAutB,EAAQ,gDAAC,KAAK9iB,cAAN,iBAAC,EAAazK,aAAd,aAAC,EAAoBxF,eAArB,QAAgC,SACxC,QAAC,GAAD,EAAC8J,QAAeskB,YAAhB,gBAAuB,QAAS,kCAAmC,CACjEne,OAAQ,WAzCJ,0DAAF,sDADV,UA+CE,sBAAKxE,MAAO,CACViU,WAAY,SACZrT,OAAQ,OAFV,UAIE,uBAAO6nB,QAAQ,UAAf,uBACA,uBACE5yB,GAAG,UACH0e,UAAQ,EACR5f,KAAK,OACL+zB,KAAK,WACL9U,YAAY,kBACZD,MAAOrC,EACPmD,SAAU,SAAC5f,GAAD,OAAOuyB,EAAWvyB,EAAE6L,OAAOiT,UAEvC,0BAAU9d,GAAG,WAAb,SACGqxB,EAAS9vB,KAAI,SAACwvB,GAAD,OACZ,wBAAwBjT,MAAOiT,GAAlBA,QAGjB,wBACEjyB,KAAK,SACLC,QAAO,uCAAE,WAAOC,GAAP,iCAAAK,EAAA,+EAEgBqxB,EACnBxQ,GAHG,OAECvR,EAFD,OAKCmkB,EAAcnkB,EAAO0iB,SAAmB9vB,KAC5C,SAACwxB,GAAD,OAAiBA,EAAYhC,aAE/BO,EAAYwB,GACZrB,EAAS,IACT,IACE,UAAAjpB,OAAO+W,oBAAP,SAAqBpd,QAAQmtB,EAA+BjgB,KAAKiF,UAAUwe,IAC3E,MAAMnqB,GACN1E,QAAQC,MAAM,qEAAsEyE,GAEtF,QAAC,GAAD,EAACH,QAAeskB,YAAhB,gBAAuB,QAAS,4BAA6B,CAAEne,OAAQ,cAflE,kDAiBL1K,QAAQC,MAAR,MACAutB,EAAQ,gDAAC,KAAK9iB,cAAN,iBAAC,EAAazK,aAAd,aAAC,EAAoBxF,eAArB,QAAgC,SACxC,QAAC,GAAD,EAAC8J,QAAeskB,YAAhB,gBAAuB,QAAS,4BAA6B,CAAEne,OAAQ,WAnBlE,0DAAF,sDAFT,uBA4BF,sBAAKxE,MAAO,CACViU,WAAY,SACZrT,OAAQ,OAFV,UAIE,uBAAO6nB,QAAQ,SAAf,sBACA,uBACE5yB,GAAG,SACH0e,UAAQ,EACR5f,KAAK,OACL+zB,KAAK,UACL/U,MAAOkT,EACPpS,SAAU,SAAC5f,GAAD,OAAOwyB,EAAUxyB,EAAE6L,OAAOiT,UAEtC,0BAAU9d,GAAG,UAAb,SACGuvB,EAA4BhuB,KAAI,SAACyvB,GAAD,OAC/B,wBAAqBlT,MAAOkT,GAAfA,WAInB,sBAAK7mB,MAAO,CACViU,WAAY,SACZrT,OAAQ,OAFV,UAIE,uBAAO6nB,QAAQ,SAAf,uBACA,uBACE5yB,GAAG,qBACH0e,UAAQ,EACR5f,KAAK,OACLgf,MAAOwK,EACP1J,SAAU,SAAC5f,GAAD,OAAO0yB,EAAsB1yB,EAAE6L,OAAOiT,aAGpD,sBAAK3T,MAAO,CACViU,WAAY,SACZrT,OAAQ,OAFV,UAIE,uBACEjM,KAAK,SACL+f,UAAWyT,EACXxU,MAAM,wBAEP6T,GAAqB,mBAAGhnB,KAAMgnB,EAAmB9mB,OAAO,SAASC,IAAI,aAAaX,MAAO,CAAEY,OAAQ,OAA9E,yBAEO3I,IAA9B6vB,GACC,sBACE9nB,MAAO,CACLY,OAAQ,OAFZ,4BAKkB,IAChB,mBAAGJ,KAAMsnB,EAA2B/G,SAAU,2BAA9C,+BAEK,IARP,mBASmB,IACjB,mBAAGvgB,KAAK,uDAAR,8BAEK,IAZP,MAaM,IACJ,mBAAGA,KAAK,yEAAR,8BAdF,OAoBDknB,GAAoB,8BAAMA,IAC1B3tB,GAAS,0CAAaA,S,+BCtUvB8uB,EAAe,OAEfC,EAAkC,SAACjxB,GACvC,OAAOA,EAAKkxB,WAAW,kBAAmB,MAGtCC,EAAa,SAACnxB,GAClB,IAAMoxB,EAAapxB,EAAKkxB,WAAW,iBAAkB,KAKrD,OAHwB,IAAtBE,EAAWpqB,QAAgBoqB,EAAW,GAAG/nB,MAAM,iBAC3C,KAAO+nB,EACPA,GA6FFC,EAA6B,gCAC7BC,EAA4B,WAC5BC,EAA6B,YAE7BC,EAA6B,SACjCC,GACkB,IAAD,IACX3gB,EAAM,UAAG2gB,EAAiBryB,YAApB,iBAAG,EAAuBiK,MAAM,2BAAhC,aAAG,EAAmD,GAYlE,MAX+B,CAC7BrJ,KAAM,oBACN0xB,SAAUL,EACVxjB,UAAW,CACTwS,UAAW,4BAEJoR,GAFI,IAEczxB,KAAMsxB,MAGjCK,kBAAyBvxB,IAAX0Q,OAAuB1Q,EAAY,CAAC0Q,KAKhD8gB,EAAuC,CAC3C5xB,KAAMqxB,EACNrgB,OAAQ,CACNqP,UAAW,CACT,CACErgB,KAAMsxB,EACNzC,KACEgD,+BAQRpgB,QAAS,CACPqO,WAAY,CACV,CACE9f,KAAMuxB,EACNO,UAAW,CACTjD,KACEgD,iCASVpR,UAAW,CACTzgB,KAAM,OACN0gB,MAAO,SACPC,QAAS,CACP,KACA,MACA,2CAHO,6BAIe2Q,EAJf,0CAKiBC,EALjB,cA6Ib,SAASQ,EACP11B,EACAwa,GACC,IAAD,EACA,IAAKrJ,YAA0BnR,EAAciF,gBAC3C,MAAMR,MAAM,4DAGd,IAAM+gB,EAAgBxlB,EAAciF,eAAemf,UAE7CqB,EAhSmB,SACzBzlB,EACAwa,GACgC,IAAD,IAC/B,IAAKrJ,YAA0BnR,EAAciF,gBAC3C,MAAMR,MAAM,yDAEd,IAAM+gB,EAAgBxlB,EAAciF,eAAemf,UAE7CsB,EAA4B,IAAItd,IAChCud,EAA2B,IAAIvd,IAC/Bwd,EAAa,SAAbA,EAAcC,GAClB,GAAkB,iBAAPA,EACT,MAAO,CAACA,GACH,GAAI,eAAgBA,EAAK,CAC9B,IAAMvM,EAAYuM,EAAIC,WAEhB6P,EAAgBf,EAAgCtb,GAGtD,OADAoM,EAA0B7b,IAAIyP,GACvB,CAAC,uBAAD,OAAwBqc,EAAxB,OACF,GAAI,cAAe9P,EAAK,CAC7B,IAAMvM,EAAYuM,EAAIE,UAEhB4P,EAAgBf,EAAgCtb,GAEtD,OADAqM,EAAyB9b,IAAIyP,GACtB,CAAC,sBAAD,OAAuBqc,EAAvB,YACF,GAAI,eAAgB9P,EAAK,CAC9B,IAAMpM,EAAaoM,EAAIG,WAEjB4P,EAAiBhB,EAAgCnb,GACvD,MAAO,CAAC,uBAAD,OAAwBmc,EAAxB,YACF,GAAI,OAAQ/P,EAAK,CACtB,MAAiC,CAACA,EAAII,GAAGC,KAAML,EAAII,GAAGplB,KAAMglB,EAAII,GAAGE,MAA5DC,EAAP,KAAeC,EAAf,KAAuBC,EAAvB,KAEIC,GAAsB,EAC1B,GAAsB,kBAAXH,EACTG,EAA+C,SAAzBH,EAAOhE,mBACxB,GAAsB,mBAAXgE,EAChBG,EAAsBH,OACjB,GAAI,cAAeA,EAExBG,EADkBH,EAAOI,aACUhM,MAC9B,MAAI,eAAgB4L,GAezB,MAAM3hB,MAAM,8BAAgC2hB,GAd5C,IAAM9M,EAAY8M,EAAON,WACzB,GAAMxM,KAAakB,EAEZ,CACL,IAAMgK,EAAehK,EAAclB,GACnC,GAA4B,kBAAjBkL,EAGT,MAAM/f,MACJ,yFAHF8hB,EAAqD,SAA/B/B,EAAapC,mBAJrCmE,GAAsB,EAc1B,IAAME,EAAiBF,EAAsBF,EAASC,EACtD,YAAuBviB,IAAnB0iB,EACK,GAEFA,EAAepN,QAAQuM,GACzB,GAAI,WAAYC,EAErB,MAAO,CADYA,EAAIxQ,OACJgE,QAAQuM,GAAYtiB,KAAK,KAE5C,MAAMmB,MAAM,0CAAD,OAA2CohB,KAU1D,MANe,CACbvB,QAAO,UAAEkB,EAAclB,eAAhB,aAAE,EAAuBjL,QAAQuM,GACxC1M,KAAI,UAAEsM,EAActM,YAAhB,aAAE,EAAoBG,QAAQuM,GAClCF,0BAA2BA,EAC3BC,yBAA0BA,GAmNAmB,CAAmB9mB,EAAewa,GAgE9D,MAZoC,CAClC7W,KAAM,oBACNgR,OApDsC,CACtC8O,WAAY3gB,MAAMC,KAChB0iB,EAAoBC,0BAA0BvgB,UAC9CjC,KACA,SAACoW,GAAD,MAAgC,CAE9B3V,KAAMixB,EAAgCtb,OAO1C0K,UAAWlhB,MAAMC,KACf0iB,EAAoBE,yBAAyBxgB,UAC7CjC,KACA,SAACoW,GAAD,MAA+B,CAE7B3V,KAAMixB,EAAgCtb,GAEtCkZ,KACEgD,eAEAlc,EAAUub,WAAW,SAAU,KAC/B,IACAF,OA4BNvf,QArBwC,CACxCqO,WAAY,GACZO,WAAW,UAAChkB,EAAcoV,eAAf,QAA0B,IAAIlS,KACvC,SAAC6U,GAAD,MAAgC,CAE9BpU,KAAMixB,EAAgC7c,EAAWpU,MAGjD6uB,KACEqD,gBAEA9d,EAAWpU,KAAKkxB,WAAW,SAAU,KACrC,IACAF,OASNvQ,UAAW,CACTzgB,KAAM,OACN0gB,MAAOmB,EAAcnB,MACrBC,QAASmB,EAAoBnB,QAC7BpL,KAAMuM,EAAoBvM,OAwLhC,SAAS4c,EACP91B,EACAwa,EACA8K,EACAyQ,GAEA,GAAI5kB,YAA0BnR,EAAciF,gBAC1C,OAAOywB,EACL11B,EACAwa,GAEG,GAAIpJ,YAAsBpR,EAAciF,gBAC7C,OA7LJ,SACEjF,EACAslB,EACAyQ,GACC,IAAD,EACA,IAAK3kB,YAAsBpR,EAAciF,gBACvC,MAAMR,MAAM,wDAgDd,IA7CA,IAAMwT,EAAYjY,EAAciF,eAAeG,MAE3C4wB,EAA0C,GACxC5O,EAAqB,IAAIpiB,IAKzBqiB,EAAkB,SAAC3O,GAAqD,IAAjC4O,EAAgC,uDAAX,OAG1D2O,EAA6B,2BAAQvd,GAAR,IAAc/U,KAAM,KACjD4jB,EAAiBvW,KAAKiF,UAAUggB,GAChCzO,EAAaJ,EAAmB1hB,IAAI6hB,GAC1C,QAAmBxjB,IAAfyjB,EACF,OAAOA,EAET,IAAMC,EAAU,IAAIrf,IAAIlD,OAAOmD,KAAK2tB,IAC9Br0B,EAAKuF,EAA4BogB,EAAYG,EAASqN,GAK5D,OAJA1N,EAAmBzhB,IAAI4hB,EAAgB5lB,GACvCq0B,EAAUr0B,GAAM+W,EAEhBA,EAAK/U,KAAOhC,EACLA,GAGHu0B,EAA8C,SAClDd,GAEI,IADJ9N,EACG,uDADkB,gBAGf6O,EAAyBJ,EAC7BR,EACAP,GAEInN,EAAuBsN,EAA2BC,GACxDvN,EAAqBwN,SAAWc,EAChC,IAAM1hB,EAAS4S,EAAgBQ,EAAsBP,GAKrD,MAJ0C,CACxC3jB,KAAM,oBACN8b,MAAM,WAAD,OAAahL,EAAb,+BAA0CygB,EAA1C,QAKT,MAAiChwB,OAAOkT,QAAQH,EAAU5S,OAA1D,eAAkE,CAA7D,0BAAOoP,EAAP,KAAenP,EAAf,KACH,QAAmCvB,IAA/BuB,EAASX,aAAa5D,KACxB,MAAM0D,MAAM,SAAD,OAAUgQ,EAAV,gDAEb,IAAK,IAAD,EACI2hB,EAAWC,EACf/wB,EAASX,aAAa5D,KADqB,UAE3CuE,EAASkM,iBAFkC,QAErB,GACtB8T,EACAyQ,EACAG,GAEF,GAAIzhB,KAAUuhB,EACZ,MAAMvxB,MAAM,YAAD,OACGgQ,EADH,4FAOb,IAAM6hB,EAAaxB,EAAWrgB,GAC9B2hB,EAASzyB,KAAO2yB,EAChBN,EAAUM,GAAcF,EACxB,MAAO9rB,GAIP,MAHIA,aAAe7F,QACjB6F,EAAIjK,QAAU,+BAAwBoU,EAAxB,MAAqCnK,EAAIjK,SAEnDiK,GAOV,IAFA,IAAMisB,EAAgC,IAAInuB,IACpCouB,EAA+B,IAAIpuB,IACzC,MAAuBlD,OAAOC,OAAO6wB,GAArC,eAAiD,CAC/C,IADG,IAAMI,EAAQ,KACjB,MAAuBlxB,OAAOC,OAAP,oBACrBixB,EAAS5kB,iBADY,aACrB,EAAoBiS,kBADC,QACa,IADpC,eAEG,CAAC,IAAD,QACKkS,EAAa,UAHF,KAGclW,aAAZ,iBAAG,EAAgBzS,MACpC,4CADiB,aAAG,EAElB,QACkBjJ,IAAlB4xB,GAEFY,EAA8B1sB,IAAI8rB,GAGtC,cAAuBzwB,OAAOC,OAAP,oBAAcixB,EAAS5kB,iBAAvB,aAAc,EAAoBwS,iBAAlC,QAA+C,IAAtE,eAA2E,CAAC,IAAD,QACnE2R,EAAa,UADF,KACc5yB,YAAZ,iBAAG,EAAeiK,MACnC,2CADiB,aAAG,EAElB,QACkBjJ,IAAlB4xB,GACFa,EAA6B3sB,IAAI8rB,IA2BvC,IAAMc,EAA2BvxB,OAAOkT,QAAP,UAC/BH,EAAUiC,oBADqB,QACL,IAC1BhX,KAAI,YAAuC,IAAD,mBAApCuW,EAAoC,KAAxB4B,EAAwB,KACpCqb,EAAiB9B,EAAgCnb,GACjDkd,EAA6B/B,EACjCvZ,EAAmB7B,WAAWC,YAG1Bmd,EAAqB9B,EAAWzZ,EAAmB7B,WAAW/E,QAKpE,MAJ8B,CAC5B9Q,KAAM+yB,EACN3zB,KAAK,WAAD,OAAa6zB,EAAb,8BAAqDD,EAArD,UA+BR,MAV2C,CACzChzB,KAAM,oBACNgR,OAlBsC,CACtC8O,WAAY3gB,MAAMC,KAAKwzB,EAA8BpxB,UAAUjC,KAC7D,SAACyyB,GAAD,MAAoC,CAClChyB,KAAMgyB,MAGV3R,UAAWlhB,MAAMC,KAAKyzB,EAA6BrxB,UAAUjC,KAC3D,SAACyyB,GAAD,MAAmC,CAAEhyB,KAAMgyB,OAY7CvgB,QARwC,CAExC4O,UAAWyS,GAQXjO,IAAK,CAEHnjB,MAAOH,OAAOC,OAAO6wB,KAkBhBa,CACL72B,EACAslB,EACAyQ,GAGF,MAAMtxB,MAAM,8CAAD,OACqCzE,EAAciF,iBAKlE,IAAMoxB,EAA+B,SACnCr2B,EAEAwa,EACAkO,EACAqN,EACAG,GAII,IAAD,cAKG5Q,EAAmC,IAAIld,KAC3C,UAACpI,EAAc2U,cAAf,QAAyB,IACtBzR,KAAI,SAAC2R,GAAD,OAAeA,EAAUlR,QAC7BiR,QAAO,SAAC0E,GACP,IAAMkL,EAAehK,EAAclB,GACnC,YAAqBvV,IAAjBygB,IAIwB,kBAAjBA,OAGP,eAAgBA,KAEhBkE,EAAkCphB,IAChCkd,EAAaxK,WAAWV,iBAU9B0N,EAAW,IAAIhiB,KACnB,UAAChF,EAAc2U,cAAf,QAAyB,IAAIzR,KAAI,SAAC2R,GAAD,MAAe,CAACA,EAAUlR,KAAMkR,OAG7DiiB,EAA2B,IAAI9xB,IACnClC,MAAMC,KAAKikB,EAAS3e,QAAQnF,KAAI,SAACS,GAAD,MAAU,CACxCA,EACAixB,EAAgCjxB,QAI9BozB,EAA2B,IAAI/xB,IACnClC,MAAMC,KAAK+zB,EAAyB1e,WAAWlV,KAAI,mCAAES,EAAF,WAAsB,CAAtB,KAEjDA,OAIEqzB,EAA8BlB,EAClC91B,EACAwa,EACA8K,EACAyQ,GAGIkB,EAAiBlB,EACrBiB,EADwC,UAExCh3B,EAAc2D,YAF0B,QAElB,aAGlBuzB,GAA+C,oBACnDF,EAAariB,cADsC,aACnD,EAAqB8O,kBAD8B,QAChB,IACnCvgB,KAAI,SAACi0B,GACL,IAAMxB,EAAgBwB,EAAUxzB,KAC1B2V,EAAYqF,YAChBoY,EAAyBrxB,IAAIiwB,IAEzB9gB,EAAY8J,YAAcqI,EAASthB,IAAI4T,IAC7C,OAAO,2BAveX,SACEkL,EACA3P,EACAuiB,EACAlB,GAKA,QAAqBnyB,IAAjBygB,EACF,QAA0BzgB,IAAtB8Q,EAAUE,QACZyP,EAAe3P,EAAUE,YACpB,CACL,IAA2B,IAAvBF,EAAUC,SAQZ,MAAMrQ,MAAM,iDAAD,OACwCoQ,EAAUlR,KADlD,MALXiC,QAAQC,MAAR,iBACYgP,EAAUlR,KADtB,+EAGA6gB,EAAe,GAQrB,IACIlU,EAAyB,CAC3B3M,KAFoBixB,EAAgC/f,EAAUlR,OAIhE,GAA4B,kBAAjB6gB,EAET,OADAlU,EAAOmP,MAAQ+E,EACRlU,EACF,GAAI,eAAgBkU,EAAc,CACvC,IAAM6S,EAAqBzC,EACzBpQ,EAAaxK,WAAWV,WAE1B,GAAI8d,EAA2B,CAC7B,IAIME,EACJpB,EALsC,CACtCvyB,KAAM,oBACNZ,KAAK,sBAAD,OAAwBs0B,EAAxB,OAKF,sBAAwB7S,EAAaxK,WAAWV,WAEpDhJ,EAAOmP,MAAQ6X,EAA2B7X,WAE1CnP,EAAOmP,MAAP,8BAAsC4X,EAAtC,MAGF,OAAO/mB,EACF,GAAI,eAAgBkU,EAAc,CACvC,IAAM+S,EAA2B3C,EAC/BpQ,EAAahL,WAAWC,YAIpB+d,EAAuB1C,EAAWtQ,EAAahL,WAAW/E,QAM1D6iB,EACJpB,EANsC,CACtCvyB,KAAM,oBACNZ,KAAK,WAAD,OAAay0B,EAAb,8BAAuDD,EAAvD,OAIuC,6BAEnB/S,EAAahL,WAAW/E,OAFL,mBAEsB+P,EAAahL,WAAWC,aAG3F,OADAnJ,EAAOmP,MAAQ6X,EAA2B7X,MACnCnP,EAEP,MAAM7L,MAAM,mCAAD,OAAoC+f,EAApC,MA8ZNiT,CACDjd,EAAclB,GACdzE,EACAyQ,EAAiChe,IAAIgS,GACrC4c,IALJ,IAQEvyB,KAAMgyB,OAIJ+B,GAA6C,oBACjDV,EAAariB,cADoC,aACjD,EAAqBqP,iBAD4B,QACf,IAClC9gB,KAAI,SAACy0B,GACL,IAAMhC,EAAgBgC,EAASh0B,KACzB2V,EAAYqF,YAChBoY,EAAyBrxB,IAAIiwB,IAEzB9gB,EAAY8J,YAAcqI,EAASthB,IAAI4T,IAC7C,OAAO,2BA7aX,SACEkL,EACA3P,GAGA,QAAqB9Q,IAAjBygB,EAEF,QAA0BzgB,IAAtB8Q,EAAUE,QACZyP,EAAe3P,EAAUE,YACpB,CACL,IAA2B,IAAvBF,EAAUC,SAQZ,MAAMrQ,MAAM,iDAAD,OACwCoQ,EAAUlR,KADlD,MALXiC,QAAQC,MAAR,iBACYgP,EAAUlR,KADtB,+EAGA6gB,EAAe,GAQrB,IACIlU,EAAwB,CAC1B3M,KAFoBixB,EAAgC/f,EAAUlR,OAIhE,GAA4B,kBAAjB6gB,EAIT,OAHAlU,EAAOsnB,IAAM,CACXv1B,KAAMmiB,GAEDlU,EACF,GAAI,eAAgBkU,EAAc,CACvC,IAAMqT,EAAqBjD,EACzBpQ,EAAaxK,WAAWV,WAG1B,OADAhJ,EAAOvN,KAAP,6BAAoC80B,EAApC,MACOvnB,EACF,GAAI,eAAgBkU,EAAc,CAGvC,IAAMmS,EAA6B/B,EACjCpQ,EAAahL,WAAWC,YAEpBmd,EAAqB9B,EAAWtQ,EAAahL,WAAW/E,QAE9D,OADAnE,EAAOvN,KAAP,kBAAyB6zB,EAAzB,8BAAiED,EAAjE,MACOrmB,EAEP,MAAM7L,MAAM,mCAAD,OAAoC+f,EAApC,MA6XNsT,CAA0Btd,EAAclB,GAAYzE,IADzD,IAGElR,KAAMgyB,OAoBJoC,EAAqBb,EACxBh0B,KAAI,SAAC2iB,GAAD,OAASA,EAAIpG,SACjBpK,OAAOqiB,EAA0Bx0B,KAAI,SAAC2iB,GAAD,OAASA,EAAI9iB,SAClD6R,OAAOiK,KAEJmZ,EAAsB,IAAI5vB,IAC9B2vB,EACG70B,KAAI,SAAC2iB,GAAD,uBAASA,EAAI7Y,MAAM,mCAAnB,aAAS,EAAwC,MACrD4H,OAAOiK,MAcZ,MAXkC,CAChClb,KAAM,oBACN0xB,SAAU4B,EACVzlB,UAAW,CACTiS,WAAYyT,EACZlT,UAAW0T,GAGbpC,aAAcxyB,MAAMC,KAAKi1B,EAAoB7yB,UAAUyR,SAMrD1P,EAA8B,SAClCvD,EACAwD,GAMA,IAHY,IAFZ8wB,EAEW,uDAF2B,SAAC/hB,GAAD,OAAOA,GAC7CgiB,EACW,uDADS,IAEhB9wB,EAAY6wB,EAAUt0B,GACtB0D,EAAQ,EACLF,EAAcG,IAAIF,IAAY,CAEnC,IAAM+wB,EAAeF,EAAUt0B,EAAOu0B,KADtC7wB,GACwDjE,YACxD,GAAI+0B,IAAiB/wB,EACnB,MAAM3C,MAAM,oGAAD,OAC2F0zB,IAGxG/wB,EAAY+wB,EAEd,OAAO/wB,GAyEIgxB,EAAsC,SACjDp4B,EACAspB,GACI,IAAD,kBACG+O,EA1EmD,SACzDr4B,GACI,IAAD,IACCs4B,EAA+C,GAE7CC,EAA6B,IAAIvzB,IAEjC+wB,EAAsB,SAC1BV,GAEI,IADJ/N,EACG,uDADkB,YAIfkR,EAAkC,2BAAQnD,GAAR,IAAkB1xB,KAAM,KAC1D4jB,EAAiBvW,KAAKiF,UAAUuiB,GAChChR,EAAa+Q,EAA2B7yB,IAAI6hB,GAClD,QAAmBxjB,IAAfyjB,EACF,OAAOA,EAET,IAAMC,EAAU,IAAIrf,IAAIlD,OAAOmD,KAAKiwB,IAG9B32B,EAAKuF,EACTogB,EACAG,EACAqN,GAMF,OAJAyD,EAA2B5yB,IAAI4hB,EAAgB5lB,GAC/C22B,EAAc32B,GAAM0zB,EAEpBA,EAAS1xB,KAAOhC,EACTA,GAIH+mB,EAAoC,IAAItgB,IAgC9C,MAVwC,CAMtCqwB,WAXyB1C,EAPFD,EACvB91B,EATsDkF,OAAOiT,aAC7D,UAACnY,EAAc2U,cAAf,QAAyB,IAAIzR,KAAI,SAAC2R,GAChC,IAAM0E,EAAyB,CAC7BS,WAAY,CAAEV,UAAWzE,EAAUlR,OAErC,MAAO,CAACkR,EAAUlR,KAAM4V,OAM1BmP,EACAqN,GAG4C,UAE5C/1B,EAAc2D,YAF8B,QAEtB,QAWtB+0B,UAAWxzB,OAAOC,OAAOmzB,IAUzBK,CAA4C34B,GAGxCoqB,GAAyB,UAACpqB,EAAc2U,cAAf,QAAyB,IACrDC,QAAO,SAACC,GAAD,YAAqC9Q,IAAtB8Q,EAAUE,WAChC7R,KAAI,SAAC2R,GAAD,MAAiC,CACpCA,EAAUlR,KACV0P,OAAOwB,EAAUE,aAGfsV,EAAuB,IAAIrlB,IAC/BolB,EAAuB/U,OAAOvS,MAAMC,KAAKumB,EAAkBlR,aAIvDwgB,EAAc,IAAI5zB,IAAJ,UAClBqzB,EAAaK,iBADK,aAClB,EAAwBx1B,KAAI,SAACmyB,GAAD,MAAc,CAACA,EAAS1xB,KAAM0xB,OAEtDwD,EAAela,YACnBia,EAAYlzB,IAAIiZ,YAAc0Z,EAAaI,cAEvCK,EAAmB,iBACvBD,QADuB,IACvBA,GADuB,UACvBA,EAAclkB,cADS,iBACvB,EAAsB8O,kBADC,aACvB,EAAkCvgB,KAAI,SAACi0B,GAAD,OAAeA,EAAUxzB,eADxC,QACiD,GACpEo1B,EAAmB,iBACvBF,QADuB,IACvBA,GADuB,UACvBA,EAAclkB,cADS,iBACvB,EAAsBqP,iBADC,aACvB,EAAiC9gB,KAAI,SAACy0B,GAAD,OAAcA,EAASh0B,eADrC,QAC8C,GAEjEq1B,EAAiC,IAAIh0B,IACzClC,MAAMC,KAAKsnB,EAAqBjS,WAAWlV,KAAI,mCAAE0jB,EAAF,KAAOnH,EAAP,WAAkB,CAC/DmV,EAAgChO,GAChCnH,OAGE6K,EAA6C,CACjD7G,WAAYqV,EACTlkB,QAAO,SAACjR,GAAD,OAAUq1B,EAA+B1xB,IAAI3D,MACpDT,KACC,SAACyyB,GAAD,MAAoC,CAClChyB,KAAMgyB,EACNlW,MAAOuZ,EAA+BtzB,IAAIiwB,OAGhD3R,UAAW+U,EACRnkB,QAAO,SAACjR,GAAD,OAAUq1B,EAA+B1xB,IAAI3D,MACpDT,KACC,SAACyyB,GAAD,MAAmC,CACjChyB,KAAMgyB,EACNiC,IAAK,CACHv1B,KAAMsc,YACJqa,EAA+BtzB,IAAIiwB,UA0B/C,OAlBA0C,EAAa7mB,UAAY8Y,EAOO,CAC9B2O,WAAY,uBACZC,KAAM,WACN3gB,SAAU,CACR4gB,eAPF,UAAAn5B,EAAc2D,YAAd,eAAoBye,cAAc1O,QAAQ,eAAgB,OAAQ,YAClEygB,UAAU,EAAG,KAOXvc,YAAa,CACX,sCAAuC,SAG3C7W,KAAMs3B,IC16BJe,EAA6B,sCAC7BC,EAA+B,wCAE/BC,EAAoB,uCAAG,WAC3BC,EACAC,EACAC,EACA5X,EACA6X,GAL2B,2BAAA14B,EAAA,yDAQrB24B,EAAS,CACbh2B,KAAI,iBAAE+1B,QAAF,IAAEA,IAAWH,EAAiB51B,YAA9B,QAAsC,WAC1Ci2B,cAAe,CACbC,kBAAmB7oB,KAAKiF,UAAUsjB,KAGjCC,EAAShwB,SAAS,SACrB5D,QAAQM,KAAK,0DACbszB,EAAW,WAAaA,GAErBA,EAASM,SAAS,OACrBN,GAAsB,KAElBO,EAASP,EAAW,oBACrBC,EAtBsB,qBAwBrB5X,EAxBqB,iCAyBEsQ,EACvBtQ,EACA,CAAC,mDA3BoB,OAyBjBuQ,EAzBiB,OA6BvBqH,EAAS,OAAGrH,QAAH,IAAGA,OAAH,EAAGA,EAAY4H,aA7BD,yBAgCJ/4B,MAAM84B,EAAQ,CACnClH,OAAQ,OACRC,KAAM9hB,KAAKiF,UAAU0jB,GACrBz4B,QAAS,IAAIC,QAAQ,CACnBC,cAAe,UAAYq4B,MApCJ,eAgCrBp4B,EAhCqB,OAuC3B,QAAC,GAAD,EAAC8I,QAAeskB,YAAhB,gBACE,QACA,2DACA,IA1CyB,kBA4CpBptB,EAAS44B,QA5CW,4CAAH,8DA+CpBC,EAAoB,SAACV,EAAkBW,GAQ3C,OANKX,EAAShwB,SAAS,SACrBgwB,EAAW,WAAaA,GAErBA,EAASM,SAAS,OACrBN,GAAsB,KAEjBA,EAAW,kBAAoBW,GA2NzBC,EAlNoB,SAAC,GAII,IAHtCp6B,EAGqC,EAHrCA,cACAspB,EAEqC,EAFrCA,kBACAzH,EACqC,EADrCA,yBAEA,EAAwCzhB,wBACtC2D,GADF,mBAAOs2B,EAAP,KAAqBC,EAArB,KAGA,EAA8Dl6B,wBAE5D2D,GAFF,mBAAOw2B,EAAP,KAAgCC,EAAhC,KAGA,EAAgDp6B,wBAC9C2D,GADF,mBAAOyvB,EAAP,KAAyBC,EAAzB,KAGA,EAA8CrzB,wBAC5C2D,GADF,mBAAO02B,EAAP,KAAwBC,EAAxB,KAGA,EAAgCt6B,oBAC9B,8CAAM+J,OAAO+W,oBAAb,aAAM,EAAqBva,QAAQyyB,UAAnC,QAAkE,MADpE,mBAAOI,EAAP,KAAiBmB,EAAjB,KAGA,EAAkCv6B,oBAChC,8CAAM+J,OAAO+W,oBAAb,aAAM,EAAqBva,QAAQ0yB,UAAnC,QAAoE,MADtE,mBAAOI,EAAP,KAAkBmB,EAAlB,KAGA,EAA6Bx6B,wBAA6B2D,GAAjD82B,EAAT,oBACA,EAAoCz6B,wBAA6B2D,GAAxD+2B,EAAT,oBACA,EAAkD16B,wBAEhD2D,GAFF,mBAAOg3B,EAAP,KAA0BC,EAA1B,KAIA9vB,qBAAU,WACR,QAAsBnH,IAAlB/D,EACF,IACE,IAAMq6B,EAAejC,EACnBp4B,EADsD,OAEtDspB,QAFsD,IAEtDA,IAAqB,IAAItkB,KAE3Bq1B,EAAa9hB,SAASub,OAAS,CAC7BC,IAAK,yBACL,sCAAuC,OACvC,2CAA4C,0BAE9CuG,EAAgBD,GAChB,IAAMY,EAAmB12B,IAAK2E,KAAKmxB,EAAc,CAC/ClxB,WAAY,EACZ+xB,YAAa,MAETC,EAA6BrsB,IAAI8d,gBACrC,IAAIF,KAAK,CAACuO,GAAmB,CAAEx6B,KAAM,sBAGvC+5B,GAA2B,SAACY,GAI1B,YAHuCr3B,IAAnCq3B,GACFtsB,IAAIusB,gBAAgBD,GAEfD,KAET1H,OAAoB1vB,GACpB,MAAOuG,GACP,IAAM8iB,EACW,kBAAR9iB,GAAoBA,aAAe7F,MACtC6F,EAAIlH,WACJiQ,OAAO/I,GACbmpB,EAAoBrG,MAGvB,CAACptB,EAAespB,IAEnB,IAAM2K,EAAgBuF,GAAYa,EAElC,OACE,uBACE1oB,SAAQ,uCAAE,WAAOhR,GAAP,6CAAAK,EAAA,yDACRL,EAAEiR,iBACG4nB,GAAaa,EAFV,iDAKRW,OAAqBj3B,GALb,SAQN,IACE,UAAAoG,OAAO+W,oBAAP,SAAqBpd,QAAQs1B,EAA4BI,GACzD,UAAArvB,OAAO+W,oBAAP,SAAqBpd,QACnBu1B,EACAI,GAEF,MAAOnvB,GACP1E,QAAQC,MACN,2EACAyE,GAjBE,OAoBAovB,GACJ,iBAAC15B,QAAD,IAACA,OAAD,EAACA,EAAe2D,YAAhB,QAAwB,YACxB,KACA,IAAIoE,MAAOmsB,cAAcxgB,QAAQ,IAAK,KAAKA,QAAQ,IAAK,IAvBpD,SAwBe4lB,EACnBe,EACAb,EACAC,EACA5X,EACA6X,GA7BI,OAwBAppB,EAxBA,OA+BN1K,QAAQqB,MAAMqJ,GAEO,kBADf6pB,EAhCA,OAgCQ7pB,QAhCR,IAgCQA,GAhCR,UAgCQA,EAAQgrB,WAhChB,aAgCQ,EAAa35B,MAEzBk5B,EAAiBV,GACXoB,EAASrB,EAAkBV,EAAUW,GAC3Ca,EAAqBO,IAIsB,kBAFvCC,EAtCA,OAuCJlrB,QAvCI,IAuCJA,GAvCI,UAuCJA,EAAQmrB,wBAvCJ,aAuCJ,EAA0B5B,qBAEpB6B,EAA0B1qB,KAAKC,MACnCuqB,IAEIG,EAJ+C,OAIhCD,QAJgC,IAIhCA,GAJgC,UAIhCA,EAAyBnjB,gBAJO,aAIhC,EAAmC5U,OAEtDm3B,EAAwBa,IAG5BjB,OAAmB32B,GAjDb,kDAmDN6B,QAAQC,MAAR,MACMunB,EACW,kBAAR,EAAP,IAA2B,gBAAe3oB,MACtC,KAAIrB,WACJiQ,OAAO,EAAD,IACZqnB,EAAmBtN,GACnB,QAAC,GAAD,EAACjjB,QAAeskB,YAAhB,gBACE,QACA,wDACA,IA5DI,0DAAF,sDADV,UAkEE,sBACE3iB,MAAO,CACLiU,WAAY,SACZrT,OAAQ,OAHZ,UAME,uBAAO6nB,QAAQ,WAAf,wBACA,uBACE5yB,GAAG,WACH0e,UAAQ,EACR5f,KAAK,OACLif,YAAY,+CACZxL,MAAM,+DACNuL,MAAO+Z,EACPjZ,SAAU,SAAC5f,GAAD,OAAOg6B,EAAYh6B,EAAE6L,OAAOiT,aAG1C,sBACE3T,MAAO,CACLiU,WAAY,SACZrT,OAAQ,OAHZ,UAME,uBAAO6nB,QAAQ,QAAf,qBACA,uBACE5yB,GAAG,QACHlB,KAAK,OACLif,YAAY,UACZxL,MAAM,6BACNuL,MAAOga,EACPlZ,SAAU,SAAC5f,GAAD,OAAOi6B,EAAaj6B,EAAE6L,OAAOiT,aAG3C,sBACE3T,MAAO,CACLiU,WAAY,SACZrT,OAAQ,OAHZ,UAME,uBACEjM,KAAK,SACL+f,UAAWyT,EACXxU,MAAM,oBAEPsb,GACC,mBACEzuB,KAAMyuB,EACNvuB,OAAO,SACPC,IAAI,aACJX,MAAO,CAAEY,OAAQ,OAJnB,oBAUH6tB,GACC,sBACEzuB,MAAO,CACLY,OAAQ,OAFZ,4BAMkB,IAChB,mBAAGJ,KAAMiuB,EAAyB1N,SAAU,yBAA5C,uCAKH2G,GAAoB,8BAAMA,IAC1BiH,GAAmB,0CAAaA,SC5LxBmB,IAlFW,SAAC,GAGI,IAAD,IAF5B57B,EAE4B,EAF5BA,cACA6hB,EAC4B,EAD5BA,yBAEA,EAAkDzhB,mBAEhD,IAFF,mBAAOkpB,EAAP,KAA0BuS,EAA1B,KAIA,EACEz7B,mBAA8B,IAAI4E,KADpC,mBAAO82B,EAAP,KAAgCC,EAAhC,KAcA,OAXA7wB,qBAAU,WAER,IAAM8wB,EAA6B,IAAIh3B,IACrCE,OAAOkT,QAAQkR,GAAmB1U,QAEhC,SAACqnB,GAAD,MAAuD,kBAAZA,EAAK,OAGpDF,EAA2BC,KAC1B,CAAC1S,IAGF,0CACqBvlB,IAAlB/D,GACwC,KAAzC,iBAACA,QAAD,IAACA,GAAD,UAACA,EAAe2U,cAAhB,aAAC,EAAuBhK,cAAxB,QAAkC,QAAW5G,EAC3C,2BACE+H,MAAO,CAELG,QAAS,MACTkjB,aAAc,OAJlB,UAOE,+CACA,cAACld,EAAA,EAAD,CACEjS,cAAeA,EACfkS,mBAAoBoX,EACpBnX,sBAAuB0pB,EACvBvc,eAAe,OAIrB,0BACExT,MAAO,CACLiG,OAAQ,iBACRC,aAAc,MACd/F,QAAS,OAJb,UAOE,yBACEH,MAAO,CAAEqU,YAAa,MAAOlU,QAAS,MAAO8e,WAAY,QAD3D,oCAKA,cAACmR,EAAD,CACEl8B,cAAeA,EACfspB,kBAAmBwS,EACnBja,yBAA0BA,OAG9B,0BACE/V,MAAO,CACLiG,OAAQ,iBACRC,aAAc,MACd/F,QAAS,OAJb,UAOE,yBACEH,MAAO,CAAEqU,YAAa,MAAOlU,QAAS,MAAO8e,WAAY,QAD3D,0CAKA,cAAC,EAAD,CACE/qB,cAAeA,EACfspB,kBAAmBwS,EACnBja,yBAA0BA,Y,iMCzCrBsa,EA/BY,SAAC,GAMI,IAL9Bn8B,EAK6B,EAL7BA,cAK6B,IAJ7Bo8B,wBAI6B,MAJV,iBAIU,MAH7BC,gBAG6B,MAHlB,iBAGkB,EAF7BC,EAE6B,EAF7BA,QACAxwB,EAC6B,EAD7BA,MAEMtB,EAAQC,aAAc,SAACC,GAAD,OAAWA,EAAMF,SAE7C,IACExK,EAAgB4K,YAAqB5K,EAAewK,GAAO,GAAO,GAClE,MAAOF,GAAW,IAAD,EACjB,IAA6D,KAAtD,OAAHA,QAAG,IAAHA,GAAA,UAAAA,EAAKjK,eAAL,eAAcwK,WAAW,6BAE3B,OADAjF,QAAQC,MAAMyE,GACP,sDAGX,IAAMrG,EAAgBkC,YAAoBnG,GACpCysB,EAAoB,IAAIC,KAAK,CAACzoB,GAAgB,CAAExD,KAAM,cAC5D,OACE,mBACEK,IAAKw7B,EACLhwB,KAAMwC,IAAI8d,gBAAgBH,GAC1BI,SAAUuP,EACVtwB,MAAOA,EAJT,SAMGuwB,KCrBDE,EAAiC,uCAAG,WACxCl6B,GADwC,eAAArB,EAAA,yDAGlCw7B,EAAkBtrB,YAAuB7O,GALd,eAMCm6B,EAJM,sBAKhC/3B,MAAM,6CAAD,OAA8C+3B,IALnB,gCAOjCA,GAPiC,2CAAH,sDAUjCC,EAAgC,uCAAG,WACvC53B,GADuC,6BAAA7D,EAAA,6DAEvCd,EAFuC,+BAENC,IAFM,SAITD,EAAa2E,EAAK03B,GAJT,cAIjCC,EAJiC,yBAKhCA,GALgC,2CAAH,sDAQtC,SAAS3d,EAAgB3I,GACvB,YAAanS,IAANmS,EAST,IA4DewmB,EA5De,SAAC,GAIF,IAH3Bhb,EAG0B,EAH1BA,mBACAzhB,EAE0B,EAF1BA,iBAE0B,IAD1BC,oBAC0B,MADXC,IACW,EAC1B,EAA0CC,mBAExC,IAFF,mBAAOu8B,EAAP,KAAsBC,EAAtB,KA4BA,OAxBA1xB,qBAAU,WACR,sBAAC,gCAAAlK,EAAA,yDAC8B,IAAzB27B,EAAchyB,OADnB,0CAG0C8xB,EACnC/a,EACAxhB,GALP,cAGWmsB,EAHX,OAOWwQ,EAAexQ,EAAuBvC,WACzC5mB,KAAI,SAACyB,GAAD,OAAkBA,EAAaE,OACnC+P,OAAOiK,GATf,SAUuC0S,QAAQuL,IACxCD,EAAa35B,KAAI,SAAC2B,GAAD,OACfjE,YAA6BiE,EAAK3E,OAZ3C,OAUW68B,EAVX,OAeKH,EAAiBG,GAftB,kDAiBKn3B,QAAQC,MAAR,MAjBL,yDAAD,KAqBC,CAAC6b,EAAoBxhB,EAAcy8B,EAAchyB,SAGlD,qBACEmB,MAAO,CAELkU,SAAU,OACVD,WAAY,UAJhB,SAOE,qBAAKjU,MAAO,CAAEkU,SAAU,OAAQgd,WAAY,QAA5C,SACGL,EAAcz5B,KAAI,SAACyB,GAAD,aACjB,0CAEE,wBACE4G,UAAU,cACV7K,QAAS,SAACC,GACQ,OAAhBV,QAAgB,IAAhBA,KAAmB0E,EAAa5D,OAHpC,mBAMG4D,EAAa5D,KAAK4C,YANrB,QAM6B,iBARrBgB,EAAahC,gBC7D3Bs6B,EAA2B,iBAS3BC,EAAiB,SAACC,EAAWC,GAAwB,IAAD,gBACnCA,GADmC,IACxD,2BAA+B,CAAC,IAArBC,EAAoB,QACzBF,EAAErD,SAASuD,KACbF,EAAIA,EAAEhJ,UAAU,EAAGgJ,EAAExyB,OAAS0yB,EAAO1yB,UAHe,8BAMxD,OAAOwyB,GAUHG,EAAuB,SAAC,GAKI,IAJhClS,EAI+B,EAJ/BA,OACAmS,EAG+B,EAH/BA,eACA5N,EAE+B,EAF/BA,SACA6N,EAC+B,EAD/BA,YAEA,EAAgCp9B,mBAA6Bo9B,GAA7D,mBAAO/1B,EAAP,KAAiBg2B,EAAjB,KACA,EAA0Dr9B,oBAAS,GAAnE,mBAAOs9B,EAAP,KAA8BC,EAA9B,KAEMC,EAAU,uCAAG,WAAOj6B,GAAP,SAAA3C,EAAA,6DACjBy8B,EAAY95B,GADK,kBAGT45B,EAAe55B,GAAM,GAHZ,sDAKfg6B,GAAyB,GALV,wDAAH,sDAoBhB,OACE,qCACE,cAAC,EAAD,CACEvS,OAAQA,EACRyS,OAAQD,EACRjO,SAAUA,EACVC,aAAcnoB,EACdq2B,WAAW,kBAEb,cAAC,EAAD,CACE1S,OAAQA,GAAUsS,EAClBxpB,MAAM,aACN6pB,aAAa,YACbC,KAxBoB,WACpBv2B,IACFk2B,GAAyB,GACzBJ,EAAe91B,GAAU,KAsBvBkoB,SAlBwB,WAC5BgO,GAAyB,UAgCvBM,EAAiB,SAAC,GAOI,IAN1B7S,EAMyB,EANzBA,OACAlX,EAKyB,EALzBA,MAKyB,IAJzB6pB,oBAIyB,MAJV,KAIU,MAHzBG,wBAGyB,MAHN,SAGM,EAFzBF,EAEyB,EAFzBA,KACArO,EACyB,EADzBA,SAEA,OACE,eAACwO,EAAA,EAAD,CAAQ38B,KAAM4pB,EAAQ3pB,kBAAgB,qBAAtC,UACE,cAAC28B,EAAA,EAAD,CAAaz8B,GAAG,qBAAhB,SAAsCuS,IACtC,eAACmqB,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,CAAQ18B,MAAM,UAAUlB,QAASivB,EAAjC,SACGuO,IAEH,cAACI,EAAA,EAAD,CAAQ18B,MAAM,YAAYlB,QAASs9B,EAAnC,SACGD,WAeLQ,EAAe,SAAC,GAMI,IALxBnT,EAKuB,EALvBA,OACAyS,EAIuB,EAJvBA,OACAlO,EAGuB,EAHvBA,SACAC,EAEuB,EAFvBA,aAEuB,IADvBkO,kBACuB,MADV,gBACU,EACjBU,EAAezO,mBACrB,OACE,eAACoO,EAAA,EAAD,CAAQ38B,KAAM4pB,EAAQ3pB,kBAAgB,qBAAtC,UACE,cAAC28B,EAAA,EAAD,CAAaz8B,GAAG,qBAAhB,SAAsC,kBACtC,uBACEgQ,SAAU,SAAChR,GACL69B,EAAavO,SACf4N,EAAOW,EAAavO,QAAQxQ,OAE9B9e,EAAEiR,kBALN,UAQE,cAAC6sB,EAAA,EAAD,UACE,cAACC,EAAA,EAAD,CACE/8B,GAAG,OACHlB,KAAK,OACLogB,aAAc+O,EACdpb,MAAOspB,EACP5N,SAAUsO,EACVne,UAAQ,EACRxe,WAAS,EACTmuB,WAAS,EACTtjB,OAAO,YAGX,eAAC2xB,EAAA,EAAD,WACE,cAACC,EAAA,EAAD,CAAQ59B,QAASivB,EAAjB,oBACA,cAAC2O,EAAA,EAAD,CAAQ18B,MAAM,UAAUnB,KAAK,SAASoB,WAAS,EAA/C,4BAyTK88B,IAhTS,SAAC,GAKI,IAJ3B3+B,EAI0B,EAJ1BA,cACAC,EAG0B,EAH1BA,iBACA+qB,EAE0B,EAF1BA,yBAE0B,IAD1B9qB,oBAC0B,MADXC,IACW,EAE1B,EAA4CC,mBAC1C,IAAI4E,KADN,mBAAO4D,EAAP,KAAuB0kB,EAAvB,KAGA,EAAwCltB,qBAAxC,mBAAOw+B,EAAP,KAAqBC,EAArB,KACA,EAAoDz+B,oBAAS,GAA7D,mBAAO0+B,EAAP,KAA2BC,EAA3B,KACMv0B,EAAQC,aAAc,SAACC,GAAD,OAAWA,EAAMF,SAE7C,EAAsDpK,qBAAtD,mBAAOmtB,EAAP,KAA4BC,EAA5B,KACA,EAAkDptB,qBAAlD,mBAAOqtB,EAAP,KAA0BC,EAA1B,KAEMsR,EAAmBlR,uBAAY,WACnCnlB,YAA6Bs0B,GAA0Bp8B,KACrDysB,KAED,CAACA,IAEJpiB,oBAAU8zB,EAAkB,CAACA,IAE7B,IAAMC,EAAmBnR,sBAAW,uCAClC,WAAO9lB,GAAP,SAAAhH,EAAA,sEAGQ8D,YACJkD,EAAUrD,aAAa5D,KACvBb,GALJ,OAOkB,OAAhBD,QAAgB,IAAhBA,KAAmB+H,EAAUrD,aAAa5D,MAC1C89B,EAAgB72B,GARlB,2CADkC,sDAWlC,CAAC/H,EAAkB4+B,EAAiB3+B,IAGhCsc,EAASsR,uBACb,SAACC,GACCA,EAAcC,SAAQ,SAACC,GACrB,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,QAAU,kBAAMxoB,QAAQ6D,IAAI,6BACnCykB,EAAOG,QAAU,kBAAMzoB,QAAQ6D,IAAI,4BACnCykB,EAAOI,OAAP,sBAAgB,4CAAAttB,EAAA,yDAEI,QADZutB,EAAYL,EAAO5d,cACevM,IAAdwqB,EAFZ,uBAGZ3oB,QAAQC,MAAR,yCAAgD0oB,IAHpC,iCAMR9mB,EACJy1B,EAAejP,EAAKtqB,KAAM,CACxB,2BACA,kBACA,iBACA,WACI,WAZM,kBAcgBK,YAC1BuqB,GAfU,UAcN2Q,EAdM,OAiBP9tB,YAAsB8tB,EAAcn+B,KAAKkE,gBAjBlC,wBAkBVW,QAAQC,MAAM,8CAlBJ,4CAsBNf,YAA2Bo6B,EAAcn+B,KAAMb,GAtBzC,yBAwBuBuI,YACjCw0B,EACA1O,EACA9mB,GA3BU,QAwBN+mB,EAxBM,OA6BN7pB,EAAe6pB,EAAqB7pB,aAC1CiB,QAAQqB,MAAM,+BAAgCtC,GAC9C,QAAC,GAAD,EAACwF,QAAeskB,YAAhB,gBAAuB,QAAS,kCAAmC,CACjEne,OAAQ,cAGV0uB,IAnCY,kDAwCZp5B,QAAQC,MAAM,8CAAd,MACA,QAAC,GAAD,EAACsE,QAAeskB,YAAhB,gBAAuB,QAAS,kCAAmC,CACjEne,OAAQ,WA1CE,0DA8ChB4d,EAAOQ,kBAAkBT,QAG7B,CAAC+Q,EAAkB9+B,IAGfi/B,EAAmBrR,uBAAY,WACnCiR,GAAsB,KACrB,CAACA,IAEEK,EAAoBtR,uBAAY,WACpCiR,GAAsB,KACrB,CAACA,IAEEM,EAAqBvR,sBAAW,uCACpC,WAAOnqB,GAAP,+BAAA3C,EAAA,yHAEoC+H,YAC9Bk0B,EACAt5B,GAJN,UAM8B,OAN9B,6BAOYc,MAAM,SAAD,OAAUd,EAAV,sBAPjB,UAUO3D,EAVP,wDAaQwsB,EAAiB5hB,YACrB5K,EACAwK,GACA,GACA,IAEa7G,KAAOA,EAChBM,EAAgBkC,YAAoBqmB,GApB5C,UAqB0B9jB,YACtBu0B,EACAt5B,EACAM,GAxBJ,eAqBQ+D,EArBR,iBA0BQi3B,EAAiBj3B,GA1BzB,QA2BEo3B,IACAJ,IA5BF,4CADoC,sDA+BpC,CACEh/B,EACAo/B,EACA50B,EACAy0B,EACAD,IAIEnQ,EAAuB,uCAAG,sBAAA7tB,EAAA,0DAC1BusB,EAD0B,uBAE5BC,OAAuBzpB,GAFK,SAGtBiF,YACJi0B,EACA1P,GAL0B,OAO5ByR,IAP4B,2CAAH,qDAWvBM,EAAqB,uCAAG,4BAAAt+B,EAAA,0DACxBusB,EADwB,wBAE1BC,OAAuBzpB,GAFG,SAGFgF,YACtBk0B,EACA1P,GALwB,UAGpBvlB,EAHoB,8BAQxBpC,QAAQC,MAAR,sCACiC0nB,EADjC,qBARwB,2CAapB0R,EAAiBj3B,GAbG,4CAAH,qDAiBrBu3B,EAAqBzR,uBACzB,SAAC5D,GAEC2U,OAAgB96B,GACA,OAAhB9D,QAAgB,IAAhBA,KAAmBiqB,KAErB,CAACjqB,IAGGu/B,EAAYzP,iBAAyB,MACrC0P,GAAgB1P,iBAA0B,MAEhD,OACE,sBACEjkB,MAAO,CAELkU,SAAU,OACVD,WAAY,UAJhB,UAOE,sBAAKjU,MAAO,CAAEY,OAAQ,OAAtB,UACE,wBACEhM,QAAS,SAACC,GACJi+B,EACFS,EAAkB,OAACT,QAAD,IAACA,OAAD,EAACA,EAAcj7B,MAAM,GAEvCw7B,KALN,kBAWA,wBAAQz+B,QAASy+B,EAAjB,qBACCn/B,GAAiB8+B,GAChB,cAAC,EAAD,CACEtB,YAAax9B,EAAc2D,KAC3BynB,OAAQ0T,EACRnP,SAAUyP,EACV7B,eAAgB8B,IAGpB,uBACEv+B,IAAK0+B,EACL/+B,KAAK,OACLsuB,OAAO,QACPxO,SAAU,SAAC5f,GAAD,aAAO6b,EAAO1Z,MAAMC,KAAN,UAAWpC,EAAE6L,OAAOkzB,aAApB,QAA6B,MACrD5zB,MAAO,CAAEM,QAAS,UAEpB,wBAAQ1L,QAAS,SAACC,GAAD,uBAAO6+B,EAAUvP,eAAjB,aAAO,EAAmB0P,SAA3C,sBACA,wBACEj/B,QAAS,SAACC,GAAO,IAAD,EACd,UAAA8+B,GAAcxP,eAAd,SAAuB0P,SAF3B,oBAOC3/B,GACC,cAAC,EAAD,CACEs8B,QAASmD,GACTz/B,cAAeA,EACfq8B,SAAS,eACTD,kBACGp8B,EAAc2D,KAAO3D,EAAc2D,KAAO,IAAM,IACjD,0BAEFmI,MAAO,CAAE8zB,eAAgB,aAI/B,sBAAK9zB,MAAO,CAAEkU,SAAU,OAAQgd,WAAY,QAA5C,UACGl6B,MAAMC,KAAK6F,EAAewP,WAAWlV,KAAI,mCAAEuE,EAAF,KAAYO,EAAZ,YACxC,0CAEE,wBACEuD,UAAU,cACV7K,QAAS,SAACC,GAAD,OAAOs+B,EAAiBj3B,IACjC8D,MACErE,KAAQ,OAAKm3B,QAAL,IAAKA,OAAL,EAAKA,EAAcj7B,MACvB,CAAEonB,WAAY,aACdhnB,EAENsrB,cAAe,SAAC1uB,GACdA,EAAEiR,iBACF8b,EAAqB/sB,EAAE2uB,eACvB9B,EAAuB/lB,IAX3B,SAcGA,MAhBKA,MAoBZ,eAACo4B,EAAA,EAAD,CACEr+B,UAA8BuC,IAAxBwpB,EACNgC,SAAU9B,EACV+B,QAAS,WACPhC,OAAuBzpB,IAJ3B,UAOE,cAAC+7B,EAAA,EAAD,CAAUrQ,OAAO,EAAM/uB,QAAS4+B,EAAhC,kBAGA,cAACQ,EAAA,EAAD,CAAUrQ,OAAO,EAAM/uB,QAASmuB,EAAhC,0BAKJ,0BACErtB,MAAI,EACJsK,MAAO,CACLiG,OAAQ,iBACRC,aAAc,MACd/F,QAAS,OALb,UAQE,kCACE,6DAE4BlI,IAA7BinB,EACC,2CAEA,cAAC,EAAD,CACE/qB,iBAAkBs/B,EAClB7d,mBAAoBsJ,EACpB9qB,aAAcA,Y,0JCjdpB4B,EAAU,aACVi+B,EAAgC,eAChCC,EAAuC,yBACvCC,EAA4B,cAC5BC,EAA4B,cAC5BC,EAAoC,cAEpCC,EAAwB,aAMxBC,EAAuC,SAC3CtvB,GAD2C,MAG3C,UAAWA,GAAOjO,MAAMw9B,QAAQvvB,EAAIwvB,QAEhCC,EAA6B,uCAAG,WACpCC,GADoC,2CAAAz/B,EAAA,6DAEpC0/B,EAFoC,+BAE7B,EACP9pB,EAHoC,+BAG7B,UACP+pB,EAJoC,+BAI5B,OACRzgC,EALoC,+BAKH0gC,IAG3BC,EAAeC,mBAAmBL,GAClCM,EAAcD,mBAAmBlqB,GACjCoqB,EAAeF,mBAAmBH,GAClCM,EAX8B,+CAWsBJ,EAXtB,iBAW2CE,EAX3C,kBAWgEC,EAXhE,8BAWkGN,GAXlG,UAYPxgC,EAAa+gC,EAAWnwB,KAZjB,WAY9BowB,EAZ8B,OAa/Bb,EAAqCa,GAbN,uBAc5Bz8B,MACJ,sEAfgC,iCAkB7By8B,GAlB6B,4CAAH,sDAqB7BC,EAA6B,SAACC,GAGlC,OAAOA,EACJ1tB,QAAQ,sBAAuB,sCAC/BA,QAAQ,SAAU,M,SAQP2tB,E,8EAAhB,WACEC,GADF,+BAAAtgC,EAAA,sDAGMugC,EAA8B,GAG5BC,EAAa,CAAC,2BAA2BnsB,OAAOisB,GAChDb,EAAQe,EAAWl+B,KAAK,KACrBo9B,EAAO,EARlB,YAQqBA,EAAO,KAR5B,6CASgCF,EAC1BC,EACAC,IAXN,UASUe,EATV,OAiByB,KADflB,EAAekB,EAAclB,OACzB51B,OAjBd,mEAoBqB41B,GApBrB,2DAqBM,OADOmB,EApBb,kBAqBY,CACJ78B,IAAKs8B,EAA2BO,EAAKC,UACrCC,KAAMF,EAAKG,KAvBnB,8KA0BU,IAAItQ,SAAQ,SAACC,GAAD,OAChBsQ,WAAWtQ,EAAW,IAAF,SA3B1B,QAQiCkP,IARjC,gDA8BSa,GA9BT,kE,sBAiCA,IAAMQ,EAAgC,uCAAG,WACvCT,GADuC,2EAAAtgC,EAAA,sDAEvCd,EAFuC,+BAENC,IAEjCyF,QAAQqB,MAAM,6CACR+6B,EACJX,EAA2CC,GAGvCW,EAAcx+B,IAAYC,eAAe,CAC7CC,KAAM7B,EACN8B,UAAWq8B,IAEPiC,EAAcz+B,IAAYC,eAAe,CAC7CC,KAAM7B,EACN8B,UAAWs8B,IAEPiC,EAAkB1+B,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAWm8B,IAEPqC,EAAwB3+B,IAAYC,eAAe,CACvDC,KAAM7B,EACN8B,UAAWo8B,IAEPqC,EAAyB5+B,IAAYC,eAAe,CACxDC,KAAM7B,EACN8B,UAAWu8B,IAEPmC,EAAc7+B,IAAYC,eAAe,CAC7CC,KAAM7B,EACN8B,UAAWw8B,IA/B0B,kCAiCd4B,GAjCc,mIAkC/BJ,GADSF,EAjCsB,GAkCnBE,KAAKxf,cACjBgf,EAAUM,EAAK78B,IAnCgB,UAoCTy9B,EAAY37B,QAAgBi7B,GApCnB,WAqCf,QADhBW,EApC+B,gCAsCnC38B,QAAQqB,MAAR,uBACkBm6B,EADlB,sBACuCQ,EADvC,2BAC8DW,EAD9D,MAtCmC,8CA4C7BC,EAAsBrB,EAA2BC,IACtCtH,SAAS,kBA7CS,wBA8CjCl0B,QAAQqB,MAAR,uBACkBu7B,EADlB,iDA9CiC,iDAoDVP,EAAYt7B,QAAgB67B,GApDlB,eAqDhB,QADbC,EApD6B,SAqDRA,IAAeb,GACxCh8B,QAAQC,MAAR,qDACgD28B,EADhD,aACgEC,EADhE,eACiFb,EADjF,MAtDiC,UA2DVS,EAAuB17B,QAC9C67B,GA5DiC,WA2D7BE,EA3D6B,SAgElB,OAAfD,GACe,OAAfC,GACAC,OAAO5f,SAAS2f,IAjJe,GA+EE,+DAuEnC98B,QAAQqB,MAAR,8CAAqDu7B,EAArD,MACIxiC,OAxE+B,EAyE/BiE,OAzE+B,sBA4ENW,YACzB49B,EACAtiC,GA9E+B,QA4E3ByE,EA5E2B,OAgFjCV,EAAgBU,EAAarD,KAC7BtB,EAAgB2E,EAAa5D,KAjFI,0DAmF3BqsB,EACW,kBAAR,EAAP,SAAiC,KAAIhqB,WAAaiQ,OAAO,EAAD,IAC1DivB,EAAYx+B,QAAQ89B,EAAMxU,GArFO,iDA2F7B+U,EAAgBr+B,QAAQ89B,EAAM39B,GA3FD,yBA8FVi+B,EAAYv7B,QAAgBi7B,GA9FlB,WA+FhB,OA/FgB,yCAgG3BM,EAAYp+B,QAAQ89B,EAAMY,GAhGC,YAoG/BxiC,EAAc2D,KApGiB,kCAqG3By+B,EAAsBt+B,QAAQ89B,EAAM5hC,EAAc2D,MArGvB,yBAwG7Bs+B,EAAYn+B,QAAQ0+B,EAAaZ,GAxGJ,yBA2G7BS,EAAuBv+B,QAC3B0+B,EA3L+B,GA+EE,2DAgHnC58B,QAAQC,MAAR,oDAC+Cu7B,EAD/C,8BAhHmC,mTAqHvCx7B,QAAQqB,MAAM,6CArHyB,8FAAH,sDAwIhC27B,EAAuB,SAAC7xB,GAAD,MAC3B,iBAAkBA,GAKd8xB,EAAkB,SAAC9xB,GAAD,MACP,kBAARA,GACP,eAAgBA,GALgB,SAACA,GAAD,OAChCjO,MAAMw9B,QAAQvvB,IAAQA,EAAImhB,MAAM0Q,GAKhCE,CAA0B/xB,EAAG,aAE/B,SAAS8N,EAAgB3I,GACvB,YAAanS,IAANmS,EAGT,IAAM6sB,EAA2B,uCAAG,WAAO1gC,GAAP,yBAAArB,EAAA,6DAE5BgiC,EACY,kBAAT3gC,EAAoBA,GAAO,IAAI8B,aAAcC,OAAO/B,GACvD4gC,EACJ,QAAUD,EAAWr4B,OAAOvH,WAAa,KAAO4/B,EAC5CE,GAAe,IAAI3gC,aAAcC,OAAOygC,GANZ,SAOTxgC,OAAOC,OAAOC,OAAO,QAASugC,GAPrB,cAO5BtgC,EAP4B,OAQ5BC,EAAYC,MAAMC,KAAK,IAAIC,WAAWJ,IACtCK,EAAUJ,EACbK,KAAI,SAACC,GAAD,OAAOA,EAAEC,SAAS,IAAIC,SAAS,EAAG,QACtCC,KAAK,IAX0B,kBAY3BL,GAZ2B,2CAAH,sDAe3BkgC,EAAwB,uCAAG,WAC/BC,GAD+B,iFAAApiC,EAAA,6DAE/Bd,EAF+B,+BAEEC,IAEjCyF,QAAQqB,MAAM,qCACdrB,QAAQqB,MAAR,sCAA6Cm8B,EAA7C,MAL+B,SAMYljC,EACzCkjC,EACAlyB,KAR6B,UAMzBmyB,EANyB,OAU1BR,EAAgBQ,GAVU,sBAWvB,IAAI5+B,MAAJ,sCAC2B2+B,EAD3B,kCAXuB,cAezBE,EAAgBD,EAfS,UAkBvB9R,QAAQuL,IACZwG,EAAcxZ,WAAW5mB,IAAzB,uCAA6B,WAAOqgC,GAAP,eAAAviC,EAAA,8DAEf+C,KADNc,EAAM0+B,EAAM5+B,aAAaE,KADJ,uBAGzBe,QAAQC,MAAM,8CAHW,uBAIlB9B,GAJkB,mBAOpBc,EAPoB,SAQbk+B,EAA4BQ,EAAMlhC,MARrB,+BASnBkhC,EAAMlhC,KATa,mBAOzBwC,IAPyB,KAQzB+8B,KARyB,KASzBv/B,KATyB,mDAA7B,wDAnB2B,QAiBzBmhC,EAjByB,OAgC7B5uB,OAAOiK,GAGHojB,EAAcx+B,IAAYC,eAAe,CAC7CC,KAAM7B,EACN8B,UAAWq8B,IAEPiC,EAAcz+B,IAAYC,eAAe,CAC7CC,KAAM7B,EACN8B,UAAWs8B,IAEPiC,EAAkB1+B,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAWm8B,IAEPqC,EAAwB3+B,IAAYC,eAAe,CACvDC,KAAM7B,EACN8B,UAAWo8B,IAEPqC,EAAyB5+B,IAAYC,eAAe,CACxDC,KAAM7B,EACN8B,UAAWu8B,IAEPmC,EAAc7+B,IAAYC,eAAe,CAC7CC,KAAM7B,EACN8B,UAAWw8B,IAzDkB,kCA2DNoD,GA3DM,mIA4DvB5B,GADSF,EA3Dc,GA4DXE,KAAKxf,cACjBgf,EAAUM,EAAK78B,IA7DQ,UA8DDy9B,EAAY37B,QAAgBi7B,GA9D3B,WA+DP,QADhBW,EA9DuB,gCAgE3B38B,QAAQqB,MAAR,uBACkBm6B,EADlB,sBACuCQ,EADvC,2BAC8DW,EAD9D,MAhE2B,iDAsErBC,EAAcd,EAAK78B,IAtEE,UAwEFo9B,EAAYt7B,QAAgB67B,GAxE1B,eAyER,QADbC,EAxEqB,SAyEAA,IAAeb,GACxCh8B,QAAQC,MAAR,qDACgD28B,EADhD,aACgEC,EADhE,eACiFb,EADjF,MA1EyB,UA+EFS,EAAuB17B,QAC9C67B,GAhFyB,WA+ErBE,EA/EqB,SAoFV,OAAfD,GACe,OAAfC,GACAC,OAAO5f,SAAS2f,IA3Ue,GAqPN,2DA2F3B98B,QAAQqB,MAAR,8CAAqDu7B,EAArD,WAEsBz+B,KADlBE,EAAgBy9B,EAAKr/B,MA5FE,4CAgGIuC,YACzB49B,EACAtiC,GAlGqB,QAgGjByE,EAhGiB,OAoGvBV,EAAgBU,EAAarD,KApGN,0DAuGjBmiC,EACJ,gBAAeh/B,MAAQ,KAAId,KAAO,KAAO,KAAItD,QAAUgT,OAAO,EAAD,IAC/DivB,EAAYx+B,QAAQ89B,EAAM6B,GAzGH,mCA+GK,kBAD1BC,EAAmBn/B,IAAKC,KAAKP,KAC8B,OAArBy/B,EA/GjB,uBAgHnBj/B,MAAM,+CAAD,OACsCi/B,IAjHxB,WAoHtBh/B,YAAqBg/B,GApHC,uBAqHnBj/B,MAAM,6DAAD,OACoDi/B,IAtHtC,gBA0HU3/B,KAD/B/D,EAAgB0jC,GACJz+B,eA1HS,wBA2HzBq9B,EAAYx+B,QACV89B,EACA,iDA7HuB,iDAoIrBO,EAAgBr+B,QAAQ89B,EAAM39B,GApIT,yBAuIFi+B,EAAYv7B,QAAgBi7B,GAvI1B,WAwIR,OAxIQ,yCAyInBM,EAAYp+B,QAAQ89B,EAAMY,GAzIP,YA+IvBxiC,EAAc2D,KA/IS,kCAgJnBy+B,EAAsBt+B,QAAQ89B,EAAM5hC,EAAc2D,MAhJ/B,yBAmJrBs+B,EAAYn+B,QAAQ0+B,EAAaZ,GAnJZ,yBAsJrBS,EAAuBv+B,QAC3B0+B,EA5Y+B,GAqPN,2DA2J3B58B,QAAQC,MAAR,oDAC+Cu7B,EAD/C,8BA3J2B,iUAgK/Bx7B,QAAQqB,MAAM,qCAhKiB,mGAAH,sDAwKjB08B,EAAkB,uCAAG,WAChCC,GADgC,iCAAA5iC,EAAA,yDAEhCd,EAFgC,+BAECC,KAE7ByjC,EAAsBC,kBAJM,+BAKCD,EAAsBC,mBALvB,gEAKnBT,EALmB,2BAOpBD,EAAyBC,EAAkBljC,GAPvB,0DAS1B0F,QAAQC,MAAR,0CACqCu9B,EADrC,qBAT0B,uJAeoBr/B,IAAhD6/B,EAAsBE,sBAfM,kCAgBxB/B,EACJ6B,EAAsBE,sBACtB5jC,GAlB4B,uEAAH,sDAuBlB6jC,EAAsB,uCAAG,gDAAA/iC,EAAA,6DACpCd,EADoC,+BACHC,IAG3B+hC,EAAcz+B,IAAYC,eAAe,CAC7CC,KAAM7B,EACN8B,UAAWs8B,IAEPiC,EAAkB1+B,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAWm8B,IAETiE,EAAqB,IAAIh/B,IAZO,SAgB9Bm9B,EAAgBt5B,SAGpB,SAAC5E,EAAe29B,EAAM94B,GAEpB,IACE,IAAM9I,EAAgBuE,IAAKC,KAAKP,GAEhCa,YAA2B9E,EAAeE,GAC1C8jC,EAAmBr+B,IAAIi8B,EAAM,CAC3B7gC,KAAMf,IAER,MAAOsK,GACP1E,QAAQC,MAAR,qDACgD+7B,EADhD,oBACgEt3B,EADhE,6BACwFrG,QA9B1D,uBAmC9Bi+B,EAAYr5B,SAAsB,SAAChE,EAAK+8B,EAAM94B,GAClD,IAAInE,EAAeq/B,EAAmBt+B,IAAIk8B,QACrB79B,IAAjBY,EACFiB,QAAQC,MAAR,qDACgDhB,EADhD,qBACgE+8B,EADhE,+BAIAj9B,EAAaE,IAAMA,KA1Ca,cA6ChC83B,EAAsC,GAE1CqH,EAAmBhW,SAAQ,SAACrpB,EAAci9B,QACf79B,IAArBY,EAAaE,IACfe,QAAQC,MAAR,sDACiD+7B,EADjD,wCAIAjF,EAAchpB,KAAKhP,MArDa,kBAwD7Bg4B,GAxD6B,4CAAH,qDA2DtBsH,EAAkB,uCAAG,4BAAAjjC,EAAA,6DAC1BmhC,EAAkB1+B,IAAYC,eAAe,CACjDC,KAAM7B,EACN8B,UAAWm8B,IAHmB,SAKlBoC,EAAgBx3B,SALE,4CAKY,IALZ,iDAAH,qDAQlBu5B,EAAsB,uCAAG,WACpCvgC,GADoC,6BAAA3C,EAAA,6DAEpCd,EAFoC,+BAEHC,IAFG,SAIR4jC,EAAuB7jC,GAJf,cAI9By8B,EAJ8B,yBAK7BA,EAAc/nB,QACnB,SAAC9T,GAAD,qCAASA,EAAIC,YAAb,iBAAS,EAAU4C,YAAnB,aAAS,EAAgBye,cAAc5Y,SAAS7F,EAAKye,sBAArD,aANkC,2CAAH,sD,eChbpB+hB,IA9EK,SAAC,GAIQ,IAH3BxiB,EAG0B,EAH1BA,kBACAC,EAE0B,EAF1BA,sBAE0B,IAD1B1hB,oBAC0B,MADXC,IACW,EAC1B,EAA0BC,wBAA6B2D,GAAvD,mBAAO8B,EAAP,KAAcutB,EAAd,KACA,EAAkChzB,oBAAS,GAA3C,mBAAOgkC,EAAP,KAAkBC,EAAlB,KACA,EAAgCjkC,oBAAS,GAAzC,mBAAOkkC,EAAP,KAAiBC,EAAjB,KACA,EAA0BnkC,mBAAS,IAAnC,mBAAOqgC,EAAP,KAAc+D,EAAd,KACA,EAA0BpkC,mBAA+B,IAAzD,mBAAOmgC,EAAP,KAAckE,EAAd,KAL0B,4CAW1B,WACEhE,GADF,iBAAAz/B,EAAA,+EAKgBijC,IALhB,kDAMkCC,EAAuBzD,GANzD,OAMY9D,EANZ,OAOM4H,GAAY,GACZE,EAAS9H,GARf,wBAUM/2B,QAAQqB,MAAM,yDAVpB,yBAYU08B,EACJ,CACEE,kBAAmBliB,EACnBmiB,sBAAuBliB,GAEzB1hB,GAjBN,eAmBIqkC,GAAY,GAnBhB,UAoBgCL,EAAuBzD,GApBvD,QAoBU9D,EApBV,OAqBI8H,EAAS9H,GArBb,kDAuBIvJ,EAAS,KAAM/yB,SAvBnB,2DAX0B,sBAsC1B,IASIqkC,EAAU,yBACd,GAAIN,EACFM,EAAU,0DACL,QAAc3gC,IAAV8B,EACT6+B,EAAU,0CAAa7+B,UAClB,GAAKu+B,GAAcE,GAEnB,QAAcvgC,IAAVw8B,EAAqB,CAC9B,IAAMoE,EAAoBpE,EAAMr9B,KAAI,SAACyB,GAAD,aAClC,cAACma,EAAA,EAAD,CAEEC,mBAAoBpa,GAFtB,UACOA,EAAahC,cADpB,QAC8BgC,EAAaE,QAI7C6/B,EAAU,mCAAGC,UARbD,EAAU,+CAUZ,OACE,sBAAKn5B,UAAU,WAAf,UACE,uBAAMoG,SA3BO,SAAChR,GAAyC,IAAD,IACxDA,EAAEiR,iBACY,KAAV6uB,IACF4D,GAAa,GAzCS,oCA0CtBO,CAAUnE,IAEZ,QAAC,GAAD,EAACt2B,QAAeskB,YAAhB,gBAAuB,QAAS,yBAA0B,KAqBxD,UACE,uBAAOhuB,KAAK,SAASif,YAAY,UAAUa,SA3D3B,SAAC5f,GACrB6jC,EAAS7jC,EAAE6L,OAAOiT,UA2Dd,uBAAOhf,KAAK,cAEd,8BAAMikC,U","file":"static/js/main.b4769f10.chunk.js","sourcesContent":["/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  Accordion,\r\n  AccordionSummary,\r\n  Button,\r\n  Dialog,\r\n  DialogActions,\r\n  DialogContent,\r\n  DialogContentText,\r\n  DialogTitle,\r\n} from \"@material-ui/core\";\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { useState } from \"react\";\r\nimport { fullyLoadComponentRefFromUrl } from \"../componentStore\";\r\nimport { DownloadDataType, downloadDataWithCache } from \"../cacheUtils\";\r\n\r\nexport const DATA_PASSING_PIPELINE_URL =\r\n  \"https://raw.githubusercontent.com/Ark-kun/pipelines/b45c82e42588ee0a86b8875d1908d972275bfd2f/samples/test/data_passing.pipeline.component.yaml\";\r\nexport const GOOGLE_CLOUD_OPTIMIZER_PIPELINE_URL =\r\n  \"https://raw.githubusercontent.com/Ark-kun/pipeline_components/84e782224ff79a0690e84e7d66c93cec5089e041/components/google-cloud/Optimizer/_samples/Optimization.pipeline.component.yaml\";\r\n\r\ninterface DebugScratchProps {\r\n  componentSpec?: ComponentSpec;\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void;\r\n  downloadData: DownloadDataType;\r\n}\r\n\r\nconst DebugScratch = ({\r\n  componentSpec,\r\n  setComponentSpec,\r\n  downloadData = downloadDataWithCache\r\n}: DebugScratchProps) => {\r\n  const [message, setMessage] = useState(\"\");\r\n  const [isDialogOpen, setIsDialogOpen] = useState(false);\r\n\r\n  return (\r\n    <>\r\n      <button\r\n        type=\"button\"\r\n        onClick={(e) => {\r\n          fullyLoadComponentRefFromUrl(\r\n            DATA_PASSING_PIPELINE_URL,\r\n            downloadData\r\n          ).then(ref => setComponentSpec?.(ref.spec));\r\n        }}\r\n      >\r\n        Load Data Passing pipeline\r\n      </button>\r\n      <button\r\n        type=\"button\"\r\n        onClick={async (e) => {\r\n          fullyLoadComponentRefFromUrl(\r\n            GOOGLE_CLOUD_OPTIMIZER_PIPELINE_URL,\r\n            downloadData\r\n          ).then(ref => setComponentSpec?.(ref.spec));\r\n        }}\r\n      >\r\n        Load Google Cloud Optimizer pipeline\r\n      </button>\r\n      <button\r\n        onClick={async (e) => {\r\n          // Error: net::ERR_CERT_AUTHORITY_INVALID\r\n          const response = await fetch(\"https://IP/api/v1/pods/\", {\r\n            headers: new Headers({\r\n              Authorization: \"Bearer \",\r\n              \"Content-Type\": \"application/json; charset=utf-8\",\r\n            }),\r\n          });\r\n          const responseText = await response.text();\r\n          setMessage(responseText);\r\n        }}\r\n      >\r\n        List K8s cluster objects\r\n      </button>\r\n      <span>{message}</span>\r\n      <Accordion>\r\n        <AccordionSummary>Summary</AccordionSummary>\r\n      </Accordion>\r\n      <button\r\n        onClick={(e) => {\r\n          setIsDialogOpen(true);\r\n        }}\r\n      >\r\n        Show dialog\r\n      </button>\r\n      <Dialog\r\n        //open={open}\r\n        open={isDialogOpen}\r\n        //onClose={handleClose}\r\n        aria-labelledby=\"alert-dialog-title\"\r\n        aria-describedby=\"alert-dialog-description\"\r\n      >\r\n        <DialogTitle id=\"alert-dialog-title\">{\"Do something?\"}</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText id=\"alert-dialog-description\">\r\n            foo bar\r\n          </DialogContentText>\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button color=\"primary\" onClick={(e) => setIsDialogOpen(false)}>\r\n            Disagree\r\n          </Button>\r\n          <Button\r\n            color=\"primary\"\r\n            onClick={(e) => setIsDialogOpen(false)}\r\n            autoFocus\r\n          >\r\n            Agree\r\n          </Button>\r\n        </DialogActions>\r\n      </Dialog>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default DebugScratch;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport yaml from \"js-yaml\";\r\nimport localForage from \"localforage\";\r\nimport { DownloadDataType, downloadDataWithCache } from \"./cacheUtils\";\r\n\r\nimport {\r\n  ComponentSpec,\r\n  ComponentReference,\r\n  isValidComponentSpec,\r\n} from \"./componentSpec\";\r\n\r\n// IndexedDB: DB and table names\r\nconst DB_NAME = \"components\";\r\nconst DIGEST_TO_DATA_DB_TABLE_NAME = \"digest_to_component_data\";\r\nconst DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME = \"digest_to_component_spec\";\r\nconst DIGEST_TO_COMPONENT_NAME_DB_TABLE_NAME = \"digest_to_component_name\";\r\nconst URL_TO_DIGEST_DB_TABLE_NAME = \"url_to_digest\";\r\nconst DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME = \"digest_to_canonical_url\";\r\nconst COMPONENT_REF_LISTS_DB_TABLE_NAME = \"component_ref_lists\";\r\nconst COMPONENT_STORE_SETTINGS_DB_TABLE_NAME = \"component_store_settings\";\r\nconst FILE_STORE_DB_TABLE_NAME_PREFIX = \"file_store_\";\r\n\r\nexport interface ComponentReferenceWithSpec extends ComponentReference {\r\n  spec: ComponentSpec;\r\n  digest: string;\r\n  // If ComponentReference has digest it probably should have text as well\r\n  text: string;\r\n}\r\n\r\nexport interface ComponentReferenceWithSpecPlusData {\r\n  componentRef: ComponentReferenceWithSpec;\r\n  data: ArrayBuffer;\r\n}\r\n\r\nconst calculateHashDigestHex = async (data: string | ArrayBuffer) => {\r\n  const dataBytes =\r\n    typeof data === \"string\" ? new TextEncoder().encode(data) : data;\r\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", dataBytes);\r\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n  const hashHex = hashArray\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\");\r\n  return hashHex;\r\n};\r\n\r\nconst storeComponentSpec = async (\r\n  digest: string,\r\n  componentSpec: ComponentSpec\r\n) => {\r\n  const digestToComponentSpecDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME,\r\n  });\r\n  const digestToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  await digestToComponentSpecDb.setItem(digest, componentSpec);\r\n  if (componentSpec.name !== undefined) {\r\n    await digestToComponentNameDb.setItem(digest, componentSpec.name);\r\n  }\r\n};\r\n\r\nexport const loadComponentAsRefFromText = async (\r\n  componentText: string | ArrayBuffer\r\n): Promise<ComponentReferenceWithSpec> => {\r\n  const componentString =\r\n    typeof componentText === \"string\"\r\n      ? componentText\r\n      : new TextDecoder().decode(componentText);\r\n  const componentBytes =\r\n    typeof componentText === \"string\"\r\n      ? new TextEncoder().encode(componentText)\r\n      : componentText;\r\n\r\n  const loadedObj = yaml.load(componentString);\r\n  if (typeof loadedObj !== \"object\" || loadedObj === null) {\r\n    throw Error(`componentText is not a YAML-encoded object: ${loadedObj}`);\r\n  }\r\n  if (!isValidComponentSpec(loadedObj)) {\r\n    throw Error(\r\n      `componentText does not encode a valid pipeline component: ${loadedObj}`\r\n    );\r\n  }\r\n  const componentSpec: ComponentSpec = loadedObj;\r\n\r\n  const digest = await calculateHashDigestHex(componentBytes);\r\n  const componentRef: ComponentReferenceWithSpec = {\r\n    spec: componentSpec,\r\n    digest: digest,\r\n    text: componentString,\r\n  };\r\n  return componentRef;\r\n};\r\n\r\nexport const loadComponentFromUrlAsRef = async (\r\n  url: string,\r\n  downloadData: DownloadDataType = downloadDataWithCache\r\n): Promise<ComponentReferenceWithSpec> => {\r\n  const componentRef = await downloadData(url, loadComponentAsRefFromText);\r\n  componentRef.url = url;\r\n  return componentRef;\r\n};\r\n\r\nexport const preloadComponentReferences = async (\r\n  componentSpec: ComponentSpec,\r\n  downloadData: DownloadDataType = downloadDataWithCache,\r\n  componentMap?: Map<string, ComponentSpec>\r\n) => {\r\n  // This map is needed to improve efficiency and handle recursive components.\r\n  if (componentMap === undefined) {\r\n    componentMap = new Map<string, ComponentSpec>();\r\n  }\r\n  if (\"graph\" in componentSpec.implementation) {\r\n    for (const taskSpec of Object.values(\r\n      componentSpec.implementation.graph.tasks\r\n    )) {\r\n      const componentUrl = taskSpec.componentRef.url;\r\n      let taskComponentSpec = taskSpec.componentRef.spec;\r\n      if (taskComponentSpec === undefined) {\r\n        if (taskSpec.componentRef.text !== undefined) {\r\n          const taskComponentRef = await loadComponentFromUrlAsRef(\r\n            taskSpec.componentRef.text,\r\n            downloadData\r\n          );\r\n          taskComponentSpec = taskComponentRef.spec;\r\n        } else if (componentUrl !== undefined) {\r\n          taskComponentSpec = componentMap.get(componentUrl);\r\n          if (taskComponentSpec === undefined) {\r\n            const taskComponentRef = await loadComponentFromUrlAsRef(\r\n              componentUrl,\r\n              downloadData\r\n            );\r\n            taskComponentSpec = taskComponentRef.spec;\r\n            componentMap.set(componentUrl, taskComponentSpec);\r\n          }\r\n        }\r\n        if (taskComponentSpec === undefined) {\r\n          // TODO: Print task name here\r\n          console.error(\r\n            \"Could not get component spec for task: \",\r\n            taskSpec.componentRef\r\n          );\r\n        } else {\r\n          taskSpec.componentRef.spec = taskComponentSpec;\r\n          await preloadComponentReferences(\r\n            taskSpec.componentRef.spec,\r\n            downloadData,\r\n            componentMap\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return componentSpec;\r\n};\r\n\r\nexport const fullyLoadComponentRefFromUrl = async (\r\n  url: string,\r\n  downloadData: DownloadDataType = downloadDataWithCache\r\n): Promise<ComponentReferenceWithSpec> => {\r\n  const componentRef = await loadComponentFromUrlAsRef(url, downloadData);\r\n  const componentSpec = await preloadComponentReferences(\r\n    componentRef.spec,\r\n    downloadData\r\n  );\r\n  const newComponentRef: ComponentReferenceWithSpec = {\r\n    ...componentRef,\r\n    spec: componentSpec,\r\n  };\r\n  return newComponentRef;\r\n};\r\n\r\nexport const fullyLoadComponentRef = async (\r\n  componentRef: ComponentReference,\r\n  downloadData: DownloadDataType = downloadDataWithCache,\r\n  recursive: boolean = true\r\n): Promise<ComponentReferenceWithSpec> => {\r\n  let newComponentRef: ComponentReferenceWithSpec;\r\n  if (componentRef.spec === undefined) {\r\n    if (componentRef.text !== undefined) {\r\n      const loadedComponentRef = await loadComponentAsRefFromText(\r\n        componentRef.text\r\n      );\r\n      newComponentRef = {\r\n        ...componentRef,\r\n        spec: loadedComponentRef.spec,\r\n        digest: loadedComponentRef.digest,\r\n        text: loadedComponentRef.text,\r\n      };\r\n    } else {\r\n      if (componentRef.url !== undefined) {\r\n        const loadedComponentRef = await loadComponentFromUrlAsRef(\r\n          componentRef.url,\r\n          downloadData\r\n        );\r\n        newComponentRef = {\r\n          ...componentRef,\r\n          spec: loadedComponentRef.spec,\r\n          digest: loadedComponentRef.digest,\r\n          text: loadedComponentRef.text,\r\n        };\r\n      } else {\r\n        throw Error(\r\n          `The component reference cannot be materialized since it has no information: ${componentRef}`\r\n        );\r\n      }\r\n    }\r\n  } else {\r\n    console.warn(\"Regenerating component text from spec. Avoid this.\");\r\n    const componentText = componentSpecToYaml(componentRef.spec);\r\n    const componentDigest = await calculateHashDigestHex(componentText);\r\n    newComponentRef = {\r\n      ...componentRef,\r\n      spec: componentRef.spec,\r\n      digest: componentDigest,\r\n      text: componentText,\r\n    };\r\n  }\r\n  if (recursive) {\r\n    preloadComponentReferences(newComponentRef.spec, downloadData);\r\n  }\r\n  return newComponentRef;\r\n};\r\n\r\nexport const storeComponentText = async (\r\n  componentText: string | ArrayBuffer\r\n) => {\r\n  const componentBytes =\r\n    typeof componentText === \"string\"\r\n      ? new TextEncoder().encode(componentText)\r\n      : componentText;\r\n  const componentRef = await loadComponentAsRefFromText(\r\n    componentText\r\n  );\r\n  const digestToComponentTextDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_DATA_DB_TABLE_NAME,\r\n  });\r\n  await digestToComponentTextDb.setItem(\r\n    componentRef.digest,\r\n    componentBytes\r\n  );\r\n  await storeComponentSpec(componentRef.digest, componentRef.spec);\r\n\r\n  return componentRef;\r\n};\r\n\r\nexport const getAllComponentsAsRefs = async () => {\r\n  const digestToDataDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_DATA_DB_TABLE_NAME,\r\n  });\r\n\r\n  // TODO: Rewrite as async generator\r\n  const digestToComponentData = new Map<string, ArrayBuffer>();\r\n  await digestToDataDb.iterate<ArrayBuffer, void>(\r\n    (data, digest, iterationNumber) => {\r\n      digestToComponentData.set(digest, data);\r\n    }\r\n  );\r\n\r\n  const digestToComponentRef = new Map<string, ComponentReferenceWithSpec>(\r\n    await Promise.all(\r\n      Array.from(digestToComponentData.entries()).map(\r\n        async ([digest, data]) =>\r\n          [digest, await loadComponentAsRefFromText(data)] as const\r\n      )\r\n    )\r\n  );\r\n\r\n  await addCanonicalUrlsToComponentReferences(digestToComponentRef);\r\n\r\n  const componentRefs = Array.from(digestToComponentRef.values());\r\n  return componentRefs;\r\n};\r\n\r\nconst addCanonicalUrlsToComponentReferences = async (\r\n  digestToComponentRef: Map<string, ComponentReference>\r\n) => {\r\n  const digestToCanonicalUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME,\r\n  });\r\n  await digestToCanonicalUrlDb.iterate<string, void>(\r\n    (url, digest, iterationNumber) => {\r\n      let componentRef = digestToComponentRef.get(digest);\r\n      if (componentRef === undefined) {\r\n        console.error(\r\n          `Component db corrupted: Component with url ${url} and digest ${digest} has no content in the DB.`\r\n        );\r\n      } else {\r\n        componentRef.url = url;\r\n      }\r\n    }\r\n  );\r\n};\r\n\r\nexport const searchComponentsByName = async (name: string) => {\r\n  const componentRefs = await getAllComponentsAsRefs();\r\n  return componentRefs.filter(\r\n    (ref) => ref.spec.name?.toLowerCase().includes(name.toLowerCase()) ?? false\r\n  );\r\n};\r\n\r\nexport const storeComponentFromUrl = async (\r\n  url: string,\r\n  setUrlAsCanonical = false\r\n): Promise<ComponentReferenceWithSpec> => {\r\n  const urlToDigestDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_TO_DIGEST_DB_TABLE_NAME,\r\n  });\r\n  const digestToComponentSpecDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME,\r\n  });\r\n  const digestToDataDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_DATA_DB_TABLE_NAME,\r\n  });\r\n\r\n  const existingDigest = await urlToDigestDb.getItem<string>(url);\r\n  if (existingDigest !== null) {\r\n    const componentSpec = await digestToComponentSpecDb.getItem<ComponentSpec>(\r\n      existingDigest\r\n    );\r\n    const componentData = await digestToDataDb.getItem<ArrayBuffer>(\r\n      existingDigest\r\n    );\r\n    if (componentSpec !== null && componentData !== null) {\r\n      const componentRef: ComponentReferenceWithSpec = {\r\n        url: url,\r\n        digest: existingDigest,\r\n        spec: componentSpec,\r\n        text: new TextDecoder().decode(componentData),\r\n      };\r\n      return componentRef;\r\n    } else {\r\n      console.error(\r\n        `Component db is corrupted: Component with url ${url} was added before with digest ${existingDigest} but now has no content in the DB.`\r\n      );\r\n    }\r\n  }\r\n\r\n  // TODO: Think about whether to directly use fetch here.\r\n  const response = await fetch(url);\r\n  const componentData = await response.arrayBuffer();\r\n  const componentRef = await storeComponentText(componentData);\r\n  componentRef.url = url;\r\n  const digest = componentRef.digest;\r\n  if (digest === undefined) {\r\n    console.error(\r\n      `Cannot happen: storeComponentText has returned componentReference with digest === undefined.`\r\n    );\r\n    return componentRef;\r\n  }\r\n  if (existingDigest !== null && digest !== existingDigest) {\r\n    console.error(\r\n      `Component db is corrupted: Component with url ${url} previously had digest ${existingDigest} but now has digest ${digest}.`\r\n    );\r\n  }\r\n  const digestToCanonicalUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME,\r\n  });\r\n  const existingCanonicalUrl = await digestToCanonicalUrlDb.getItem<string>(\r\n    digest\r\n  );\r\n  if (existingCanonicalUrl === null) {\r\n    await digestToCanonicalUrlDb.setItem(digest, url);\r\n  } else {\r\n    if (url !== existingCanonicalUrl) {\r\n      console.debug(\r\n        `The component with digest \"${digest}\" is being loaded from \"${url}\", but was previously loaded from \"${existingCanonicalUrl}\".` +\r\n          (setUrlAsCanonical ? \" Changing the canonical url.\" : \"\")\r\n      );\r\n      if (setUrlAsCanonical) {\r\n        await digestToCanonicalUrlDb.setItem(digest, url);\r\n      }\r\n    }\r\n  }\r\n  // Updating the urlToDigestDb last, because it's used to check for cached entries.\r\n  // So we need to be sure that everything has been updated correctly.\r\n  await urlToDigestDb.setItem(url, digest);\r\n  return componentRef;\r\n};\r\n\r\ninterface ComponentFileEntryV2 {\r\n  componentRef: ComponentReferenceWithSpec;\r\n}\r\n\r\ninterface FileEntry {\r\n  name: string;\r\n  creationTime: Date;\r\n  modificationTime: Date;\r\n  data: ArrayBuffer;\r\n}\r\n\r\ninterface ComponentFileEntryV3\r\n  extends FileEntry,\r\n    ComponentReferenceWithSpecPlusData {}\r\n\r\nexport type ComponentFileEntry = ComponentFileEntryV3;\r\n\r\nconst makeNameUniqueByAddingIndex = (\r\n  name: string,\r\n  existingNames: Set<string>\r\n): string => {\r\n  let finalName = name;\r\n  let index = 1;\r\n  while (existingNames.has(finalName)) {\r\n    index++;\r\n    finalName = name + \" \" + index.toString();\r\n  }\r\n  return finalName;\r\n};\r\n\r\nconst writeComponentRefToFile = async (\r\n  listName: string,\r\n  fileName: string,\r\n  componentRef: ComponentReferenceWithSpec\r\n) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  const existingFile = await componentListDb.getItem<ComponentFileEntry>(\r\n    fileName\r\n  );\r\n  const currentTime = new Date();\r\n  const componentData = new TextEncoder().encode(componentRef.text);\r\n  let fileEntry: ComponentFileEntry;\r\n  if (existingFile === null) {\r\n    fileEntry = {\r\n      componentRef: componentRef,\r\n      name: fileName,\r\n      creationTime: currentTime,\r\n      modificationTime: currentTime,\r\n      data: componentData,\r\n    };\r\n  } else {\r\n    fileEntry = {\r\n      ...existingFile,\r\n      name: fileName,\r\n      modificationTime: currentTime,\r\n      data: componentData,\r\n      componentRef: componentRef,\r\n    };\r\n  }\r\n  await componentListDb.setItem(fileName, fileEntry);\r\n  return fileEntry;\r\n};\r\n\r\nconst addComponentRefToList = async (\r\n  listName: string,\r\n  componentRef: ComponentReferenceWithSpec,\r\n  fileName: string = \"Component\"\r\n) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  const existingNames = new Set<string>(await componentListDb.keys());\r\n  const uniqueFileName = makeNameUniqueByAddingIndex(fileName, existingNames);\r\n  return writeComponentRefToFile(\r\n    listName,\r\n    uniqueFileName,\r\n    componentRef\r\n  );\r\n};\r\n\r\nexport const addComponentToListByUrl = async (\r\n  listName: string,\r\n  url: string,\r\n  defaultFileName: string = \"Component\"\r\n) => {\r\n  const componentRef = await storeComponentFromUrl(url);\r\n  return addComponentRefToList(\r\n    listName,\r\n    componentRef,\r\n    componentRef.spec.name ?? defaultFileName\r\n  );\r\n};\r\n\r\nexport const addComponentToListByText = async (\r\n  listName: string,\r\n  componentText: string | ArrayBuffer,\r\n  fileName?: string,\r\n  defaultFileName: string = \"Component\"\r\n) => {\r\n  const componentRef = await storeComponentText(componentText);\r\n  return addComponentRefToList(\r\n    listName,\r\n    componentRef,\r\n    fileName ?? componentRef.spec.name ?? defaultFileName\r\n  );\r\n};\r\n\r\nexport const writeComponentToFileListFromText = async (\r\n  listName: string,\r\n  fileName: string,\r\n  componentText: string | ArrayBuffer\r\n) => {\r\n  const componentRef = await storeComponentText(componentText);\r\n  return writeComponentRefToFile(\r\n    listName,\r\n    fileName,\r\n    componentRef\r\n  );\r\n};\r\n\r\nexport const getAllComponentsFromList = async (listName: string) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  let componentRefs: ComponentReferenceWithSpec[] = [];\r\n  await componentListDb.iterate<ComponentFileEntry, void>(\r\n    (fileEntry, fileName, iterationNumber) => {\r\n      componentRefs.push(fileEntry.componentRef);\r\n    }\r\n  );\r\n  return componentRefs;\r\n};\r\n\r\nexport const getAllComponentFilesFromList = async (listName: string) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  let componentFiles = new Map<string, ComponentFileEntry>();\r\n  await componentListDb.iterate<ComponentFileEntry, void>(\r\n    (fileEntry, fileName, iterationNumber) => {\r\n      componentFiles.set(fileName, fileEntry);\r\n    }\r\n  );\r\n  return componentFiles;\r\n};\r\n\r\nexport const getComponentFileFromList = async (\r\n  listName: string,\r\n  fileName: string\r\n) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  return componentListDb.getItem<ComponentFileEntry>(fileName);\r\n};\r\n\r\nexport const deleteComponentFileFromList = async (\r\n  listName: string,\r\n  fileName: string\r\n) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  return componentListDb.removeItem(fileName);\r\n};\r\n\r\nexport const unsafeWriteFilesToList = async (listName: string, files: ComponentFileEntry[]) => {\r\n  await upgradeSingleComponentListDb(listName);\r\n  const tableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: tableName,\r\n  });\r\n  for (const file of files) {\r\n    await componentListDb.setItem(file.name, file);\r\n  }\r\n};\r\n\r\nexport const componentSpecToYaml = (componentSpec: ComponentSpec) => {\r\n  return yaml.dump(componentSpec, { lineWidth: 10000 });\r\n};\r\n\r\n// TODO: Remove the upgrade code in several weeks.\r\nconst upgradeSingleComponentListDb = async (listName: string) => {\r\n  const componentListVersionKey = \"component_list_format_version_\" + listName;\r\n  const componentStoreSettingsDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: COMPONENT_STORE_SETTINGS_DB_TABLE_NAME,\r\n  });\r\n  const componentListTableName = FILE_STORE_DB_TABLE_NAME_PREFIX + listName;\r\n  const componentListDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: componentListTableName,\r\n  });\r\n  let listFormatVersion =\r\n    (await componentStoreSettingsDb.getItem<number>(componentListVersionKey)) ??\r\n    1;\r\n  if (![1, 2, 3, 4].includes(listFormatVersion)) {\r\n    throw Error(\r\n      `upgradeComponentListDb: Unknown component list version \"${listFormatVersion}\" for the list ${listName}`\r\n    );\r\n  }\r\n  if (listFormatVersion === 1) {\r\n    console.log(`componentStore: Upgrading the component list DB ${listName}`);\r\n    const componentRefListsDb = localForage.createInstance({\r\n      name: DB_NAME,\r\n      storeName: COMPONENT_REF_LISTS_DB_TABLE_NAME,\r\n    });\r\n    const componentRefList: ComponentReferenceWithSpec[] =\r\n      (await componentRefListsDb.getItem(listName)) ?? [];\r\n\r\n    let existingNames = new Set<string>();\r\n    const emptyNameReplacement =\r\n      listName === \"user_pipelines\" ? \"Pipeline\" : \"Component\";\r\n    for (const componentRef of componentRefList) {\r\n      const fileName = componentRef.spec.name ?? emptyNameReplacement;\r\n      const uniqueFileName = makeNameUniqueByAddingIndex(\r\n        fileName,\r\n        existingNames\r\n      );\r\n      const fileEntry: ComponentFileEntryV2 = {\r\n        componentRef: componentRef,\r\n      };\r\n      await componentListDb.setItem(uniqueFileName, fileEntry);\r\n      existingNames.add(uniqueFileName);\r\n    }\r\n    await componentStoreSettingsDb.setItem(componentListVersionKey, 2);\r\n    listFormatVersion = 2;\r\n    console.log(\r\n      `componentStore: Upgraded the component list DB ${listName} to version ${listFormatVersion}`\r\n    );\r\n  }\r\n  if (listFormatVersion === 2) {\r\n    const digestToDataDb = localForage.createInstance({\r\n      name: DB_NAME,\r\n      storeName: DIGEST_TO_DATA_DB_TABLE_NAME,\r\n    });\r\n    const fileNames = await componentListDb.keys();\r\n    for (const fileName of fileNames) {\r\n      const fileEntry = await componentListDb.getItem<ComponentFileEntryV2>(\r\n        fileName\r\n      );\r\n      if (fileEntry === null) {\r\n        throw Error(`File \"${fileName}\" has disappeared during upgrade`);\r\n      }\r\n      let componentRef = fileEntry.componentRef;\r\n      let data = await digestToDataDb.getItem<ArrayBuffer>(\r\n        fileEntry.componentRef.digest\r\n      );\r\n      if (data === null) {\r\n        console.error(\r\n          `Db is corrupted: Could not find data for file \"${fileName}\" with digest ${fileEntry.componentRef.digest}.`\r\n        );\r\n        const componentText = componentSpecToYaml(fileEntry.componentRef.spec);\r\n        data = new TextEncoder().encode(componentText);\r\n        const newDigest = await calculateHashDigestHex(data);\r\n        componentRef.digest = newDigest;\r\n        console.warn(\r\n          `The component \"${fileName}\" was re-serialized. Old digest: ${fileEntry.componentRef.digest}. New digest ${newDigest}.`\r\n        );\r\n        // This case should not happen. Let's throw error for now.\r\n        throw Error(\r\n          `Db is corrupted: Could not find data for file \"${fileName}\" with digest ${fileEntry.componentRef.digest}.`\r\n        );\r\n      }\r\n      const currentTime = new Date();\r\n      const newFileEntry: ComponentFileEntryV3 = {\r\n        name: fileName,\r\n        creationTime: currentTime,\r\n        modificationTime: currentTime,\r\n        data: data,\r\n        componentRef: componentRef,\r\n      };\r\n      await componentListDb.setItem(fileName, newFileEntry);\r\n    }\r\n    listFormatVersion = 3;\r\n    await componentStoreSettingsDb.setItem(\r\n      componentListVersionKey,\r\n      listFormatVersion\r\n    );\r\n    console.log(\r\n      `componentStore: Upgraded the component list DB ${listName} to version ${listFormatVersion}`\r\n    );\r\n  }\r\n  if (listFormatVersion === 3) {\r\n    // Upgrading the DB to backfill entry.componentRef.text from entry.data\r\n    const fileNames = await componentListDb.keys();\r\n    for (const fileName of fileNames) {\r\n      const fileEntry = await componentListDb.getItem<ComponentFileEntryV3>(\r\n        fileName\r\n      );\r\n      if (fileEntry === null) {\r\n        throw Error(`File \"${fileName}\" has disappeared during upgrade`);\r\n      }\r\n      if (!fileEntry.componentRef.text) {\r\n        fileEntry.componentRef.text = new TextDecoder().decode(fileEntry.data)\r\n      }\r\n      await componentListDb.setItem(fileName, fileEntry);\r\n    }\r\n    listFormatVersion = 4;\r\n    await componentStoreSettingsDb.setItem(\r\n      componentListVersionKey,\r\n      listFormatVersion\r\n    );\r\n    console.log(\r\n      `componentStore: Upgraded the component list DB ${listName} to version ${listFormatVersion}`\r\n    );\r\n  }\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2022 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2022 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { Node, useStoreState } from \"react-flow-renderer\";\r\nimport yaml from \"js-yaml\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { componentSpecToYaml } from \"../componentStore\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\n\r\nconst SAVED_COMPONENT_SPEC_KEY = \"autosaved.component.yaml\";\r\n\r\nexport const savePipelineSpecToSessionStorage = (\r\n  componentSpec: ComponentSpec,\r\n  nodes?: Node[]\r\n) => {\r\n  try {\r\n    if (nodes !== undefined) {\r\n      if (nodes.length === 0) {\r\n        console.warn(\"saveComponentSpec: nodes.length === 0\");\r\n      }\r\n      componentSpec = augmentComponentSpec(componentSpec, nodes, true, true);\r\n    }\r\n    const componentText = componentSpecToYaml(componentSpec);\r\n    window.sessionStorage.setItem(SAVED_COMPONENT_SPEC_KEY, componentText);\r\n  } catch (err: any) {\r\n    // TODO: Find a way to avoid the React/Redux race conditions causing this error.\r\n    if (err?.message?.startsWith(\"The nodes array does not\") !== true) {\r\n      console.error(err);\r\n    }\r\n  }\r\n};\r\n\r\nexport const loadPipelineSpecFromSessionStorage = () => {\r\n  try {\r\n    const componentText = window.sessionStorage.getItem(\r\n      SAVED_COMPONENT_SPEC_KEY\r\n    );\r\n    if (componentText !== null) {\r\n      const loadedYaml = yaml.load(componentText);\r\n      if (loadedYaml !== null && typeof loadedYaml === \"object\") {\r\n        //TODO: Validate that the spec is valid\r\n        const savedComponentSpec = loadedYaml as ComponentSpec;\r\n        return savedComponentSpec;\r\n      }\r\n    }\r\n  } catch (err) {\r\n    console.error(err);\r\n  }\r\n  return undefined;\r\n};\r\n\r\n// Auto-saver is extracted to its own child component since useStoreState in the parent causes infinite re-rendering\r\n// (each render of GraphComponentSpecFlow seems to change the Redux store).\r\n// This component seems to be triggered for every node movement, so even pure layout changes are saved.\r\nexport const PipelineAutoSaver = ({\r\n  componentSpec,\r\n}: {\r\n  componentSpec: ComponentSpec;\r\n}) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n  // Fixing issue where a React error would cause all node positions to be recorded as undefined (`!<tag:yaml.org,2002:js/undefined>`)\r\n  // nodes should never be undefined in normal situation.\r\n  if (nodes !== undefined && nodes.length > 0) {\r\n    savePipelineSpecToSessionStorage(componentSpec, nodes);\r\n  }\r\n  return null;\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useEffect, useState } from 'react';\r\nimport {\r\n  ReactFlowProvider,\r\n  Controls,\r\n  Background,\r\n  MiniMap,\r\n} from 'react-flow-renderer';\r\n\r\nimport { downloadDataWithCache } from '../cacheUtils';\r\nimport { ComponentSpec } from '../componentSpec';\r\nimport GraphComponentSpecFlow, {\r\n  EMPTY_GRAPH_COMPONENT_SPEC,\r\n} from \"./GraphComponentSpecFlow\";\r\nimport Sidebar from './Sidebar';\r\nimport { getAppSettings } from '../appSettings';\r\nimport { fullyLoadComponentRefFromUrl } from \"../componentStore\";\r\nimport {\r\n  loadPipelineSpecFromSessionStorage,\r\n  PipelineAutoSaver,\r\n} from \"./PipelineAutoSaver\";\r\n\r\nimport './dnd.css';\r\n\r\nconst GRID_SIZE = 10;\r\n\r\nconst DnDFlow = () => {\r\n  const [componentSpec, setComponentSpec] = useState<ComponentSpec | undefined>();\r\n  const [appSettings] = useState(getAppSettings());\r\n\r\n  const downloadData = downloadDataWithCache;\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      const restoredComponentSpec = loadPipelineSpecFromSessionStorage();\r\n      if (restoredComponentSpec !== undefined) {\r\n        setComponentSpec(restoredComponentSpec);\r\n        return;\r\n      }\r\n      const defaultPipelineUrl = appSettings.defaultPipelineUrl;\r\n      try {\r\n        const defaultPipelineRef = await fullyLoadComponentRefFromUrl(\r\n          defaultPipelineUrl,\r\n          downloadData\r\n        );\r\n        setComponentSpec(defaultPipelineRef.spec);\r\n      } catch (err) {\r\n        console.error(\r\n          `Failed to load the default pipeline from ${defaultPipelineUrl}`\r\n        );\r\n        console.error(err);\r\n        setComponentSpec(EMPTY_GRAPH_COMPONENT_SPEC);\r\n      }\r\n    })();\r\n  }, [appSettings.defaultPipelineUrl, downloadData]);\r\n\r\n  if (componentSpec === undefined) {\r\n    return <></>;\r\n  }\r\n\r\n  return (\r\n    <div className=\"dndflow\">\r\n      <ReactFlowProvider>\r\n        <div className=\"reactflow-wrapper\">\r\n          <GraphComponentSpecFlow\r\n            componentSpec={componentSpec}\r\n            setComponentSpec={setComponentSpec}\r\n            snapToGrid={true}\r\n            snapGrid={[GRID_SIZE, GRID_SIZE]}\r\n          >\r\n            <MiniMap/>\r\n            <Controls />\r\n            <Background gap={GRID_SIZE}/>\r\n          </GraphComponentSpecFlow>\r\n        </div>\r\n        <Sidebar\r\n          componentSpec={componentSpec}\r\n          setComponentSpec={setComponentSpec}\r\n          appSettings={appSettings}\r\n          downloadData={downloadData}\r\n        />\r\n        <PipelineAutoSaver componentSpec={componentSpec}/>\r\n      </ReactFlowProvider>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DnDFlow;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { Link } from \"@material-ui/core\";\r\n\r\nfunction AppFooter() {\r\n  return (\r\n    <footer\r\n      className=\"footer\"\r\n      style={{\r\n        width: \"100%\",\r\n        height: \"30px\",\r\n        padding: \"4px\",\r\n        textAlign: \"center\",\r\n        backgroundColor: \"ghostwhite\",\r\n      }}\r\n    >\r\n      <div style={{ display: \"inline-block\" }}>\r\n        <Link\r\n          href=\"https://cloud-pipelines.net/\"\r\n          underline=\"hover\"\r\n          target=\"_blank\"\r\n          rel=\"noopener\"\r\n          style={{ margin: \"6px\" }}\r\n        >\r\n          About\r\n        </Link>\r\n        <Link\r\n          href=\"https://github.com/Cloud-Pipelines/pipeline-editor/issues\"\r\n          underline=\"hover\"\r\n          target=\"_blank\"\r\n          rel=\"noopener\"\r\n          style={{ margin: \"6px\" }}\r\n        >\r\n          Give feedback\r\n        </Link>\r\n        <Link\r\n          href=\"https://cloud-pipelines.net/privacy_policy\"\r\n          underline=\"hover\"\r\n          target=\"_blank\"\r\n          rel=\"noopener\"\r\n          style={{ margin: \"6px\" }}\r\n        >\r\n          Privacy policy\r\n        </Link>\r\n      </div>\r\n    </footer>\r\n  );\r\n}\r\n\r\nexport default AppFooter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport './App.css';\r\nimport DnDFlow from './DragNDrop/index';\r\nimport AppFooter from \"./AppFooter\"\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\" style={{ width: \"100%\", height: \"calc(100% - 30px)\" }}>\r\n      <DnDFlow />\r\n      <AppFooter />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://cra.link/PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://cra.link/PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then((registration) => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://cra.link/PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then((response) => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then((registration) => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log('No internet connection found. App is running in offline mode.');\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then((registration) => {\r\n        registration.unregister();\r\n      })\r\n      .catch((error) => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\r\nimport reportWebVitals from './reportWebVitals';\r\n//import { migrateUserData } from \"./userDataMigration\"\r\n\r\n// Migration is now disabled.\r\n// After 2 months of auto-migration, the redirect from cloud-pipelines.github.io\r\n// to cloud-pipelines.net was changed to hard redirect.\r\n// Accessing the data stored for cloud-pipelines.github.io is now impossible.\r\n// try {\r\n//   migrateUserData();\r\n// } catch (err) {\r\n//   console.error(err);\r\n// }\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://cra.link/PWA\r\nserviceWorkerRegistration.register();\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport yaml from \"js-yaml\";\r\n\r\nconst httpGetDataWithCache = async <T>(\r\n  url: string,\r\n  transformer: (buffer: ArrayBuffer) => T,\r\n  cacheName: string = \"cache\",\r\n  updateIfInCache: boolean = false\r\n): Promise<T> => {\r\n  const cache = await caches.open(cacheName);\r\n  let response = await cache.match(url);\r\n  let needToUpdateCache = false;\r\n  if (response === undefined || updateIfInCache) {\r\n    try {\r\n      const newResponse = await fetch(url);\r\n      if (!newResponse.ok) {\r\n        throw new Error(\r\n          `Network response was not OK: ${newResponse.status}: ${newResponse.statusText}`\r\n        );\r\n      }\r\n      response = newResponse;\r\n      needToUpdateCache = true;\r\n    } catch (err) {\r\n      if (response === undefined) {\r\n        throw err;\r\n      }\r\n    }\r\n  }\r\n  // Preventing TypeError: Failed to execute 'put' on 'Cache': Response body is already used\r\n  const responseForCaching = response.clone();\r\n  // Need to verify that the transformer executes with error before putting data in cache.\r\n  const result = transformer(await response.arrayBuffer());\r\n  if (needToUpdateCache) {\r\n    await cache.put(url, responseForCaching);\r\n  }\r\n  return result;\r\n};\r\n\r\nexport type DownloadDataType = <T>(\r\n  url: string,\r\n  transformer: (buffer: ArrayBuffer) => T\r\n) => Promise<T>;\r\n\r\nexport async function downloadData<T>(\r\n  url: string,\r\n  transformer: (buffer: ArrayBuffer) => T\r\n): Promise<T> {\r\n  const response = await fetch(url);\r\n  if (!response.ok) {\r\n    throw new Error(\r\n      `Network response was not OK: ${response.status}: ${response.statusText}`\r\n    );\r\n  }\r\n  const result = transformer(await response.arrayBuffer());\r\n  return result;\r\n}\r\n\r\nconst IMMUTABLE_URL_REGEXPS = [\r\n  /^https:\\/\\/raw.githubusercontent.com\\/[-A-Za-z_]+\\/[-A-Za-z_]+\\/[0-9a-fA-f]{40}\\/.*/,\r\n  /^https:\\/\\/gitlab.com\\/([-A-Za-z_]+\\/){2,}-\\/raw\\/[0-9a-fA-f]{40}\\/.*/,\r\n];\r\n\r\nexport async function downloadDataWithCache<T>(\r\n  url: string,\r\n  transformer: (buffer: ArrayBuffer) => T\r\n): Promise<T> {\r\n  const isImmutable = IMMUTABLE_URL_REGEXPS.some((regexp) => url.match(regexp));\r\n  return httpGetDataWithCache(url, transformer, \"cache\", !isImmutable);\r\n}\r\n\r\n// Data transformer functions\r\n\r\nfunction loadTextFromData(buffer: ArrayBuffer): string {\r\n  return new TextDecoder().decode(buffer);\r\n}\r\n\r\nexport function loadObjectFromJsonData(buffer: ArrayBuffer): object {\r\n  const obj = JSON.parse(loadTextFromData(buffer));\r\n  if (typeof obj === \"object\" && obj !== undefined && obj !== null) {\r\n    return obj;\r\n  }\r\n  throw Error(`Expected a JSON-encoded object, but got \"${typeof obj}\"`);\r\n}\r\n\r\nexport function loadObjectFromYamlData(buffer: ArrayBuffer): object {\r\n  const obj = yaml.load(loadTextFromData(buffer));\r\n  if (typeof obj === \"object\" && obj !== undefined && obj !== null) {\r\n    return obj;\r\n  }\r\n  throw Error(`Expected a YAML-encoded object, but got \"${typeof obj}\"`);\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nexport type MySchema = ComponentSpec;\r\nexport type TypeSpecType =\r\n  | string\r\n  | {\r\n      [k: string]: TypeSpecType;\r\n    };\r\nexport interface InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the component input specification\r\n */\r\nexport interface InputSpec extends InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  default?: string;\r\n  optional?: boolean;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the component output specification\r\n */\r\nexport interface OutputSpec extends InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by the input argument value.\r\n */\r\nexport interface InputValuePlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  inputValue: string;\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a local file path pointing to a file containing the input argument value.\r\n */\r\nexport interface InputPathPlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  inputPath: string;\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a local file path pointing to a file where the program should write its output data.\r\n */\r\nexport interface OutputPathPlaceholder {\r\n  /**\r\n   * Name of the output.\r\n   */\r\n  outputPath: string;\r\n}\r\nexport type StringOrPlaceholder =\r\n  | string\r\n  | InputValuePlaceholder\r\n  | InputPathPlaceholder\r\n  | OutputPathPlaceholder\r\n  | ConcatPlaceholder\r\n  | IfPlaceholder;\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by the concatenated values of its items.\r\n */\r\nexport interface ConcatPlaceholder {\r\n  /**\r\n   * Items to concatenate\r\n   */\r\n  concat: StringOrPlaceholder[];\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a boolean value specifying whether the caller has passed an argument for the specified optional input.\r\n */\r\nexport interface IsPresentPlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  isPresent: string;\r\n}\r\nexport type IfConditionArgumentType =\r\n  | IsPresentPlaceholder\r\n  | boolean\r\n  | string\r\n  | InputValuePlaceholder;\r\nexport type ListOfStringsOrPlaceholders = StringOrPlaceholder[];\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a boolean value specifying whether the caller has passed an argument for the specified optional input.\r\n */\r\nexport interface IfPlaceholder {\r\n  if: {\r\n    cond: IfConditionArgumentType;\r\n    then: ListOfStringsOrPlaceholders;\r\n    else?: ListOfStringsOrPlaceholders;\r\n  };\r\n}\r\nexport interface ContainerSpec {\r\n  /**\r\n   * Docker image name.\r\n   */\r\n  image: string;\r\n  /**\r\n   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided.\r\n   */\r\n  command?: StringOrPlaceholder[];\r\n  /**\r\n   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided.\r\n   */\r\n  args?: StringOrPlaceholder[];\r\n  /**\r\n   * List of environment variables to set in the container.\r\n   */\r\n  env?: {\r\n    [k: string]: StringOrPlaceholder;\r\n  };\r\n}\r\n/**\r\n * Represents the container component implementation.\r\n */\r\nexport interface ContainerImplementation {\r\n  container: ContainerSpec;\r\n}\r\nexport type ImplementationType = ContainerImplementation | GraphImplementation;\r\nexport interface MetadataSpec {\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Component specification. Describes the metadata (name, description, source), the interface (inputs and outputs) and the implementation of the component.\r\n */\r\nexport interface ComponentSpec {\r\n  name?: string;\r\n  description?: string;\r\n  inputs?: InputSpec[];\r\n  outputs?: OutputSpec[];\r\n  implementation: ImplementationType;\r\n  metadata?: MetadataSpec;\r\n}\r\n/**\r\n * Component reference. Contains information that can be used to locate and load a component by name, digest or URL\r\n */\r\nexport interface ComponentReference {\r\n  name?: string;\r\n  digest?: string;\r\n  tag?: string;\r\n  url?: string;\r\n  spec?: ComponentSpec;\r\n  // Holds unparsed component text. An alternative to spec.\r\n  // url -> data -> text -> spec\r\n  // This simplifies code due to ability to preserve the original component data corresponding to the hash digest.\r\n  // I debated whether to use data (binary) or text here and decided on text.\r\n  // ComponentSpec is usually serialized to YAML or JSON formats that are text based\r\n  // and have better support for text compared to binary data.\r\n  // Not yet in the standard.\r\n  text?: string;\r\n}\r\n/**\r\n * Represents the component argument value that comes from the graph component input.\r\n */\r\nexport interface GraphInputArgument {\r\n  /**\r\n   * References the input of the graph/pipeline.\r\n   */\r\n  graphInput: {\r\n    inputName: string;\r\n    type?: TypeSpecType;\r\n  };\r\n}\r\n/**\r\n * Represents the component argument value that comes from the output of a sibling task.\r\n */\r\nexport interface TaskOutputArgument {\r\n  /**\r\n   * References the output of a sibling task.\r\n   */\r\n  taskOutput: {\r\n    taskId: string;\r\n    outputName: string;\r\n    type?: TypeSpecType;\r\n  };\r\n}\r\nexport type ArgumentType = string | GraphInputArgument | TaskOutputArgument;\r\n/**\r\n * Pair of operands for a binary operation.\r\n */\r\nexport interface TwoArgumentOperands {\r\n  op1: ArgumentType;\r\n  op2: ArgumentType;\r\n}\r\n/**\r\n * Pair of operands for a binary logical operation.\r\n */\r\nexport interface TwoLogicalOperands {\r\n  op1: PredicateType;\r\n  op2: PredicateType;\r\n}\r\n/**\r\n * Optional configuration that specifies how the task should be executed. Can be used to set some platform-specific options.\r\n */\r\nexport type PredicateType =\r\n  | {\r\n      \"==\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"!=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \">\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \">=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"<\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"<=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      and: TwoLogicalOperands;\r\n    }\r\n  | {\r\n      or: TwoLogicalOperands;\r\n    }\r\n  | {\r\n      not: PredicateType;\r\n    };\r\n\r\n/**\r\n * Optional configuration that specifies how the task should be retried if it fails.\r\n */\r\nexport interface RetryStrategySpec {\r\n  maxRetries?: number;\r\n}\r\n/**\r\n * Optional configuration that specifies how the task execution may be skipped if the output data exist in cache.\r\n */\r\nexport interface CachingStrategySpec {\r\n  maxCacheStaleness?: string;\r\n}\r\n\r\nexport interface ExecutionOptionsSpec {\r\n  retryStrategy?: RetryStrategySpec;\r\n  cachingStrategy?: CachingStrategySpec;\r\n}\r\n/**\r\n * 'Task specification. Task is a configured component - a component supplied with arguments and other applied configuration changes.\r\n */\r\nexport interface TaskSpec {\r\n  componentRef: ComponentReference;\r\n  arguments?: {\r\n    [k: string]: ArgumentType;\r\n  };\r\n  isEnabled?: PredicateType;\r\n  executionOptions?: ExecutionOptionsSpec;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the graph component implementation. It represents a graph of component tasks connected to the upstream sources of data using the argument specifications. It also describes the sources of graph output values.\r\n */\r\nexport interface GraphSpec {\r\n  tasks: {\r\n    [k: string]: TaskSpec;\r\n  };\r\n  outputValues?: {\r\n    [k: string]: TaskOutputArgument;\r\n  };\r\n}\r\n/**\r\n * Represents the graph component implementation.\r\n */\r\nexport interface GraphImplementation {\r\n  graph: GraphSpec;\r\n}\r\n\r\n// Type guards\r\nexport const isValidComponentSpec = (obj: any): obj is ComponentSpec =>\r\n  typeof obj === \"object\" && \"implementation\" in obj;\r\n\r\nexport const isContainerImplementation = (\r\n  implementation: ImplementationType\r\n): implementation is ContainerImplementation => \"container\" in implementation;\r\n\r\nexport const isGraphImplementation = (\r\n  implementation: ImplementationType\r\n): implementation is GraphImplementation => \"graph\" in implementation;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useState } from \"react\";\r\nimport { ArgumentType, TaskSpec } from \"../componentSpec\";\r\nimport ArgumentsEditor from \"./ArgumentsEditor\";\r\n\r\ninterface ArgumentsEditorDialogProps {\r\n  taskSpec: TaskSpec;\r\n  closeEditor?: () => void;\r\n  setArguments?: (args: Record<string, ArgumentType>) => void;\r\n}\r\n\r\nconst ArgumentsEditorDialog = ({\r\n  taskSpec,\r\n  closeEditor,\r\n  setArguments,\r\n}: ArgumentsEditorDialogProps) => {\r\n  const [currentArguments, setCurrentArguments] = useState<\r\n    Record<string, ArgumentType>\r\n  >({ ...taskSpec.arguments });\r\n\r\n  const componentSpec = taskSpec.componentRef.spec;\r\n  if (componentSpec === undefined) {\r\n    console.error(\r\n      \"ArgumentsEditor called with missing taskSpec.componentRef.spec\",\r\n      taskSpec\r\n    );\r\n    return <></>;\r\n  }\r\n\r\n  return (\r\n    <form\r\n      onSubmit={async (e) => {\r\n        e.preventDefault();\r\n      }}\r\n      // Does not work\r\n      // draggable={false}\r\n      style={{\r\n        position: \"fixed\",\r\n        background: \"white\",\r\n        border: \"1px solid black\",\r\n        borderRadius: \"4px\",\r\n        padding: \"15px\",\r\n        // Does not work\r\n        // zIndex: 11,\r\n      }}\r\n    >\r\n      <legend>Input arguments for {componentSpec.name}</legend>\r\n      <ArgumentsEditor\r\n        componentSpec={componentSpec}\r\n        componentArguments={currentArguments}\r\n        setComponentArguments={setCurrentArguments}\r\n      />\r\n      <button type=\"button\" onClick={closeEditor}>\r\n        Close\r\n      </button>\r\n      <button\r\n        type=\"button\"\r\n        onClick={(e) => {\r\n          setArguments?.(currentArguments);\r\n          closeEditor?.();\r\n        }}\r\n      >\r\n        Apply\r\n      </button>\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default ArgumentsEditorDialog;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { CSSProperties, memo, useState } from 'react';\r\nimport {\r\n  ArgumentType,\r\n  InputSpec,\r\n  OutputSpec,\r\n  TaskSpec,\r\n} from '../componentSpec';\r\n\r\nimport { Handle, Position, Node, NodeProps, HandleType } from 'react-flow-renderer';\r\n\r\nimport ArgumentsEditorDialog from './ArgumentsEditorDialog';\r\n\r\nconst inputHandlePosition = Position.Top;\r\nconst outputHandlePosition = Position.Bottom;\r\n\r\ntype InputOrOutputSpec = InputSpec | OutputSpec;\r\n\r\nconst MISSING_ARGUMENT_CLASS_NAME = \"missing-argument\";\r\n\r\nconst NODE_WIDTH_IN_PX = 180;\r\n\r\nexport const isComponentTaskNode = (node: Node): node is Node<ComponentTaskNodeProps> =>\r\n  node.type === \"task\" && node.data !== undefined && \"taskSpec\" in node.data;\r\n\r\nfunction generateHandles(\r\n  ioSpecs: InputOrOutputSpec[],\r\n  handleType: HandleType,\r\n  position: Position,\r\n  idPrefix: string,\r\n  inputsWithMissingArguments?: string[],\r\n): JSX.Element[] {\r\n  let handleComponents = [];\r\n  const numHandles = ioSpecs.length;\r\n  for (let i = 0; i < numHandles; i++) {\r\n    const ioSpec = ioSpecs[i];\r\n    const id = idPrefix + ioSpec.name;\r\n    const relativePosition = (i + 1) / (numHandles + 1);\r\n    const positionPercentString = String(100 * relativePosition) + \"%\";\r\n    const style =\r\n      position === Position.Top || position === Position.Bottom\r\n        ? { left: positionPercentString }\r\n        : { top: positionPercentString };\r\n    // TODO: Handle complex type specs\r\n    const ioTypeName = ioSpec.type?.toString() ?? \"Any\";\r\n    let classNames = [`handle_${idPrefix}${ioTypeName}`.replace(/ /g, \"_\")];\r\n    const isInvalid = (inputsWithMissingArguments ?? []).includes(ioSpec.name);\r\n    if (isInvalid) {\r\n      classNames.push(MISSING_ARGUMENT_CLASS_NAME);\r\n    }\r\n    classNames = classNames.map((className) => className.replace(/ /g, \"_\"));\r\n\r\n    const [labelClasses, labelStyle] = generateLabelStyle(position, numHandles);\r\n    const handleTitle =\r\n      ioSpec.name + \" : \" + ioTypeName + \"\\n\" + (ioSpec.description || \"\");\r\n    handleComponents.push(\r\n      <Handle\r\n        key={id}\r\n        type={handleType}\r\n        position={position}\r\n        id={id}\r\n        style={style}\r\n        isConnectable={true}\r\n        title={handleTitle}\r\n        className={classNames.join(\" \")}\r\n      >\r\n        <div className={labelClasses} style={labelStyle}>\r\n          {ioSpec.name}\r\n        </div>\r\n      </Handle>\r\n    );\r\n  }\r\n  return handleComponents;\r\n}\r\n\r\n\r\nfunction generateLabelStyle(\r\n  position: Position,\r\n  numHandles: number\r\n): [string, CSSProperties] {\r\n  let maxLabelWidthPx = NODE_WIDTH_IN_PX;\r\n  // By default, we want to place the label on the same side of the handle as the handle is on the side of the node.\r\n  let labelClasses = \"label\";\r\n  // When there are too many inputs/outputs, we need to move the label so it starts from the handle.\r\n  // Based on my tests, we always want this for >4 handles (top/bottom), so the rotated default placement is never used at all.\r\n\r\n  if (position === Position.Top || position === Position.Bottom) {\r\n    if (numHandles > 1) {\r\n      // For single handle max width is the node width, while the formula would give half of that\r\n      maxLabelWidthPx = NODE_WIDTH_IN_PX / (numHandles + 1);\r\n    }\r\n    //if (numHandles > 4) {\r\n    if (maxLabelWidthPx < 35) {\r\n      maxLabelWidthPx = 50;\r\n      labelClasses += \" label-angled\";\r\n    }\r\n  } else {\r\n    maxLabelWidthPx = 60;\r\n  }\r\n\r\n  const labelStyle: CSSProperties = { maxWidth: `${maxLabelWidthPx}px` };\r\n  return [labelClasses, labelStyle];\r\n}\r\n\r\nfunction generateInputHandles(inputSpecs: InputSpec[], inputsWithInvalidArguments?: string[]): JSX.Element[] {\r\n  return generateHandles(inputSpecs, \"target\", inputHandlePosition, \"input_\", inputsWithInvalidArguments);\r\n}\r\n\r\nfunction generateOutputHandles(outputSpecs: OutputSpec[]): JSX.Element[] {\r\n  return generateHandles(outputSpecs, \"source\", outputHandlePosition, \"output_\");\r\n}\r\n\r\nexport interface ComponentTaskNodeProps {\r\n  taskSpec: TaskSpec,\r\n  taskId?: string,\r\n  setArguments?: (args: Record<string, ArgumentType>) => void;\r\n};\r\n\r\nconst ComponentTaskNode = ({ data }: NodeProps<ComponentTaskNodeProps>) => {\r\n  const [isArgumentsEditorOpen, setIsArgumentsEditorOpen] = useState(false);\r\n\r\n  const taskSpec = data.taskSpec;\r\n  const componentSpec = taskSpec.componentRef.spec;\r\n  if (componentSpec === undefined) {\r\n    return (<></>);\r\n  }\r\n\r\n  const label = componentSpec.name ?? \"<component>\";\r\n  let title = \"Task ID: \" + data.taskId;\r\n  if (componentSpec.name) {\r\n    title += \"\\nComponent: \" + componentSpec.name;\r\n  }\r\n  if (taskSpec.componentRef.url) {\r\n    title += \"\\nUrl: \" + taskSpec.componentRef.url;\r\n  }\r\n  if (taskSpec.componentRef.digest) {\r\n    title += \"\\nDigest: \" + taskSpec.componentRef.digest;\r\n  }\r\n  if (componentSpec.description) {\r\n    title += \"\\nDescription: \" + componentSpec.description;\r\n  }\r\n  const inputsWithInvalidArguments = (componentSpec.inputs ?? [])\r\n    .filter(\r\n      (inputSpec) =>\r\n        inputSpec.optional !== true &&\r\n        inputSpec.default === undefined &&\r\n        !(inputSpec.name in (taskSpec.arguments ?? {}))\r\n    )\r\n    .map((inputSpec) => inputSpec.name);\r\n  const inputHandles = generateInputHandles(componentSpec.inputs ?? [], inputsWithInvalidArguments);\r\n  const outputHandles = generateOutputHandles(componentSpec.outputs ?? []);\r\n  const handleComponents = inputHandles.concat(outputHandles);\r\n\r\n  const closeArgumentsEditor = () => {\r\n    setIsArgumentsEditorOpen(false);\r\n  }\r\n\r\n  return (\r\n    <div\r\n      onDoubleClick={() => {\r\n        setIsArgumentsEditorOpen(!isArgumentsEditorOpen);\r\n      }}\r\n      title={title}\r\n      //onContextMenu={}\r\n      //contextMenu={}\r\n    >\r\n      {label}\r\n      {handleComponents}\r\n      {isArgumentsEditorOpen && (\r\n        <ArgumentsEditorDialog\r\n          taskSpec={taskSpec}\r\n          closeEditor={closeArgumentsEditor}\r\n          setArguments={data.setArguments}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default memo(ComponentTaskNode);\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport React, { DragEvent, useState } from \"react\";\r\nimport ReactFlow, {\r\n  ArrowHeadType,\r\n  Connection,\r\n  Edge,\r\n  ElementId,\r\n  Elements,\r\n  isEdge,\r\n  isNode,\r\n  Node,\r\n  OnLoadParams,\r\n  ReactFlowProps,\r\n  XYPosition,\r\n} from \"react-flow-renderer\";\r\n\r\nimport {\r\n  ArgumentType,\r\n  ComponentSpec,\r\n  GraphInputArgument,\r\n  GraphSpec,\r\n  InputSpec,\r\n  OutputSpec,\r\n  TaskOutputArgument,\r\n  TaskSpec,\r\n  isGraphImplementation,\r\n} from \"../componentSpec\";\r\nimport { assertDefined } from \"../utils\";\r\nimport ComponentTaskNode, { ComponentTaskNodeProps, isComponentTaskNode } from \"./ComponentTaskNode\";\r\n\r\n\r\nconst NODE_LAYOUT_ANNOTATION_KEY = \"editor.position\";\r\nconst SDK_ANNOTATION_KEY = \"sdk\";\r\nconst SDK_ANNOTATION_VALUE = \"https://cloud-pipelines.net/pipeline-editor/\";\r\n\r\nexport const EMPTY_GRAPH_COMPONENT_SPEC: ComponentSpec = {\r\n  implementation: {\r\n    graph: {\r\n      tasks: {},\r\n    },\r\n  },\r\n};\r\n\r\nconst taskIdToNodeId = (id: string) => \"task_\" + id;\r\nconst inputNameToNodeId = (name: string) => \"input_\" + name;\r\nconst outputNameToNodeId = (name: string) => \"output_\" + name;\r\n\r\nconst nodeIdToTaskId = (id: string) => id.replace(/^task_/, \"\");\r\nconst nodeIdToInputName = (id: string) => id.replace(/^input_/, \"\");\r\nconst nodeIdToOutputName = (id: string) => id.replace(/^output_/, \"\");\r\n\r\nexport const augmentComponentSpec = (\r\n  componentSpec: ComponentSpec,\r\n  nodes: Node[],\r\n  includeSpecs = false,\r\n  includePositions = true\r\n) => {\r\n  componentSpec = { ...componentSpec };\r\n\r\n  const getNodePositionAnnotation = (node: Node) =>\r\n    JSON.stringify({\r\n      // node.position cannot be used since set at 1st drop and never updated\r\n      x: node.__rf.position.x,\r\n      y: node.__rf.position.y,\r\n      width: node.__rf.width,\r\n      height: node.__rf.height,\r\n    });\r\n\r\n  const nodeXPositionComparer = (n1: Node, n2: Node) => {\r\n    const deltaX = n1.__rf.position.x - n2.__rf.position.x;\r\n    const deltaY = n1.__rf.position.y - n2.__rf.position.y;\r\n    return deltaX !== 0 ? deltaX : deltaY;\r\n  };\r\n  const nodeYPositionComparer = (n1: Node, n2: Node) => {\r\n    const deltaX = n1.__rf.position.x - n2.__rf.position.x;\r\n    const deltaY = n1.__rf.position.y - n2.__rf.position.y;\r\n    return deltaY !== 0 ? deltaY : deltaX;\r\n  };\r\n\r\n  // Input and output nodes\r\n  // Sorting them by horizontal position to make reordering inputs and outputs easy.\r\n  const inputNodes = nodes\r\n    .filter((node) => node.type === \"input\")\r\n    .sort(nodeXPositionComparer);\r\n  const outputNodes = nodes\r\n    .filter((node) => node.type === \"output\")\r\n    .sort(nodeXPositionComparer);\r\n  const taskNodes = nodes\r\n    .filter(isComponentTaskNode)\r\n    .sort(nodeYPositionComparer);\r\n\r\n  const inputPositionMap = new Map<string, string>(\r\n    inputNodes.map((node) => [\r\n      nodeIdToInputName(node.id),\r\n      getNodePositionAnnotation(node),\r\n    ])\r\n  );\r\n  const inputOrderMap = new Map<string, number>(\r\n    inputNodes.map((node, index) => [nodeIdToInputName(node.id), index])\r\n  );\r\n  const inputOrderComparer = (a: InputSpec, b: InputSpec) =>\r\n    (inputOrderMap.get(a.name) ?? Infinity) -\r\n    (inputOrderMap.get(b.name) ?? Infinity);\r\n  const outputPositionMap = new Map<string, string>(\r\n    outputNodes.map((node) => [\r\n      nodeIdToOutputName(node.id),\r\n      getNodePositionAnnotation(node),\r\n    ])\r\n  );\r\n  const outputOrderMap = new Map<string, number>(\r\n    outputNodes.map((node, index) => [nodeIdToOutputName(node.id), index])\r\n  );\r\n  const outputOrderComparer = (a: OutputSpec, b: OutputSpec) =>\r\n    (outputOrderMap.get(a.name) ?? Infinity) -\r\n    (outputOrderMap.get(b.name) ?? Infinity);\r\n  const taskPositionMap = new Map<string, string>(\r\n    taskNodes.map((node) => [\r\n      nodeIdToTaskId(node.id),\r\n      getNodePositionAnnotation(node),\r\n    ])\r\n  );\r\n  const taskOrderMap = new Map<string, number>(\r\n    taskNodes.map((node, index) => [nodeIdToTaskId(node.id), index])\r\n  );\r\n  const taskOrderComparer = (\r\n    pairA: [string, TaskSpec],\r\n    pairB: [string, TaskSpec]\r\n  ) =>\r\n    (taskOrderMap.get(pairA[0]) ?? Infinity) -\r\n    (taskOrderMap.get(pairB[0]) ?? Infinity);\r\n\r\n  componentSpec.inputs = componentSpec.inputs\r\n    ?.map((inputSpec) => {\r\n      if (!inputPositionMap.has(inputSpec.name) || !inputOrderMap.has(inputSpec.name)) {\r\n        throw Error(`The nodes array does not have input node ${inputSpec.name}`);\r\n      }\r\n      let newAnnotations = { ...inputSpec.annotations };\r\n      if (includePositions) {\r\n        newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] = inputPositionMap.get(\r\n          inputSpec.name\r\n        );\r\n      } else {\r\n        delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n      }\r\n      let newInputSpec: InputSpec = {\r\n        ...inputSpec,\r\n        annotations: newAnnotations,\r\n      };\r\n      if (Object.keys(newAnnotations).length === 0) {\r\n        delete newInputSpec.annotations;\r\n      }\r\n      return newInputSpec;\r\n    })\r\n    .sort(inputOrderComparer);\r\n\r\n  componentSpec.outputs = componentSpec.outputs\r\n    ?.map((outputSpec) => {\r\n      if (!outputPositionMap.has(outputSpec.name) || !outputOrderMap.has(outputSpec.name)) {\r\n        throw Error(`The nodes array does not have output node ${outputSpec.name}`);\r\n      }\r\n      let newAnnotations = { ...outputSpec.annotations };\r\n      if (includePositions) {\r\n        newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] = outputPositionMap.get(\r\n          outputSpec.name\r\n        );\r\n      } else {\r\n        delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n      }\r\n      let newOutputSpec: OutputSpec = {\r\n        ...outputSpec,\r\n        annotations: newAnnotations,\r\n      };\r\n      if (\r\n        newAnnotations === undefined ||\r\n        Object.keys(newAnnotations).length === 0\r\n      ) {\r\n        delete newOutputSpec.annotations;\r\n      }\r\n      return newOutputSpec;\r\n    })\r\n    .sort(outputOrderComparer);\r\n\r\n  if (!isGraphImplementation(componentSpec.implementation)) {\r\n    return componentSpec;\r\n  }\r\n\r\n  let graphSpec: GraphSpec = { ...componentSpec.implementation.graph };\r\n  const newTasks = Object.fromEntries(\r\n    Object.entries(graphSpec.tasks || {})\r\n      .map(([taskId, taskSpec]) => {\r\n        if (!taskPositionMap.has(taskId) || !taskOrderMap.has(taskId)) {\r\n          throw Error(`The nodes array does not have task node ${taskId}`);\r\n        }\r\n        let newAnnotations = { ...taskSpec.annotations };\r\n        if (includePositions) {\r\n          newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] =\r\n            taskPositionMap.get(taskId);\r\n        } else {\r\n          delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n        }\r\n        let newTaskSpec: TaskSpec = {\r\n          ...taskSpec,\r\n          annotations: newAnnotations,\r\n        };\r\n        if (\r\n          newAnnotations === undefined ||\r\n          Object.keys(newAnnotations).length === 0\r\n        ) {\r\n          delete newTaskSpec.annotations;\r\n        }\r\n        // TODO: Sort the arguments based on the ordering of the component inputs.\r\n        if (\r\n          !includeSpecs &&\r\n          newTaskSpec.componentRef.spec !== undefined &&\r\n          newTaskSpec.componentRef.url !== undefined\r\n        ) {\r\n          newTaskSpec.componentRef = { ...newTaskSpec.componentRef };\r\n          delete newTaskSpec.componentRef.spec;\r\n        }\r\n        // Always deleting the text since it's not yet supported in some SDKs.\r\n        delete newTaskSpec.componentRef.text;\r\n        return [taskId, newTaskSpec] as [string, TaskSpec];\r\n      })\r\n      .sort(taskOrderComparer)\r\n  );\r\n  if (newTasks !== undefined) {\r\n    graphSpec.tasks = newTasks;\r\n  }\r\n  componentSpec = {\r\n    ...componentSpec,\r\n    implementation: { ...componentSpec.implementation, graph: graphSpec },\r\n  };\r\n\r\n  componentSpec = {\r\n    ...componentSpec,\r\n    metadata: {\r\n      ...componentSpec.metadata,\r\n      annotations: {\r\n        ...componentSpec.metadata?.annotations,\r\n        [SDK_ANNOTATION_KEY]: SDK_ANNOTATION_VALUE\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reordering the attributes and removing the undefined ones\r\n  const rebuildComponentSpec = ({\r\n    name,\r\n    description,\r\n    metadata,\r\n    inputs,\r\n    outputs,\r\n    implementation,\r\n    ...rest\r\n  }: ComponentSpec): ComponentSpec => ({\r\n    ...(name && { name: name }),\r\n    ...(description && { description: description }),\r\n    ...(metadata && { metadata: metadata }),\r\n    ...(inputs && { inputs: inputs }),\r\n    ...(outputs && { outputs: outputs }),\r\n    implementation: implementation,\r\n    ...rest,\r\n  });\r\n  componentSpec = rebuildComponentSpec(componentSpec);\r\n\r\n  return componentSpec;\r\n};\r\n\r\nconst makeNameUniqueByAddingIndex = (name: string, existingNames: Set<string>): ElementId => {\r\n  let finalName = name;\r\n  let index = 1;\r\n  while (existingNames.has(finalName)) {\r\n    index++;\r\n    finalName = name + \" \" + index.toString();\r\n  }\r\n  return finalName;\r\n};\r\n\r\nconst getUniqueInputName = (\r\n  componentSpec: ComponentSpec,\r\n  name: string = \"Input\",\r\n) => {\r\n  return makeNameUniqueByAddingIndex(\r\n    name,\r\n    new Set(componentSpec.inputs?.map((inputSpec) => inputSpec.name))\r\n  );\r\n};\r\n\r\nconst getUniqueOutputName = (\r\n  componentSpec: ComponentSpec,\r\n  name: string = \"Output\",\r\n) => {\r\n  return makeNameUniqueByAddingIndex(\r\n    name,\r\n    new Set(componentSpec.outputs?.map((outputSpec) => outputSpec.name))\r\n  );\r\n};\r\n\r\nconst getUniqueTaskName = (\r\n  graphSpec: GraphSpec,\r\n  name: string = \"Task\",\r\n) => {\r\n  return makeNameUniqueByAddingIndex(\r\n    name,\r\n    new Set(Object.keys(graphSpec.tasks))\r\n  );\r\n};\r\n\r\nexport const duplicateTasks = (\r\n  graphSpec: GraphSpec,\r\n  taskIDs: string[],\r\n  positionOffset: XYPosition\r\n) => {\r\n  const taskIdToNewTaskId = new Map<string, string>();\r\n  const existingTaskIds = new Set(Object.keys(graphSpec.tasks));\r\n  for (const taskId of taskIDs) {\r\n    // We could base the new ID on the existing task ID, but they would add more and more prefixes when duplicating.\r\n    // Better start with the original component name.\r\n    const taskSpec = graphSpec.tasks[taskId];\r\n    const newTaskIdBase = taskSpec.componentRef.spec?.name ?? taskId;\r\n    const newTaskId = makeNameUniqueByAddingIndex(\r\n      newTaskIdBase,\r\n      existingTaskIds\r\n    );\r\n    taskIdToNewTaskId.set(taskId, newTaskId);\r\n    existingTaskIds.add(newTaskId);\r\n  }\r\n  const newTasks = { ...graphSpec.tasks };\r\n  for (const taskId of taskIDs) {\r\n    const taskSpec = graphSpec.tasks[taskId];\r\n    // Deep-cloning the taskSpec\r\n    const newTaskSpec = JSON.parse(JSON.stringify(taskSpec)) as TaskSpec;\r\n    for (const argument of Object.values(newTaskSpec.arguments ?? {})) {\r\n      if (typeof argument === \"object\" && \"taskOutput\" in argument) {\r\n        argument.taskOutput.taskId =\r\n          taskIdToNewTaskId.get(argument.taskOutput.taskId) ??\r\n          argument.taskOutput.taskId;\r\n      }\r\n    }\r\n    // Setting task position\r\n    // !! FIX: We do not have the position information here. It's in the Redux store!\r\n    const nodePositionSerialized = taskSpec.annotations?.[\"editor.position\"];\r\n    if (nodePositionSerialized !== undefined) {\r\n      if (typeof nodePositionSerialized === \"string\") {\r\n        const nodePosition = JSON.parse(nodePositionSerialized);\r\n        if (typeof nodePosition === \"object\" && nodePosition) {\r\n          const newNodePosition = {\r\n            x: nodePosition.x + (positionOffset?.x ?? 0),\r\n            y: nodePosition.y + (positionOffset?.y ?? 0),\r\n          };\r\n          newTaskSpec.annotations = {\r\n            ...newTaskSpec.annotations,\r\n            \"editor.position\": JSON.stringify(newNodePosition),\r\n          };\r\n        }\r\n      }\r\n    }\r\n\r\n    const newTaskId = assertDefined(taskIdToNewTaskId.get(taskId));\r\n    newTasks[newTaskId] = newTaskSpec;\r\n  }\r\n  const newGraphSpec = { ...graphSpec, tasks: newTasks };\r\n  return newGraphSpec;\r\n};\r\n\r\nexport interface GraphComponentSpecFlowProps\r\n  extends Omit<ReactFlowProps, \"elements\"> {\r\n  componentSpec: ComponentSpec,\r\n  setComponentSpec: (componentSpec: ComponentSpec) => void,\r\n}\r\n\r\nconst nodeTypes = {\r\n  task: ComponentTaskNode,\r\n};\r\n\r\nconst GraphComponentSpecFlow = ({\r\n  children,\r\n  componentSpec = { implementation: { graph: { tasks: {} } } },\r\n  setComponentSpec,\r\n  ...rest\r\n}: GraphComponentSpecFlowProps) => {\r\n  const [reactFlowInstance, setReactFlowInstance] = useState<OnLoadParams>();\r\n\r\n  if (! ('graph' in componentSpec.implementation)) {\r\n    // Only graph components are supported\r\n    return <></>;\r\n  }\r\n  let graphSpec = componentSpec.implementation.graph;\r\n\r\n  const nodes = Object.entries(graphSpec.tasks).map<Node<ComponentTaskNodeProps>>(\r\n    ([taskId, taskSpec]) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (taskSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = taskSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n\r\n      return {\r\n        id: taskIdToNodeId(taskId),\r\n        data: {\r\n          taskSpec: taskSpec,\r\n          taskId: taskId,\r\n          setArguments: (args) => setTaskArguments(taskId, args),\r\n        },\r\n        position: position,\r\n        type: \"task\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const inputNodes = (componentSpec.inputs ?? []).map<Node>(\r\n    (inputSpec) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (inputSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = inputSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n      return {\r\n        id: inputNameToNodeId(inputSpec.name),\r\n        data: { label: inputSpec.name },\r\n        position: position,\r\n        type: \"input\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const outputNodes = (componentSpec.outputs ?? []).map<Node>(\r\n    (outputSpec) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (outputSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = outputSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n      return {\r\n        id: outputNameToNodeId(outputSpec.name),\r\n        data: { label: outputSpec.name },\r\n        position: position,\r\n        type: \"output\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const edges: Edge[] = Object.entries(graphSpec.tasks).flatMap(\r\n    ([taskId, taskSpec]) => {\r\n      return Object.entries(taskSpec.arguments ?? {}).flatMap(\r\n        ([inputName, argument]) => {\r\n          if (typeof argument === \"string\") {\r\n            return [];\r\n          }\r\n          if (\"taskOutput\" in argument) {\r\n            const taskOutput = argument.taskOutput;\r\n            const edge: Edge = {\r\n              id: `${taskOutput.taskId}_${taskOutput.outputName}-${taskId}_${inputName}`,\r\n              source: taskIdToNodeId(taskOutput.taskId),\r\n              sourceHandle: `output_${taskOutput.outputName}`,\r\n              target: taskIdToNodeId(taskId),\r\n              targetHandle: `input_${inputName}`,\r\n              arrowHeadType: ArrowHeadType.ArrowClosed,\r\n            };\r\n            return [edge];\r\n          } else if (\"graphInput\" in argument) {\r\n            const graphInput = argument.graphInput;\r\n            const edge: Edge = {\r\n              id: `Input_${graphInput.inputName}-${taskId}_${inputName}`,\r\n              source: inputNameToNodeId(graphInput.inputName),\r\n              //sourceHandle: undefined,\r\n              //sourceHandle: \"Input\",\r\n              sourceHandle: null,\r\n              target: taskIdToNodeId(taskId),\r\n              targetHandle: `input_${inputName}`,\r\n              arrowHeadType: ArrowHeadType.ArrowClosed,\r\n            };\r\n            return [edge];\r\n          } else {\r\n            console.error(\"Impossible task input argument kind: \", argument);\r\n            return [];\r\n          }\r\n        }\r\n      );\r\n    }\r\n  );\r\n\r\n  const outputEdges: Edge[] = Object.entries(graphSpec.outputValues ?? {}).map(\r\n    ([outputName, argument]) => {\r\n      const taskOutput = argument.taskOutput;\r\n      const edge: Edge = {\r\n        id: `${taskOutput.taskId}_${taskOutput.outputName}-Output_${outputName}`,\r\n        source: taskIdToNodeId(taskOutput.taskId),\r\n        sourceHandle: `output_${taskOutput.outputName}`,\r\n        target: outputNameToNodeId(outputName),\r\n        //targetHandle: undefined,\r\n        //targetHandle: \"Output\",\r\n        targetHandle: null,\r\n        arrowHeadType: ArrowHeadType.ArrowClosed,\r\n      };\r\n      return edge;\r\n    }\r\n  );\r\n\r\n  const elements = (nodes as Elements).concat(inputNodes).concat(outputNodes).concat(edges).concat(outputEdges);\r\n\r\n  const replaceComponentSpec = (newComponentSpec: ComponentSpec) => {\r\n    componentSpec = newComponentSpec;\r\n    setComponentSpec(newComponentSpec);\r\n  };\r\n\r\n  const replaceGraphSpec = (newGraphSpec: GraphSpec) => {\r\n    graphSpec = newGraphSpec;\r\n    replaceComponentSpec({ ...componentSpec, implementation: { graph: graphSpec } });\r\n  };\r\n\r\n  const setTaskArguments = (\r\n    taskId: string,\r\n    taskArguments?: Record<string, ArgumentType>,\r\n  ) => {\r\n    let newGraphSpec: GraphSpec = {\r\n      ...graphSpec,\r\n      tasks: { ...graphSpec.tasks },\r\n    };\r\n    newGraphSpec.tasks[taskId] = {\r\n      ...graphSpec.tasks[taskId],\r\n      arguments: taskArguments,\r\n    };\r\n    replaceGraphSpec(newGraphSpec);\r\n  };\r\n\r\n  const setTaskArgument = (\r\n    taskId: string,\r\n    inputName: string,\r\n    argument?: ArgumentType\r\n  ) => {\r\n    const oldTaskSpec = graphSpec.tasks[taskId];\r\n    const oldTaskSpecArguments = oldTaskSpec.arguments;\r\n    let newTaskSpecArguments: Record<string, ArgumentType> = {\r\n      ...oldTaskSpecArguments,\r\n    };\r\n    if (argument === undefined) {\r\n      delete newTaskSpecArguments[inputName];\r\n    } else {\r\n      newTaskSpecArguments[inputName] = argument;\r\n    }\r\n    setTaskArguments(taskId, newTaskSpecArguments);\r\n  };\r\n\r\n  const removeTaskArgument = (taskId: string, inputName: string) =>\r\n    setTaskArgument(taskId, inputName, undefined);\r\n\r\n  const setGraphOutputValue = (\r\n    outputName: string,\r\n    outputValue?: TaskOutputArgument\r\n  ) => {\r\n    let newGraphOutputValues = { ...graphSpec.outputValues };\r\n    if (outputValue === undefined) {\r\n      delete newGraphOutputValues[outputName];\r\n    } else {\r\n      newGraphOutputValues[outputName] = outputValue;\r\n    }\r\n    graphSpec = { ...graphSpec, outputValues: newGraphOutputValues };\r\n    replaceGraphSpec(graphSpec);\r\n  };\r\n\r\n  const removeGraphOutputValue = (outputName: string) =>\r\n    setGraphOutputValue(outputName);\r\n\r\n  const addConnection = (connection: Connection | Edge) => {\r\n    if (connection.source === null || connection.target === null) {\r\n      console.error(\r\n        \"addConnection called with missing source or target: \",\r\n        connection\r\n      );\r\n      return;\r\n    }\r\n\r\n    const targetTaskInputName = connection.targetHandle?.replace(/^input_/, \"\");\r\n    const sourceTaskOutputName = connection.sourceHandle?.replace(/^output_/, \"\");\r\n\r\n    if (sourceTaskOutputName !== undefined) {\r\n      // Source is task output\r\n      const taskOutputArgument: TaskOutputArgument = {\r\n        taskOutput: {\r\n          taskId: nodeIdToTaskId(connection.source),\r\n          outputName: sourceTaskOutputName,\r\n        },\r\n      };\r\n\r\n      if (targetTaskInputName !== undefined) {\r\n        // Target is task input\r\n        setTaskArgument(\r\n          nodeIdToTaskId(connection.target),\r\n          targetTaskInputName,\r\n          taskOutputArgument\r\n        );\r\n      } else {\r\n        // Target is graph output\r\n        setGraphOutputValue(\r\n          nodeIdToOutputName(connection.target),\r\n          taskOutputArgument\r\n        );\r\n        // TODO: Perhaps propagate type information\r\n      }\r\n    } else {\r\n      // Source is graph input\r\n      const graphInputName = nodeIdToInputName(connection.source);\r\n      const graphInputArgument: GraphInputArgument = {\r\n        graphInput: {\r\n          inputName: graphInputName,\r\n        },\r\n      };\r\n      if (targetTaskInputName !== undefined) {\r\n        // Target is task input\r\n        setTaskArgument(\r\n          nodeIdToTaskId(connection.target),\r\n          targetTaskInputName,\r\n          graphInputArgument\r\n        );\r\n        // TODO: Perhaps propagate type information\r\n      } else {\r\n        // Target is graph output\r\n        console.error(\r\n          \"addConnection: Cannot directly connect graph input to graph output: \",\r\n          connection\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  const onConnect = (params: Connection | Edge) => {\r\n    addConnection(params);\r\n  };\r\n\r\n  const removeEdge = (edge: Edge) => {\r\n    const inputName = edge.targetHandle?.replace(/^input_/, \"\");\r\n\r\n    if (inputName !== undefined) {\r\n      removeTaskArgument(nodeIdToTaskId(edge.target), inputName);\r\n    } else {\r\n      removeGraphOutputValue(nodeIdToOutputName(edge.target));\r\n    }\r\n  };\r\n\r\n  const removeComponentInput = (inputNameToRemove: string) => {\r\n    // Removing the outcoming edges\r\n    // Not really needed since react-flow sends the node's incoming and outcoming edges for deletion when a node is deleted\r\n    for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n      for (const [inputName, argument] of Object.entries(\r\n        taskSpec.arguments ?? {}\r\n      )) {\r\n        if (typeof argument !== \"string\" && \"graphInput\" in argument) {\r\n          if (argument.graphInput.inputName === inputNameToRemove) {\r\n            removeTaskArgument(taskId, inputName);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Not checking the sources of graph outputs, since they cannot be directly connected to the graph inputs\r\n\r\n    // Removing the input itself\r\n    const newInputs = (componentSpec.inputs ?? []).filter(\r\n      (inputSpec) => inputSpec.name !== inputNameToRemove\r\n    );\r\n    componentSpec = { ...componentSpec, inputs: newInputs };\r\n    replaceComponentSpec(componentSpec);\r\n  };\r\n\r\n  const removeComponentOutput = (outputNameToRemove: string) => {\r\n    removeGraphOutputValue(outputNameToRemove);\r\n    // Removing the output itself\r\n    const newOutputs = (componentSpec.outputs ?? []).filter(\r\n      (outputSpec) => outputSpec.name !== outputNameToRemove\r\n    );\r\n    componentSpec = { ...componentSpec, outputs: newOutputs };\r\n    replaceComponentSpec(componentSpec);\r\n  };\r\n\r\n  const removeTask = (taskIdToRemove: string) => {\r\n    // Removing the outcoming edges\r\n    // Not really needed since react-flow sends the node's incoming and outcoming edges for deletion when a node is deleted\r\n    for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n      for (const [inputName, argument] of Object.entries(\r\n        taskSpec.arguments ?? {}\r\n      )) {\r\n        if (typeof argument !== \"string\" && \"taskOutput\" in argument) {\r\n          if (argument.taskOutput.taskId === taskIdToRemove) {\r\n            removeTaskArgument(taskId, inputName);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Removing outcoming edges that go to graph outputs.\r\n    // ? Should we delete the outputs themselves\r\n    const newGraphOutputValues = Object.fromEntries(\r\n      Object.entries(graphSpec.outputValues ?? {}).filter(\r\n        ([_, argument]) => argument.taskOutput.taskId !== taskIdToRemove\r\n      )\r\n    );\r\n    graphSpec = { ...graphSpec, outputValues: newGraphOutputValues };\r\n\r\n    // Removing the task\r\n    let newGraphSpec: GraphSpec = {\r\n      ...graphSpec,\r\n      tasks: { ...graphSpec.tasks },\r\n    };\r\n    delete newGraphSpec.tasks[taskIdToRemove];\r\n    replaceGraphSpec(newGraphSpec);\r\n  };\r\n\r\n  const removeNode = (node: Node) => {\r\n    // TODO: Use global constants for node types\r\n    if (node.type === \"input\") {\r\n      const inputName = nodeIdToInputName(node.id);\r\n      removeComponentInput(inputName);\r\n    } else if (node.type === \"output\") {\r\n      const outputName = nodeIdToOutputName(node.id);\r\n      removeComponentOutput(outputName);\r\n    } else if (node.type === \"task\") {\r\n      const taskId = nodeIdToTaskId(node.id);\r\n      removeTask(taskId);\r\n    } else {\r\n      console.log(\"removeNode: Unexpected note type: \", node);\r\n    }\r\n  };\r\n\r\n  const onElementsRemove = (elementsToRemove: Elements) => {\r\n    for (const element of elementsToRemove) {\r\n      if (isEdge(element)) {\r\n        removeEdge(element);\r\n      }\r\n    }\r\n    for (const element of elementsToRemove) {\r\n      if (isNode(element)) {\r\n        removeNode(element);\r\n      }\r\n    }\r\n  };\r\n\r\n  const onEdgeUpdate = (oldEdge: Edge, newConnection: Connection) => {\r\n    removeEdge(oldEdge);\r\n    addConnection(newConnection);\r\n  };\r\n\r\n  const onLoad = (_reactFlowInstance: OnLoadParams) =>\r\n    setReactFlowInstance(_reactFlowInstance);\r\n\r\n  const onDragOver = (event: DragEvent) => {\r\n    event.preventDefault();\r\n    event.dataTransfer.dropEffect = \"move\";\r\n  };\r\n\r\n  const onDrop = (event: DragEvent) => {\r\n    event.preventDefault();\r\n\r\n    if (reactFlowInstance) {\r\n      const droppedData = event.dataTransfer.getData(\"application/reactflow\");\r\n      if (droppedData === \"\") {\r\n        return;\r\n      }\r\n      const droppedDataObject = JSON.parse(droppedData);\r\n      const nodeType = Object.keys(droppedDataObject)[0];\r\n      const nodeData = droppedDataObject[nodeType];\r\n\r\n      // Correcting the position using the drag point location information\r\n      let dragOffsetX = 0;\r\n      let dragOffsetY = 0;\r\n      const dragStartOffsetData = event.dataTransfer.getData(\"DragStart.offset\");\r\n      if (dragStartOffsetData !== \"\") {\r\n        const dragStartOffset = JSON.parse(dragStartOffsetData);\r\n        dragOffsetX = dragStartOffset.offsetX ?? 0;\r\n        dragOffsetY = dragStartOffset.offsetY ?? 0;\r\n      }\r\n\r\n      // Node position. Offsets should be included in projection, so that they snap to the grid.\r\n      // Otherwise the dropped nodes will be out of phase with the rest of the nodes even when snapping.\r\n      let position = reactFlowInstance.project({\r\n        x: event.clientX - dragOffsetX,\r\n        y: event.clientY - dragOffsetY,\r\n      });\r\n\r\n      const nodePosition = { x: position.x, y: position.y };\r\n      const positionAnnotations = {\r\n        \"editor.position\": JSON.stringify(nodePosition),\r\n      }\r\n      if (nodeType === \"task\") {\r\n        const taskSpec = nodeData as TaskSpec;\r\n        const mergedAnnotations = {\r\n          ...taskSpec.annotations,\r\n          ...positionAnnotations,\r\n        };\r\n        taskSpec.annotations = mergedAnnotations;\r\n        const taskSpecWithAnnotation: TaskSpec = {\r\n          ...taskSpec,\r\n          annotations: mergedAnnotations,\r\n        };\r\n        const taskId = getUniqueTaskName(\r\n          graphSpec,\r\n          taskSpec.componentRef.spec?.name ?? \"Task\"\r\n        );\r\n        graphSpec = { ...graphSpec, tasks: { ...graphSpec.tasks } };\r\n        graphSpec.tasks[taskId] = taskSpecWithAnnotation;\r\n        replaceGraphSpec(graphSpec);\r\n      } else if (nodeType === \"input\") {\r\n        const inputId = getUniqueInputName(componentSpec);\r\n        const inputSpec: InputSpec = {\r\n          name: inputId,\r\n          annotations: positionAnnotations,\r\n        };\r\n        const inputs = (componentSpec.inputs ?? []).concat([inputSpec]);\r\n        componentSpec = { ...componentSpec, inputs: inputs };\r\n        replaceComponentSpec(componentSpec);\r\n      } else if (nodeType === \"output\") {\r\n        const outputId = getUniqueOutputName(componentSpec);\r\n        const outputSpec: OutputSpec = {\r\n          name: outputId,\r\n          annotations: positionAnnotations,\r\n        };\r\n        const outputs = (componentSpec.outputs ?? []).concat([outputSpec]);\r\n        componentSpec = { ...componentSpec, outputs: outputs };\r\n        replaceComponentSpec(componentSpec);\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <ReactFlow\r\n      {...rest}\r\n      elements={elements}\r\n      nodeTypes={nodeTypes}\r\n      onConnect={onConnect}\r\n      onDragOver={onDragOver}\r\n      onDrop={onDrop}\r\n      onEdgeUpdate={onEdgeUpdate}\r\n      onElementsRemove={onElementsRemove}\r\n      onLoad={onLoad}\r\n      deleteKeyCode={\r\n        rest.deleteKeyCode ?? (isAppleOS() ? \"Backspace\" : \"Delete\")\r\n      }\r\n      multiSelectionKeyCode={\r\n        rest.multiSelectionKeyCode ?? (isAppleOS() ? \"Command\" : \"Control\")\r\n      }\r\n    >\r\n      {children}\r\n    </ReactFlow>\r\n  );\r\n};\r\n\r\nexport default GraphComponentSpecFlow;\r\n\r\nconst isAppleOS = () =>\r\n  window.navigator.platform.startsWith(\"Mac\") ||\r\n  window.navigator.platform.startsWith(\"iPhone\") ||\r\n  window.navigator.platform.startsWith(\"iPad\") ||\r\n  window.navigator.platform.startsWith(\"iPod\");\r\n","/**\r\n * @license\r\n * Copyright 2022 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2022 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nexport function assertDefined<T>(obj: T | undefined) {\r\n  if (obj === undefined) {\r\n    throw TypeError(\"Object is undefined\");\r\n  }\r\n  return obj;\r\n}\r\n\r\nexport function notUndefined<T>(x: T | undefined): x is T {\r\n  return x !== undefined;\r\n}\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { DragEvent } from \"react\";\r\n\r\nimport { ComponentReference, TaskSpec } from \"../componentSpec\";\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData(\"application/reactflow\", JSON.stringify(nodeData));\r\n  event.dataTransfer.setData(\r\n    \"DragStart.offset\",\r\n    JSON.stringify({\r\n      offsetX: event.nativeEvent.offsetX,\r\n      offsetY: event.nativeEvent.offsetY,\r\n    })\r\n  );\r\n  event.dataTransfer.effectAllowed = \"move\";\r\n};\r\n\r\ninterface DraggableComponentProps\r\n  extends React.DetailedHTMLProps<\r\n    React.HTMLAttributes<HTMLDivElement>,\r\n    HTMLDivElement\r\n  > {\r\n  componentReference: ComponentReference;\r\n}\r\n\r\nconst DraggableComponent = ({\r\n  componentReference,\r\n  ...props\r\n}: DraggableComponentProps) => {\r\n  let title = componentReference.spec?.name || \"\";\r\n  if (componentReference.url) {\r\n    title += \"\\nUrl: \" + componentReference.url;\r\n  }\r\n  if (componentReference.digest) {\r\n    title += \"\\nDigest: \" + componentReference.digest;\r\n  }\r\n  if (componentReference.spec?.description) {\r\n    title += \"\\nDescription: \" + componentReference.spec?.description;\r\n  }\r\n  return (\r\n    <div\r\n      className=\"react-flow__node react-flow__node-task sidebar-node\"\r\n      draggable\r\n      onDragStart={(event: DragEvent) => {\r\n        const taskSpec: TaskSpec = {\r\n          componentRef: componentReference,\r\n        };\r\n        return onDragStart(event, { task: taskSpec });\r\n      }}\r\n      title={title}\r\n      {...props}\r\n    >\r\n      {componentReference.spec?.name ?? \"Component\"}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DraggableComponent;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { ArgumentType, ComponentSpec, TypeSpecType } from \"../componentSpec\";\r\n\r\ninterface ArgumentsEditorProps {\r\n  componentSpec: ComponentSpec;\r\n  componentArguments: Record<string, ArgumentType>;\r\n  setComponentArguments: (args: Record<string, ArgumentType>) => void;\r\n  shrinkToWidth?: boolean;\r\n}\r\n\r\nconst getPatternForTypeSpec = (typeSpec?: TypeSpecType) => {\r\n  // TODO: Implement\r\n  return undefined;\r\n};\r\n\r\nconst typeSpecToString = (typeSpec?: TypeSpecType): string => {\r\n  if (typeSpec === undefined) {\r\n    return \"Any\";\r\n  }\r\n  if (typeof typeSpec === \"string\") {\r\n    return typeSpec;\r\n  }\r\n  return JSON.stringify(typeSpec);\r\n};\r\n\r\nconst ArgumentsEditor = ({\r\n  componentSpec,\r\n  componentArguments,\r\n  setComponentArguments,\r\n  shrinkToWidth = false,\r\n}: ArgumentsEditorProps) => {\r\n  return (\r\n    <div\r\n      className=\"highlight-invalid-inputs\"\r\n      style={{\r\n        display: \"table\",\r\n        borderSpacing: \"5px\",\r\n        // Enables shrinking the table. But also makes all columns same width regardless of the content\r\n        tableLayout: shrinkToWidth ? \"fixed\" : \"auto\",\r\n        // Width is needed for table-layout: \"fixed\" to work\r\n        width: \"100%\",\r\n      }}\r\n    >\r\n      {(componentSpec.inputs ?? []).map((inputSpec) => {\r\n        const inputName = inputSpec.name;\r\n        let value: string | undefined = undefined;\r\n        let placeholder: string | undefined = undefined;\r\n        const argument = componentArguments[inputName];\r\n        if (argument === undefined) {\r\n          value = inputSpec.default;\r\n        } else {\r\n          if (typeof argument === \"string\") {\r\n            value = argument;\r\n          } else if (\"taskOutput\" in argument) {\r\n            placeholder = `<from task ${argument.taskOutput.taskId} / ${argument.taskOutput.outputName}>`;\r\n          } else if (\"graphInput\" in argument) {\r\n            placeholder = `<from graph input ${argument.graphInput.inputName}>`;\r\n          } else {\r\n            placeholder = \"<reference>\";\r\n          }\r\n        }\r\n\r\n        const argumentIsRequiredButMissing =\r\n          !(inputName in componentArguments) &&\r\n          inputSpec.optional !== true &&\r\n          inputSpec.default === undefined;\r\n\r\n        const typeSpecString =\r\n          typeSpecToString(inputSpec.type) +\r\n          (inputSpec.optional === true ? \"?\" : \"\");\r\n\r\n        const inputTitle = `${inputName} (${typeSpecString})\\n${\r\n          inputSpec.description || \"\"\r\n        }`;\r\n\r\n        return (\r\n          <div\r\n            key={inputName}\r\n            style={{\r\n              display: \"table-row\",\r\n            }}\r\n          >\r\n            <label\r\n              title={inputTitle}\r\n              style={{\r\n                textAlign: \"right\",\r\n                display: \"table-cell\",\r\n                whiteSpace: \"nowrap\",\r\n                overflow: \"hidden\",\r\n                textOverflow: \"ellipsis\",\r\n              }}\r\n            >\r\n              <span>\r\n                {inputName} (\r\n                <span\r\n                  style={{\r\n                    textOverflow: \"ellipsis\",\r\n                    overflow: \"hidden\",\r\n                    maxWidth: \"90px\",\r\n                    display: \"inline-block\",\r\n                    verticalAlign: \"bottom\",\r\n                  }}\r\n                  title={typeSpecString}\r\n                >\r\n                  {typeSpecString}\r\n                </span>\r\n                )\r\n              </span>\r\n            </label>\r\n            <input\r\n              style={{\r\n                display: \"table-cell\",\r\n                // Prevents border flickering and disappearing on movement\r\n                borderWidth: \"1px\",\r\n                // Overriding both min-width and max-width to enable the input element shrinking\r\n                minWidth: \"50px\",\r\n                maxWidth: \"100%\",\r\n              }}\r\n              placeholder={placeholder}\r\n              required={argumentIsRequiredButMissing}\r\n              value={value ?? \"\"}\r\n              pattern={getPatternForTypeSpec(inputSpec.type)}\r\n              onChange={(e) => {\r\n                componentArguments[inputName] = e.target.value;\r\n                setComponentArguments({ ...componentArguments });\r\n              }}\r\n            />\r\n            <div\r\n              style={{\r\n                display: \"table-cell\",\r\n                // Setting explicit width to make the button column smaller. Otherwise it takes 1/3 of the total width when the table-layout is set to fixed.\r\n                // The width should have been set to \"min-content\", but that does not work for some reason\r\n                width: \"30px\",\r\n              }}\r\n            >\r\n              <button\r\n                type=\"button\"\r\n                title=\"Reset to default\"\r\n                onClick={(e) => {\r\n                  delete componentArguments[inputName];\r\n                  setComponentArguments({ ...componentArguments });\r\n                }}\r\n                disabled={!(inputName in componentArguments)}\r\n              >\r\n                \r\n              </button>\r\n            </div>\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ArgumentsEditor;\r\n","/**\r\n * @license\r\n * Copyright 2022 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2022 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\n// Settings: Default values and local storage configuration keys\r\nconst COMPONENT_LIBRARY_URL_DEFAULT_VALUE =\r\n  process.env.PUBLIC_URL + \"/component_library.yaml\";\r\nconst COMPONENT_LIBRARY_URL_LOCAL_STORAGE_KEY =\r\n  \"ComponentLibrary/component_library_url\";\r\n\r\nconst PIPELINE_LIBRARY_URL_DEFAULT_VALUE =\r\n  process.env.PUBLIC_URL + \"/pipeline_library.yaml\";\r\nconst PIPELINE_LIBRARY_URL_LOCAL_STORAGE_KEY =\r\n  \"PipelineLibrary/pipeline_library_url\";\r\n\r\n// TODO: Remove this setting in favor of taking the first pipeline from the pipeline library\r\nconst DEFAULT_PIPELINE_URL_DEFAULT_VALUE =\r\n  \"https://raw.githubusercontent.com/Ark-kun/pipelines/2edfd25b5ee3a4aa149c24a225a50041fbd3662d/components/XGBoost/_samples/sample_pipeline.pipeline.component.yaml\";\r\nconst DEFAULT_PIPELINE_URL_LOCAL_STORAGE_KEY = \"App/default_pipeline_url\";\r\n\r\nconst COMPONENT_FEED_URLS_DEFAULT_VALUE = [\r\n  \"https://raw.githubusercontent.com/Ark-kun/pipeline_components/pipeline_component_feed/pipeline_component_feed.yaml\",\r\n];\r\nconst COMPONENT_FEED_URLS_LOCAL_STORAGE_KEY =\r\n  \"ComponentSearch/component_feed_urls\";\r\n\r\nconst GITHUB_SEARCH_LOCATIONS_DEFAULT_VALUE = [\r\n  \"repo:Ark-kun/pipeline_components path:components\",\r\n];\r\nconst GITHUB_SEARCH_LOCATIONS_LOCAL_STORAGE_KEY =\r\n  \"ComponentSearch/github_search_locations\";\r\n\r\nconst GOOGLE_CLOUD_OAUTH_CLIENT_ID_DEFAULT_VALUE =\r\n  \"640001104961-2m8hs192tmd9f9nssbr5thr5o3uhmita.apps.googleusercontent.com\";\r\nconst GOOGLE_CLOUD_OAUTH_CLIENT_ID_LOCAL_STORAGE_KEY =\r\n  \"GoogleCloud/google_cloud_oauth_client_id\";\r\n\r\n// Settings interfaces and classes\r\ninterface Setting<T> {\r\n  get value(): T;\r\n  set value(value: T);\r\n  resetToDefault(): T;\r\n  isOverridden(): boolean;\r\n}\r\n\r\nabstract class SettingBackedByLocalStorage<T> implements Setting<T> {\r\n  _defaultValue: T;\r\n  _storageKey: string;\r\n\r\n  constructor(storageKey: string, defaultValue: T) {\r\n    this._defaultValue = defaultValue;\r\n    this._storageKey = storageKey;\r\n  }\r\n\r\n  get value() {\r\n    // Defensive programming.\r\n    // The window.localStorage should never be missing, null or undefined.\r\n    // And localStorage.getItem should never fail.\r\n    // However in practice there are reports of failures on the Internet for one reason or another.\r\n    // So I'm being extra cautious here.\r\n    try {\r\n      const stringValue = window.localStorage.getItem(this._storageKey);\r\n      if (stringValue !== null) {\r\n        return this.deserialize(stringValue);\r\n      }\r\n    } catch (err) {\r\n      console.error(\r\n        \"window.localStorage.getItem was unavailable or threw an exception. This should not happen.\"\r\n      );\r\n      console.error(err);\r\n    }\r\n\r\n    return this._defaultValue;\r\n  }\r\n\r\n  set value(value: T) {\r\n    const valueString = this.serialize(value);\r\n    const defaultValueString = this.serialize(this._defaultValue);\r\n    if (valueString === defaultValueString) {\r\n      window.localStorage.removeItem(this._storageKey);\r\n    } else {\r\n      window.localStorage.setItem(this._storageKey, valueString);\r\n    }\r\n  }\r\n\r\n  abstract serialize(value: T): string;\r\n  abstract deserialize(stringValue: string): T;\r\n\r\n  resetToDefault() {\r\n    window.localStorage.removeItem(this._storageKey);\r\n    return this._defaultValue;\r\n  }\r\n\r\n  isOverridden() {\r\n    return window.localStorage.getItem(this._storageKey) !== null;\r\n  }\r\n}\r\n\r\nclass StringSettingBackedByLocalStorage extends SettingBackedByLocalStorage<string> {\r\n  serialize(value: string): string {\r\n    return value;\r\n  }\r\n  deserialize(stringValue: string): string {\r\n    return stringValue;\r\n  }\r\n}\r\n\r\nclass StringArraySettingBackedByLocalStorage extends SettingBackedByLocalStorage<\r\n  string[]\r\n> {\r\n  serialize(value: string[]): string {\r\n    return JSON.stringify(value);\r\n  }\r\n  deserialize(stringValue: string): string[] {\r\n    return JSON.parse(stringValue);\r\n  }\r\n}\r\n\r\nexport interface MutableAppSettings {\r\n  componentLibraryUrl: Setting<string>;\r\n  pipelineLibraryUrl: Setting<string>;\r\n  defaultPipelineUrl: Setting<string>;\r\n  componentFeedUrls: Setting<string[]>;\r\n  gitHubSearchLocations: Setting<string[]>;\r\n  googleCloudOAuthClientId: Setting<string>;\r\n}\r\n\r\nclass AppSettingsBackedByLocalStorage implements MutableAppSettings {\r\n  componentLibraryUrl = new StringSettingBackedByLocalStorage(\r\n    COMPONENT_LIBRARY_URL_LOCAL_STORAGE_KEY,\r\n    COMPONENT_LIBRARY_URL_DEFAULT_VALUE\r\n  );\r\n  pipelineLibraryUrl = new StringSettingBackedByLocalStorage(\r\n    PIPELINE_LIBRARY_URL_LOCAL_STORAGE_KEY,\r\n    PIPELINE_LIBRARY_URL_DEFAULT_VALUE\r\n  );\r\n  defaultPipelineUrl = new StringSettingBackedByLocalStorage(\r\n    DEFAULT_PIPELINE_URL_LOCAL_STORAGE_KEY,\r\n    DEFAULT_PIPELINE_URL_DEFAULT_VALUE\r\n  );\r\n  componentFeedUrls = new StringArraySettingBackedByLocalStorage(\r\n    COMPONENT_FEED_URLS_LOCAL_STORAGE_KEY,\r\n    COMPONENT_FEED_URLS_DEFAULT_VALUE\r\n  );\r\n  gitHubSearchLocations = new StringArraySettingBackedByLocalStorage(\r\n    GITHUB_SEARCH_LOCATIONS_LOCAL_STORAGE_KEY,\r\n    GITHUB_SEARCH_LOCATIONS_DEFAULT_VALUE\r\n  );\r\n  googleCloudOAuthClientId = new StringSettingBackedByLocalStorage(\r\n    GOOGLE_CLOUD_OAUTH_CLIENT_ID_LOCAL_STORAGE_KEY,\r\n    GOOGLE_CLOUD_OAUTH_CLIENT_ID_DEFAULT_VALUE\r\n  );\r\n}\r\n\r\nexport interface AppSettings {\r\n  componentLibraryUrl: string;\r\n  pipelineLibraryUrl: string;\r\n  defaultPipelineUrl: string;\r\n  componentFeedUrls: string[];\r\n  gitHubSearchLocations: string[];\r\n  googleCloudOAuthClientId: string;\r\n}\r\n\r\nexport const getMutableAppSettings = (): MutableAppSettings =>\r\n  new AppSettingsBackedByLocalStorage();\r\n\r\nexport const getAppSettings = (): AppSettings => {\r\n  const mutableAppSettings = getMutableAppSettings();\r\n  return {\r\n    componentLibraryUrl: mutableAppSettings.componentLibraryUrl.value,\r\n    pipelineLibraryUrl: mutableAppSettings.pipelineLibraryUrl.value,\r\n    defaultPipelineUrl: mutableAppSettings.defaultPipelineUrl.value,\r\n    componentFeedUrls: mutableAppSettings.componentFeedUrls.value,\r\n    gitHubSearchLocations: mutableAppSettings.gitHubSearchLocations.value,\r\n    googleCloudOAuthClientId: mutableAppSettings.googleCloudOAuthClientId.value,\r\n  };\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\n// Manually converted from https://github.com/kubeflow/pipelines/blob/master/api/v2alpha1/pipeline_spec.proto\r\n\r\n// The spec of a pipeline job.\r\nexport interface PipelineJob {\r\n  // Name of the job.\r\n  name?: string;\r\n\r\n  // User friendly display name\r\n  displayName?: string;\r\n  // Definition of the pipeline that is being executed.\r\n  pipelineSpec: PipelineSpec;\r\n\r\n  // The labels with user-defined metadata to organize PipelineJob.\r\n  labels?: { [k: string]: string };\r\n\r\n  // Runtime config of the pipeline.\r\n  runtimeConfig: RuntimeConfig;\r\n}\r\n\r\n// The runtime config of a PipelineJob.\r\nexport interface RuntimeConfig {\r\n  // The runtime parameters of the PipelineJob. The parameters will be\r\n  // passed into [PipelineJob.pipeline_spec][] to replace the placeholders\r\n  // at runtime.\r\n  parameters?: { [k: string]: MlmdValue };\r\n\r\n  // A path in a Cloud Storage bucket which will be treated as the root\r\n  // output directory of the pipeline. It is used by the system to\r\n  // generate the paths of output artifacts.\r\n  // This is a GCP-specific optimization.\r\n  gcsOutputDirectory: string;\r\n}\r\n\r\n// The spec of a pipeline.\r\nexport interface PipelineSpec {\r\n  // The metadata of the pipeline.\r\n  pipelineInfo?: PipelineInfo;\r\n\r\n  // The deployment config of the pipeline.\r\n  // The deployment config can be extended to provide platform specific configs.\r\n  deploymentSpec: PipelineDeploymentConfig;\r\n\r\n  // The version of the sdk, which compiles the spec.\r\n  sdkVersion?: string;\r\n\r\n  // The version of the schema.\r\n  schemaVersion?: string;\r\n\r\n  // The map of name to definition of all components used in this pipeline.\r\n  components: { [k: string]: ComponentSpec };\r\n\r\n  // The definition of the main pipeline.  Execution of the pipeline is\r\n  // completed upon the completion of this component.\r\n  root: ComponentSpec;\r\n}\r\n\r\n// Definition of a component.\r\nexport interface ComponentSpec {\r\n  // Definition of the input parameters and artifacts of the component.\r\n  inputDefinitions?: ComponentInputsSpec;\r\n\r\n  // Definition of the output parameters and artifacts of the component.\r\n  outputDefinitions?: ComponentOutputsSpec;\r\n\r\n  // Either a DAG or a single execution.\r\n  //oneof implementation {\r\n  dag?: DagSpec;\r\n  executorLabel?: string;\r\n  //}\r\n}\r\n\r\n// A DAG contains multiple tasks.\r\nexport interface DagSpec {\r\n  // The tasks inside the dag.\r\n  tasks: { [k: string]: PipelineTaskSpec };\r\n\r\n  // Defines how the outputs of the dag are linked to the sub tasks.\r\n  outputs?: DagOutputsSpec;\r\n}\r\n\r\n// Definition of the output artifacts and parameters of the DAG component.\r\nexport interface DagOutputsSpec {\r\n  // Name to the output artifact channel of the DAG.\r\n  artifacts?: { [k: string]: DagOutputArtifactSpec };\r\n\r\n  // The name to the output parameter.\r\n  parameters?: { [k: string]: DagOutputParameterSpec };\r\n}\r\n\r\n// Selects a defined output artifact from a sub task of the DAG.\r\nexport interface ArtifactSelectorSpec {\r\n  // The name of the sub task which produces the output that matches with\r\n  // the `output_artifact_key`.\r\n  producerSubtask: string;\r\n\r\n  // The key of [ComponentOutputsSpec.artifacts][] map of the producer task.\r\n  outputArtifactKey: string;\r\n}\r\n\r\n// Selects a list of output artifacts that will be aggregated to the single\r\n// output artifact channel of the DAG.\r\nexport interface DagOutputArtifactSpec {\r\n  // The selected artifacts will be aggregated as output as a single\r\n  // output channel of the DAG.\r\n  artifactSelectors: ArtifactSelectorSpec[];\r\n}\r\n\r\n// Selects a defined output parameter from a sub task of the DAG.\r\nexport interface ParameterSelectorSpec {\r\n  // The name of the sub task which produces the output that matches with\r\n  // the `output_parameter_key`.\r\n  producerSubtask: string;\r\n\r\n  // The key of [ComponentOutputsSpec.parameters][] map of the producer task.\r\n  outputParameterKey: string;\r\n}\r\n\r\n// Aggregate output parameters from sub tasks into a list object.\r\nexport interface ParameterSelectorsSpec {\r\n  parameterSelectors: ParameterSelectorSpec[];\r\n}\r\n\r\n// Aggregates output parameters from sub tasks into a map object.\r\nexport interface MapParameterSelectorsSpec {\r\n  mappedParameters: { [k: string]: ParameterSelectorSpec };\r\n}\r\n\r\n// We support four ways to fan-in output parameters from sub tasks to the DAG\r\n// parent task.\r\n// 1. Directly expose a single output parameter from a sub task,\r\n// 2. (Conditional flow) Expose a list of output from multiple tasks\r\n// (some might be skipped) but allows only one of the output being generated.\r\n// 3. Expose a list of outputs from multiple tasks (e.g. iterator flow).\r\n// 4. Expose the aggregation of output parameters as a name-value map.\r\nexport type DagOutputParameterSpec =\r\n  // Returns the sub-task parameter as a DAG parameter.  The selected\r\n  // parameter must have the same type as the DAG parameter type.\r\n  | { valueFromParameter: ParameterSelectorSpec }\r\n  // Returns one of the sub-task parameters as a DAG parameter. If there are\r\n  // multiple values are available to select, the DAG will fail. All the\r\n  // selected parameters must have the same type as the DAG parameter type.\r\n  | { valueFromOneof: ParameterSelectorsSpec };\r\n\r\n// Definition specification of the component input parameters and artifacts.\r\nexport interface ComponentInputsSpec {\r\n  // Name to artifact input.\r\n  artifacts?: { [k: string]: InputArtifactSpec };\r\n\r\n  // Name to parameter input.\r\n  parameters?: { [k: string]: InputParameterSpec };\r\n}\r\n\r\n// Definition of an artifact input.\r\nexport interface InputArtifactSpec {\r\n  artifactType: ArtifactTypeSchema;\r\n}\r\n\r\n// Definition of a parameter input.\r\nexport interface InputParameterSpec {\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// Definition specification of the component output parameters and artifacts.\r\nexport interface ComponentOutputsSpec {\r\n  // Name to artifact output.\r\n  artifacts?: { [k: string]: OutputArtifactSpec };\r\n\r\n  // Name to parameter output.\r\n  parameters?: { [k: string]: OutputParameterSpec };\r\n}\r\n\r\n// Definition of an artifact output.\r\nexport interface OutputArtifactSpec {\r\n  artifactType: ArtifactTypeSchema;\r\n\r\n  // Properties of the Artifact.\r\n  metadata?: { [k: string]: any };\r\n}\r\n\r\n// Definition of a parameter output.\r\nexport interface OutputParameterSpec {\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// The spec of task inputs.\r\n//export interface TaskInputsSpec {\r\nexport interface TaskArgumentsSpec {\r\n  // A map of input parameters which are small values, stored by the system and\r\n  // can be queried.\r\n  parameters?: { [k: string]: ParameterArgumentSpec };\r\n  // A map of input artifacts.\r\n  artifacts?: { [k: string]: ArtifactArgumentSpec };\r\n}\r\n\r\n// The specification of a task input artifact.\r\n//export type InputArtifactSpec =\r\nexport type ArtifactArgumentSpec =\r\n  // Pass the input artifact from another task within the same parent\r\n  // component.\r\n  | { taskOutputArtifact: TaskOutputArtifactSpec }\r\n  // Pass the input artifact from parent component input artifact.\r\n  | { componentInputArtifact: string };\r\n\r\nexport interface TaskOutputArtifactSpec {\r\n  // The name of the upstream task which produces the output that matches\r\n  // with the `output_artifact_key`.\r\n  producerTask: string;\r\n\r\n  // The key of [TaskOutputsSpec.artifacts][] map of the producer task.\r\n  outputArtifactKey: string;\r\n}\r\n\r\n// Represents an input parameter. The value can be taken from an upstream\r\n// task's output parameter (if specifying `producer_task` and\r\n// `output_parameter_key`, or it can be a runtime value, which can either be\r\n// determined at compile-time, or from a pipeline parameter.\r\n//export interface InputParameterSpec {\r\nexport interface ParameterArgumentSpec {\r\n  //oneof kind {\r\n  // Output parameter from an upstream task.\r\n  taskOutputParameter?: TaskOutputParameterSpec;\r\n  // A constant value or runtime parameter.\r\n  runtimeValue?: ValueOrRuntimeParameter;\r\n  // Pass the input parameter from parent component input parameter.\r\n  componentInputParameter?: string;\r\n  // The final status of an upstream task.\r\n  taskFinalStatus?: TaskFinalStatus;\r\n  //}\r\n\r\n  // Selector expression of Common Expression Language (CEL)\r\n  // that applies to the parameter found from above kind.\r\n  //\r\n  // The expression is applied to the Value type\r\n  // [Value][].  For example,\r\n  // 'size(string_value)' will return the size of the Value.string_value.\r\n  //\r\n  // After applying the selection, the parameter will be returned as a\r\n  // [Value][].  The type of the Value is either deferred from the input\r\n  // definition in the corresponding\r\n  // [ComponentSpec.input_definitions.parameters][], or if not found,\r\n  // automatically deferred as either string value or double value.\r\n  //\r\n  // In addition to the builtin functions in CEL, The value.string_value can\r\n  // be treated as a json string and parsed to the [google.protobuf.Value][]\r\n  // proto message. Then, the CEL expression provided in this field will be\r\n  // used to get the requested field. For examples,\r\n  //  - if Value.string_value is a json array of \"[1.1, 2.2, 3.3]\",\r\n  //  'parseJson(string_value)[i]' will pass the ith parameter from the list\r\n  //  to the current task, or\r\n  //  - if the Value.string_value is a json map of \"{\"a\": 1.1, \"b\": 2.2,\r\n  //  \"c\": 3.3}, 'parseJson(string_value)[key]' will pass the map value from\r\n  //  the struct map to the current task.\r\n  //\r\n  // If unset, the value will be passed directly to the current task.\r\n  parameterExpressionSelector?: string;\r\n}\r\n\r\n// Represents an upstream task's output parameter.\r\nexport interface TaskOutputParameterSpec {\r\n  // The name of the upstream task which produces the output parameter that\r\n  // matches with the `output_parameter_key`.\r\n  producerTask: string;\r\n\r\n  // The key of [TaskOutputsSpec.parameters][] map of the producer task.\r\n  outputParameterKey: string;\r\n}\r\n\r\n// Represents an upstream task's final status. The field can only be set if\r\n// the schema version is `2.0.0`. The resolved input parameter will be a\r\n// json payload in string type.\r\nexport interface TaskFinalStatus {\r\n  // The name of the upsteram task where the final status is coming from.\r\n  producerTask: string;\r\n}\r\n\r\n// The spec of task outputs.\r\nexport interface TaskOutputsSpec {\r\n  // A map of output parameters which are small values, stored by the system and\r\n  // can be queried. The output key is used\r\n  // by [TaskInputsSpec.InputParameterSpec][] of the downstream task to specify\r\n  // the data dependency. The same key will also be used by\r\n  // [ExecutorInput.Inputs][] to reference the output parameter.\r\n  parameters?: { [k: string]: OutputParameterSpec };\r\n  // A map of output artifacts. Keyed by output key. The output key is used\r\n  // by [TaskInputsSpec.InputArtifactSpec][] of the downstream task to specify\r\n  // the data dependency. The same key will also be used by\r\n  // [ExecutorInput.Inputs][] to reference the output artifact.\r\n  artifacts?: { [k: string]: OutputArtifactSpec };\r\n}\r\n\r\n// The specification of a task output artifact.\r\nexport interface OutputArtifactSpec {\r\n  // The type of the artifact.\r\n  artifactType: ArtifactTypeSchema;\r\n\r\n  // The properties of the artifact, which are determined either at\r\n  // compile-time, or at pipeline submission time through runtime parameters\r\n  properties?: { [k: string]: ValueOrRuntimeParameter };\r\n\r\n  // The custom properties of the artifact, which are determined either at\r\n  // compile-time, or at pipeline submission time through runtime parameters\r\n  customProperties?: { [k: string]: ValueOrRuntimeParameter };\r\n}\r\n\r\n// Specification for output parameters produced by the task.\r\nexport interface OutputParameterSpec {\r\n  // Required field. The type of the output parameter.\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// Represent primitive types.\r\nexport enum PrimitiveTypeEnum {\r\n  PRIMITIVE_TYPE_UNSPECIFIED = \"PRIMITIVE_TYPE_UNSPECIFIED\",\r\n  INT = \"INT\",\r\n  DOUBLE = \"DOUBLE\",\r\n  STRING = \"STRING\",\r\n}\r\n\r\n// The spec of a pipeline task.\r\nexport interface PipelineTaskSpec {\r\n  // Basic info of a pipeline task.\r\n  taskInfo?: PipelineTaskInfo;\r\n\r\n  // Specification for task inputs which contains parameters and artifacts.\r\n  // <Alexey Volkov>: This should have been named: `arguments: TaskArguments`\r\n  inputs?: TaskArgumentsSpec;\r\n\r\n  // A list of names of upstream tasks that do not provide input\r\n  // artifacts for this task, but nonetheless whose completion this task depends\r\n  // on.\r\n  dependentTasks?: string[];\r\n\r\n  cachingOptions?: CachingOptions;\r\n\r\n  // Reference to a component.  Use this field to define either a DAG or an\r\n  // executor.\r\n  componentRef: ComponentRef;\r\n\r\n  // Trigger policy of the task.\r\n  triggerPolicy?: TriggerPolicy;\r\n\r\n  // Iterator supports fanning out the task into multiple sub-tasks based on the\r\n  // values of input artifact or parameter. The current task will become the\r\n  // parent of all the fan-out tasks. The output of the current task follows\r\n  // the following conventions:\r\n  // * Output artifacts with the same name of each iteration will be merged\r\n  //   into one output artifact channel of the parent iterator task.\r\n  // * Output parameters with the same name of each iteration will be merged\r\n  //   into a string output parameter with the same name with content being a\r\n  //   JSON array.\r\n  //\r\n  // For example, if an iterator starts two sub-tasks (t1 and t2) with the\r\n  // following outputs.\r\n  //\r\n  // t1.outputs.parameters = { 'p': 'v1' }\r\n  // t1.outputs.artifacts = { 'a': [a1] }\r\n  // t2.outputs.parameters = { 'p': 'v2' }\r\n  // t2.outputs.artifacts = { 'a': [a2] }\r\n  // parent_task.outputs.parameters = { 'p': '[\"v1\", \"v2\"]' }\r\n  // parent_task.outputs.artifacts = { 'a': [a1, a2] }\r\n  //oneof iterator {\r\n  // Iterator to iterate over an artifact input.\r\n  artifactIterator?: ArtifactIteratorSpec;\r\n  // Iterator to iterate over a parameter input.\r\n  parameterIterator?: ParameterIteratorSpec;\r\n  //}\r\n}\r\n\r\nexport interface CachingOptions {\r\n  // Whether or not to enable cache for this task. Defaults to false.\r\n  enableCache: boolean;\r\n}\r\n\r\n// Trigger policy defines how the task gets triggered. If a task is not\r\n// triggered, it will run into SKIPPED state.\r\nexport interface TriggerPolicy {\r\n  // An expression which will be evaluated into a boolean value. True to\r\n  // trigger the task to run. The expression follows the language of\r\n  // [CEL Spec][https://github.com/google/cel-spec]. It can access the data\r\n  // from [ExecutorInput][] message of the task.\r\n  // For example:\r\n  // - `inputs.artifacts['model'][0].properties['accuracy']*100 > 90`\r\n  // - `inputs.parameters['type'] == 'foo' && inputs.parameters['num'] == 1`\r\n  condition: string;\r\n\r\n  // The trigger strategy of this task.  The `strategy` and `condition` are\r\n  // in logic \"AND\", as a task will only be tested for the `condition` when\r\n  // the `strategy` is meet.\r\n  // Unset or set to default value of TRIGGER_STRATEGY_UNSPECIFIED behaves the\r\n  // same as ALL_UPSTREAM_TASKS_SUCCEEDED.\r\n  strategy: TriggerStrategy;\r\n}\r\n\r\n// An enum defines the trigger strategy of when the task will be ready to be\r\n// triggered.\r\n// ALL_UPSTREAM_TASKS_SUCCEEDED - all upstream tasks in succeeded state.\r\n// ALL_UPSTREAM_TASKS_COMPLETED - all upstream tasks in any final state.\r\n// (Note that CANCELLED is also a final state but job will not trigger new\r\n// tasks when job is in CANCELLING state, so that the task with the trigger\r\n// policy at ALL_UPSTREAM_TASKS_COMPLETED will not start when job\r\n// cancellation is in progress.)\r\nenum TriggerStrategy {\r\n  // Unspecified.  Behave the same as ALL_UPSTREAM_TASKS_SUCCEEDED.\r\n  TRIGGER_STRATEGY_UNSPECIFIED = \"TRIGGER_STRATEGY_UNSPECIFIED\",\r\n  // Specifies that all upstream tasks are in succeeded state.\r\n  ALL_UPSTREAM_TASKS_SUCCEEDED = \"ALL_UPSTREAM_TASKS_SUCCEEDED\",\r\n  // Specifies that all upstream tasks are in any final state.\r\n  ALL_UPSTREAM_TASKS_COMPLETED = \"ALL_UPSTREAM_TASKS_COMPLETED\",\r\n}\r\n\r\n// The spec of an artifact iterator. It supports fan-out a workflow from a list\r\n// of artifacts.\r\nexport interface ArtifactIteratorSpec {\r\n  // The items to iterate.\r\n  items: ArtifactItemsSpec;\r\n  // The name of the input artifact channel which has the artifact item from the\r\n  // [items][] collection.\r\n  itemInput: string;\r\n}\r\n// Specifies the name of the artifact channel which contains the collection of\r\n// items to iterate. The iterator will create a sub-task for each item of\r\n// the collection and pass the item as a new input artifact channel as\r\n// specified by [item_input][].\r\nexport interface ArtifactItemsSpec {\r\n  // The name of the input artifact.\r\n  inputArtifact: string;\r\n}\r\n\r\n// The spec of a parameter iterator. It supports fan-out a workflow from a\r\n// string parameter which contains a JSON array.\r\nexport interface ParameterIteratorSpec {\r\n  // The items to iterate.\r\n  items: ParameterItemsSpec;\r\n  // The name of the input parameter which has the item value from the\r\n  // [items][] collection.\r\n  itemInput: string;\r\n}\r\n\r\n// Specifies the spec to describe the parameter items to iterate.\r\nexport type ParameterItemsSpec =\r\n  // Specifies where to get the collection of items to iterate. The iterator\r\n  // will create a sub-task for each item of the collection and pass the item\r\n  // as a new input parameter as specified by [item_input][].\r\n  // The raw JSON array.\r\n  | { raw: string }\r\n  // The name of the input parameter whose value has the items collection.\r\n  // The parameter must be in STRING type and its content can be parsed\r\n  // as a JSON array.\r\n  | { input_parameter: string };\r\n\r\nexport interface ComponentRef {\r\n  // The name of a component. Refer to the key of the\r\n  // [PipelineSpec.components][] map.\r\n  name: string;\r\n}\r\n\r\n// Basic info of a pipeline.\r\nexport interface PipelineInfo {\r\n  // Required field. The name of the pipeline.\r\n  // The name will be used to create or find pipeline context in MLMD.\r\n  name: string;\r\n}\r\n\r\n// The definition of a artifact type in MLMD.\r\nexport type ArtifactTypeSchema =\r\n  // The name of the type. The format of the title must be:\r\n  // `<namespace>.<title>.<version>`.\r\n  // Examples:\r\n  //  - `aiplatform.Model.v1`\r\n  //  - `acme.CustomModel.v2`\r\n  // When this field is set, the export type must be pre-registered in the MLMD\r\n  // store.\r\n  | { schemaTitle: string }\r\n\r\n  // Points to a YAML file stored on Google Cloud Storage describing the\r\n  // format.\r\n  | { schemaUri: string }\r\n\r\n  // Contains a raw YAML string, describing the format of\r\n  // the properties of the type.\r\n  | { instanceSchema: string };\r\n\r\n// The basic info of a task.\r\nexport interface PipelineTaskInfo {\r\n  // The unique name of the task within the pipeline definition. This name\r\n  // will be used in downstream tasks to indicate task and data dependencies.\r\n  // <Alexey Volkov>: This ^^^ does not seem to be true. This name seems to be used only as display name.\r\n  name: string;\r\n}\r\n\r\n// Definition for a value or reference to a runtime parameter. A\r\n// ValueOrRuntimeParameter instance can be either a field value that is\r\n// determined during compilation time, or a runtime parameter which will be\r\n// determined during runtime.\r\nexport type ValueOrRuntimeParameter =\r\n  // Constant value which is determined in compile time.\r\n  | { constantValue: MlmdValue }\r\n  // The runtime parameter refers to the parent component input parameter.\r\n  | { runtimeParameter: string };\r\n\r\nexport type MlmdValue =\r\n  | {\r\n      stringValue: string;\r\n    }\r\n  | {\r\n      intValue: number;\r\n    }\r\n  | {\r\n      doubleValue: number;\r\n    };\r\n\r\n// The definition of the deployment config of the pipeline. It contains the\r\n// the platform specific executor configs for KFP OSS.\r\nexport interface PipelineDeploymentConfig {\r\n  // Map from executor label to executor spec.\r\n  executors: { [k: string]: ExecutorSpec };\r\n}\r\n\r\n// The specification on a container invocation.\r\n// The string fields of the message support string based placeholder contract\r\n// defined in [ExecutorInput](). The output of the container follows the\r\n// contract of [ExecutorOutput]().\r\nexport interface PipelineContainerSpec {\r\n  // The image uri of the container.\r\n  image: string;\r\n  // The main entrypoint commands of the container to run. If not provided,\r\n  // fallback to use the entry point command defined in the container image.\r\n  command?: string[];\r\n  // The arguments to pass into the main entrypoint of the container.\r\n  args?: string[];\r\n\r\n  // The lifecycle hooks of the container executor.\r\n  // lifecycle: Lifecycle;\r\n\r\n  resources?: ResourceSpec;\r\n\r\n  // Environment variables to be passed to the container.\r\n  env?: EnvVar[];\r\n}\r\n\r\n// The specification on the resource requirements of a container execution.\r\n// This can include specification of vCPU, memory requirements, as well as\r\n// accelerator types and counts.\r\nexport interface ResourceSpec {\r\n  // The limit of the number of vCPU cores. This container execution needs\r\n  // at most cpu_limit vCPU to run.\r\n  cpuLimit: number;\r\n\r\n  // The memory limit in GB. This container execution needs at most\r\n  // memory_limit RAM to run.\r\n  memoryLimit: number;\r\n\r\n  accelerator: AcceleratorConfig;\r\n}\r\n\r\n// Environment variables to be passed to the container.\r\n// Represents an environment variable present in a container.\r\nexport interface EnvVar {\r\n  // Name of the environment variable. Must be a valid C identifier. It can\r\n  // be composed of characters such as uppercase, lowercase characters,\r\n  // underscore, digits, but the leading character should be either a\r\n  // letter or an underscore.\r\n  name: string;\r\n\r\n  // Variables that reference a $(VAR_NAME) are expanded using the previous\r\n  // defined environment variables in the container and any environment\r\n  // variables defined by the platform runtime that executes this pipeline.\r\n  // If a variable cannot be resolved, the reference in the input string\r\n  // will be unchanged. The $(VAR_NAME) syntax can be escaped with a double\r\n  // $$, ie: $$(VAR_NAME). Escaped references will never be expanded,\r\n  // regardless of whether the variable exists or not.\r\n  value: string;\r\n}\r\n\r\n// The specification of the executor.\r\nexport type ExecutorSpec =\r\n  // Starts a container.\r\n  { container: PipelineContainerSpec };\r\n// Import an artifact.\r\n//| { importer: ImporterSpec }\r\n// Resolves an existing artifact.\r\n//| { resolver: ResolverSpec }\r\n// Starts a Google Cloud AI Platform CustomJob.\r\n//| { custom_job: AIPlatformCustomJobSpec };\r\n\r\n// The specification on the accelerators being attached to this container.\r\nexport interface AcceleratorConfig {\r\n  // The type of accelerators.\r\n  type: string;\r\n  // The number of accelerators.\r\n  count: number;\r\n}\r\n\r\n// Missing: Lifecycle\r\n// Missing: ImporterSpec\r\n// Missing: ResolverSpec\r\n// Missing: RuntimeArtifact\r\n// Missing: ArtifactList\r\n// Missing: ExecutorInput\r\n// Missing: ExecutorOutput\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  ArgumentType,\r\n  ComponentSpec,\r\n  StringOrPlaceholder,\r\n  TypeSpecType,\r\n  isContainerImplementation,\r\n  isGraphImplementation,\r\n  InputSpec,\r\n} from \"../../componentSpec\";\r\n\r\nimport * as vertex from \"./vertexPipelineSpec\";\r\n\r\n// # How to handle I/O:\r\n// Rules (might have exceptions)\r\n// output = output artifact\r\n// inputValue => input parameter\r\n// inputPath => input artifact\r\n// # Fixing conflicts:\r\n// 1) Artifact (may only come from task output) is consumed as value.\r\n//   Solution 1) (implemented): Change input from parameter to artifact and use the input.artifact.value placeholder.\r\n//      Cons: The downstream component input definitions depend on arguments. (Some inputs are changed from parameter to artifact.)\r\n//   Solution 2): Add parameter output (with the same name as the artifact output) to the upstream component. The paths should be the same, so a single file will be treated as both parameter and output.\r\n//      Cons: The upstream component output definitions depend on downstream consumption style. (Although parameter outputs are added, not changed.)\r\n//   Solution 3): Insert a \"Downloader\" task between upstream and downstream.\r\n//      Cons: Extra container task\r\n// 2) Parameter (pipeline input or constant value) is consumed as artifact (as file).\r\n//   Solution 1): Insert a \"Uploader\" task to convert parameter to artifact.\r\n//      Cons: Extra container task\r\n\r\nconst sanitizePipelineInfoName = (pipelineContextName: string) => {\r\n  return pipelineContextName.toLowerCase().replace(/\\W/, \"-\");\r\n};\r\n\r\ntype ResolvedCommandLineAndArgs = {\r\n  command?: string[];\r\n  args?: string[];\r\n  env?: Record<string, string>;\r\n  inputsConsumedAsParameter: Set<string>;\r\n  inputsConsumedAsArtifact: Set<string>;\r\n};\r\n\r\nconst resolveCommandLine = (\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>\r\n): ResolvedCommandLineAndArgs => {\r\n  if (!isContainerImplementation(componentSpec.implementation)) {\r\n    throw Error(\"resolveCommandLine only supports container components\");\r\n  }\r\n  const containerSpec = componentSpec.implementation.container;\r\n\r\n  const inputsConsumedAsParameter = new Set<string>();\r\n  const inputsConsumedAsArtifact = new Set<string>();\r\n  const convertArg = (arg: StringOrPlaceholder): string[] => {\r\n    if (typeof arg == \"string\") {\r\n      return [arg];\r\n    } else if (\"inputValue\" in arg) {\r\n      const inputName = arg.inputValue;\r\n      if (!inputsThatHaveParameterArguments.has(inputName)) {\r\n        // ! Important details:\r\n        // In this branch, the argument comes from task output (or graph input with artifact argument).\r\n        // All outputs are artifacts by default, so this argument is an artifact argument.\r\n        // We can either try to change the argument to parameter or make the input to be an artifact to solve the conflict.\r\n        // I choose to make the input to be artifact.\r\n        // Adding input name to inputsConsumedAsPath to make the input rendered as an artifact input.\r\n        inputsConsumedAsArtifact.add(inputName);\r\n        return [`{{$.inputs.artifacts['${inputName}'].value}}`];\r\n      } else {\r\n        inputsConsumedAsParameter.add(inputName);\r\n        return [`{{$.inputs.parameters['${inputName}']}}`];\r\n      }\r\n    } else if (\"inputPath\" in arg) {\r\n      const inputName = arg.inputPath;\r\n      inputsConsumedAsArtifact.add(inputName);\r\n      return [`{{$.inputs.artifacts['${inputName}'].path}}`];\r\n    } else if (\"outputPath\" in arg) {\r\n      const outputName = arg.outputPath;\r\n      return [`{{$.outputs.artifacts['${outputName}'].path}}`];\r\n    } else if (\"if\" in arg) {\r\n      const [ifCond, ifThen, ifElse] = [arg.if.cond, arg.if.then, arg.if.else];\r\n      // TODO: Check false values, not just check for true\r\n      let condEvaluatesToTrue = false;\r\n      if (typeof ifCond === \"string\") {\r\n        condEvaluatesToTrue = ifCond.toLowerCase() === \"true\";\r\n      } else if (typeof ifCond === \"boolean\") {\r\n        condEvaluatesToTrue = ifCond;\r\n      } else if (\"isPresent\" in ifCond) {\r\n        const inputName = ifCond.isPresent;\r\n        condEvaluatesToTrue = inputName in taskArguments;\r\n      } else if (\"inputValue\" in ifCond) {\r\n        const inputName = ifCond.inputValue;\r\n        if (!(inputName in taskArguments)) {\r\n          condEvaluatesToTrue = false;\r\n        } else {\r\n          const taskArgument = taskArguments[inputName];\r\n          if (typeof taskArgument === \"string\") {\r\n            condEvaluatesToTrue = taskArgument.toLowerCase() === \"true\";\r\n          } else {\r\n            throw Error(\r\n              \"Using runtime conditions in component command line placeholders is not supported yet.\"\r\n            );\r\n          }\r\n        }\r\n      } else {\r\n        throw Error(\"Unexpected condition kind: \" + ifCond);\r\n      }\r\n      const unresolvedArgs = condEvaluatesToTrue ? ifThen : ifElse;\r\n      if (unresolvedArgs === undefined) {\r\n        return [];\r\n      }\r\n      return unresolvedArgs.flatMap(convertArg);\r\n    } else if (\"concat\" in arg) {\r\n      const concatArgs = arg.concat;\r\n      return [concatArgs.flatMap(convertArg).join(\"\")];\r\n    } else {\r\n      throw Error(`Unknown kind of command-line argument: ${arg}`);\r\n    }\r\n  };\r\n\r\n  const envValues =\r\n    containerSpec.env &&\r\n    Object.fromEntries(\r\n      Object.entries(containerSpec.env).map(([key, value]) => {\r\n        const resolvedArgArray = convertArg(value);\r\n        if (resolvedArgArray.length !== 1) {\r\n          throw Error(\r\n            `Environment variable value must resolve to a single value, but got ${resolvedArgArray}`\r\n          );\r\n        }\r\n        const resolvedValue = resolvedArgArray[0];\r\n        return [key, resolvedValue];\r\n      })\r\n    );\r\n\r\n  const result: ResolvedCommandLineAndArgs = {\r\n    command: containerSpec.command?.flatMap(convertArg),\r\n    args: containerSpec.args?.flatMap(convertArg),\r\n    env: envValues,\r\n    inputsConsumedAsParameter: inputsConsumedAsParameter,\r\n    inputsConsumedAsArtifact: inputsConsumedAsArtifact,\r\n  };\r\n  return result;\r\n};\r\n\r\nconst typeSpecToVertexPrimitiveTypeEnum = (\r\n  typeSpec: TypeSpecType | undefined\r\n): vertex.PrimitiveTypeEnum => {\r\n  if (typeof typeSpec === \"string\") {\r\n    if ([\"integer\"].includes(typeSpec.toLowerCase())) {\r\n      return vertex.PrimitiveTypeEnum.INT;\r\n    }\r\n    if ([\"float\", \"double\"].includes(typeSpec.toLowerCase())) {\r\n      return vertex.PrimitiveTypeEnum.DOUBLE;\r\n    }\r\n  }\r\n  return vertex.PrimitiveTypeEnum.STRING;\r\n};\r\n\r\nconst typeSpecToVertexParameterSpec = (\r\n  typeSpec: TypeSpecType | undefined\r\n): vertex.InputParameterSpec => {\r\n  return {\r\n    type: typeSpecToVertexPrimitiveTypeEnum(typeSpec),\r\n  };\r\n};\r\n\r\nconst typeSpecToVertexArtifactTypeSchema = (\r\n  typeSpec: TypeSpecType | undefined\r\n): vertex.ArtifactTypeSchema => {\r\n  // TODO: Implement better mapping\r\n  const artifactTypeSchema = {\r\n    schemaTitle: \"system.Artifact\",\r\n  };\r\n  return artifactTypeSchema;\r\n};\r\n\r\nconst typeSpecToVertexArtifactSpec = (\r\n  typeSpec: TypeSpecType | undefined\r\n): vertex.InputArtifactSpec => {\r\n  return {\r\n    artifactType: typeSpecToVertexArtifactTypeSchema(typeSpec),\r\n  };\r\n};\r\n// const typeSpecToVertexArtifactType(typeSpec: TypeSpecType) => {\r\n//     return typeof typeSpec === \"string\" && [\"String\", \"Integer\", \"Float\", \"Double\", \"Boolean\", ]\r\n// }\r\n\r\nconst stringToMlmdValue = (\r\n  constantString: string,\r\n  primitiveType: vertex.PrimitiveTypeEnum\r\n): vertex.MlmdValue => {\r\n  switch (primitiveType) {\r\n    case vertex.PrimitiveTypeEnum.STRING:\r\n      return {\r\n        stringValue: constantString,\r\n      };\r\n    case vertex.PrimitiveTypeEnum.INT:\r\n      return {\r\n        intValue: parseInt(constantString),\r\n      };\r\n    case vertex.PrimitiveTypeEnum.DOUBLE:\r\n      return {\r\n        doubleValue: parseFloat(constantString),\r\n      };\r\n    default:\r\n      throw Error(`Unknown primitive type ${primitiveType}`);\r\n  }\r\n};\r\n\r\nconst MAKE_ARTIFACT_COMPONENT_ID = \"_make_artifact\";\r\nconst MAKE_ARTIFACT_EXECUTOR_ID = \"_make_artifact\";\r\nconst MAKE_ARTIFACT_INPUT_NAME = \"parameter\";\r\nconst MAKE_ARTIFACT_OUTPUT_NAME = \"artifact\";\r\n\r\nconst buildMakeArtifactTaskSpec = (\r\n  parameterArgumentSpec: vertex.ParameterArgumentSpec\r\n): vertex.PipelineTaskSpec => {\r\n  const taskSpec: vertex.PipelineTaskSpec = {\r\n    componentRef: {\r\n      name: MAKE_ARTIFACT_COMPONENT_ID,\r\n    },\r\n    taskInfo: {\r\n      name: \"Make artifact\",\r\n    },\r\n    inputs: {\r\n      parameters: {\r\n        [MAKE_ARTIFACT_INPUT_NAME]: parameterArgumentSpec,\r\n      },\r\n    },\r\n    cachingOptions: {\r\n      enableCache: true,\r\n    },\r\n  };\r\n  return taskSpec;\r\n};\r\n\r\nconst makeArtifactComponentSpec: vertex.ComponentSpec = {\r\n  executorLabel: MAKE_ARTIFACT_EXECUTOR_ID,\r\n  inputDefinitions: {\r\n    parameters: {\r\n      [MAKE_ARTIFACT_INPUT_NAME]: {\r\n        type: vertex.PrimitiveTypeEnum.STRING,\r\n      },\r\n    },\r\n  },\r\n  outputDefinitions: {\r\n    artifacts: {\r\n      [MAKE_ARTIFACT_OUTPUT_NAME]: {\r\n        artifactType: {\r\n          schemaTitle: \"system.Artifact\",\r\n        },\r\n      },\r\n    },\r\n  },\r\n};\r\n\r\nconst makeArtifactExecutorSpec: vertex.ExecutorSpec = {\r\n  container: {\r\n    image: \"alpine\",\r\n    command: [\r\n      \"sh\",\r\n      \"-ec\",\r\n      'mkdir -p \"$(dirname \"$1\")\"; printf \"%s\" \"$0\" > \"$1\"',\r\n      `{{$.inputs.parameters['${MAKE_ARTIFACT_INPUT_NAME}']}}`,\r\n      `{{$.outputs.artifacts['${MAKE_ARTIFACT_OUTPUT_NAME}'].path}}`,\r\n    ],\r\n  },\r\n};\r\n\r\nfunction buildVertexParameterArgumentSpec(\r\n  taskArgument: ArgumentType | undefined,\r\n  inputSpec: InputSpec\r\n) {\r\n  if (taskArgument === undefined) {\r\n    if (inputSpec.default !== undefined) {\r\n      taskArgument = inputSpec.default;\r\n    } else {\r\n      if (inputSpec.optional === true) {\r\n        // TODO: Decide what the behavior should be\r\n        // throw Error(`Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`);\r\n        console.error(\r\n          `Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`\r\n        );\r\n        taskArgument = \"\";\r\n      } else {\r\n        throw Error(\r\n          `Argument was not provided for required input \"${inputSpec.name}\"`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  let result: vertex.ParameterArgumentSpec;\r\n  if (typeof taskArgument === \"string\") {\r\n    result = {\r\n      runtimeValue: {\r\n        constantValue: stringToMlmdValue(\r\n          taskArgument,\r\n          typeSpecToVertexPrimitiveTypeEnum(inputSpec.type)\r\n        ),\r\n      },\r\n    };\r\n    return result;\r\n  } else if (\"graphInput\" in taskArgument) {\r\n    result = {\r\n      componentInputParameter: taskArgument.graphInput.inputName,\r\n    };\r\n    return result;\r\n  } else if (\"taskOutput\" in taskArgument) {\r\n    result = {\r\n      taskOutputParameter: {\r\n        producerTask: taskArgument.taskOutput.taskId,\r\n        outputParameterKey: taskArgument.taskOutput.outputName,\r\n      },\r\n    };\r\n    return result;\r\n  } else {\r\n    throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n  }\r\n}\r\n\r\nfunction buildVertexArtifactArgumentSpec(\r\n  taskArgument: ArgumentType | undefined,\r\n  inputSpec: InputSpec,\r\n  upstreamCannotBeArtifact: boolean,\r\n  addMakeArtifactTaskAndGetArtifactArgumentSpec: (\r\n    parameterArgumentSpec: vertex.ParameterArgumentSpec,\r\n    namePrefix?: string\r\n  ) => vertex.ArtifactArgumentSpec\r\n) {\r\n  //if (! (inputName in taskArguments)) {\r\n  if (taskArgument === undefined) {\r\n    // Checking for default value\r\n    if (inputSpec.default !== undefined) {\r\n      taskArgument = inputSpec.default;\r\n    } else {\r\n      if (inputSpec.optional === true) {\r\n        // TODO: Decide what the behavior should be\r\n        // throw Error(`Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`);\r\n        console.error(\r\n          `Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`\r\n        );\r\n        taskArgument = \"\";\r\n      } else {\r\n        throw Error(\r\n          `Argument was not provided for required input \"${inputSpec.name}\"`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  let result: vertex.ArtifactArgumentSpec;\r\n  if (typeof taskArgument === \"string\") {\r\n    const parameterArgumentSpec: vertex.ParameterArgumentSpec = {\r\n      runtimeValue: {\r\n        constantValue: {\r\n          // TODO: Check whether string is always OK here\r\n          stringValue: taskArgument,\r\n        },\r\n      },\r\n    };\r\n    // TODO: Maybe use the taskArgument as part of the name?\r\n    const convertedArtifactArgumentSpec =\r\n      addMakeArtifactTaskAndGetArtifactArgumentSpec(\r\n        parameterArgumentSpec,\r\n        \"Make artifact\"\r\n      );\r\n    result = convertedArtifactArgumentSpec;\r\n    return result;\r\n  } else if (\"graphInput\" in taskArgument) {\r\n    // Workaround for root DAG where all inputs must be parameters\r\n    if (upstreamCannotBeArtifact) {\r\n      const parameterArgumentSpec: vertex.ParameterArgumentSpec = {\r\n        componentInputParameter: taskArgument.graphInput.inputName,\r\n      };\r\n      // We only need one task for each pipeline input parameter\r\n      const convertedArtifactArgumentSpec =\r\n        addMakeArtifactTaskAndGetArtifactArgumentSpec(\r\n          parameterArgumentSpec,\r\n          \"Make artifact for \" + taskArgument.graphInput.inputName\r\n        );\r\n      result = convertedArtifactArgumentSpec;\r\n    } else {\r\n      result = {\r\n        componentInputArtifact: taskArgument.graphInput.inputName,\r\n      };\r\n    }\r\n    return result;\r\n  } else if (\"taskOutput\" in taskArgument) {\r\n    result = {\r\n      taskOutputArtifact: {\r\n        producerTask: taskArgument.taskOutput.taskId,\r\n        outputArtifactKey: taskArgument.taskOutput.outputName,\r\n      },\r\n    };\r\n    return result;\r\n  } else {\r\n    throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n  }\r\n}\r\n\r\nconst assertDefined = <T>(obj: T | undefined) => {\r\n  if (obj === undefined) {\r\n    throw TypeError(\"Object is undefined\");\r\n  }\r\n  return obj;\r\n};\r\n\r\nconst transformRecordValues = <T1, T2>(\r\n  record: Record<string, T1>,\r\n  transform: (value: T1) => T2\r\n) =>\r\n  Object.fromEntries(\r\n    Object.entries(record).map(([key, value]) => [key, transform(value)])\r\n  );\r\n\r\nfunction buildVertexComponentSpecFromContainerComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>,\r\n  addExecutorAndGetId: (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix?: string | undefined\r\n  ) => string\r\n) {\r\n  if (!isContainerImplementation(componentSpec.implementation)) {\r\n    throw Error(\"Only container components are supported by this function\");\r\n  }\r\n\r\n  const containerSpec = componentSpec.implementation.container;\r\n\r\n  const resolvedCommandLine = resolveCommandLine(\r\n    componentSpec,\r\n    taskArguments,\r\n    inputsThatHaveParameterArguments\r\n  );\r\n\r\n  const vertexExecutorSpec: vertex.ExecutorSpec = {\r\n    container: {\r\n      image: containerSpec.image,\r\n      command: resolvedCommandLine.command,\r\n      args: resolvedCommandLine.args,\r\n      env:\r\n        resolvedCommandLine.env &&\r\n        Object.entries(resolvedCommandLine.env).map(([name, value]) => ({\r\n          name: name,\r\n          value: value,\r\n        })),\r\n    },\r\n  };\r\n\r\n  const vertexExecutorId = addExecutorAndGetId(\r\n    vertexExecutorSpec,\r\n    componentSpec.name ?? \"Component\"\r\n  );\r\n\r\n  const inputMap = new Map(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => [inputSpec.name, inputSpec])\r\n  );\r\n\r\n  const vertexComponentInputsSpec: vertex.ComponentInputsSpec = {\r\n    parameters: Object.fromEntries(\r\n      Array.from(resolvedCommandLine.inputsConsumedAsParameter.values()).map(\r\n        (inputName) => [\r\n          inputName,\r\n          typeSpecToVertexParameterSpec(inputMap.get(inputName)?.type),\r\n        ]\r\n      )\r\n    ),\r\n    artifacts: Object.fromEntries(\r\n      Array.from(resolvedCommandLine.inputsConsumedAsArtifact.values()).map(\r\n        (inputName) => [\r\n          inputName,\r\n          typeSpecToVertexArtifactSpec(inputMap.get(inputName)?.type),\r\n        ]\r\n      )\r\n    ),\r\n  };\r\n\r\n  const vertexComponentOutputsSpec: vertex.ComponentOutputsSpec = {\r\n    parameters: {},\r\n    artifacts: Object.fromEntries(\r\n      (componentSpec.outputs ?? []).map((outputSpec) => [\r\n        outputSpec.name,\r\n        typeSpecToVertexArtifactSpec(outputSpec.type),\r\n      ])\r\n    ),\r\n  };\r\n\r\n  const vertexComponentSpec: vertex.ComponentSpec = {\r\n    inputDefinitions: vertexComponentInputsSpec,\r\n    outputDefinitions: vertexComponentOutputsSpec,\r\n    // dag\r\n    executorLabel: vertexExecutorId,\r\n  };\r\n  return vertexComponentSpec;\r\n}\r\n\r\nfunction buildVertexComponentSpecFromGraphComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>,\r\n  addExecutorAndGetId: (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix?: string\r\n  ) => string,\r\n  addComponentAndGetId: (\r\n    component: vertex.ComponentSpec,\r\n    namePrefix?: string\r\n  ) => string\r\n) {\r\n  if (!isGraphImplementation(componentSpec.implementation)) {\r\n    throw Error(\"Only graph components are supported by this function\");\r\n  }\r\n\r\n  const graphSpec = componentSpec.implementation.graph;\r\n\r\n  const inputsConsumedAsParameter = new Set<string>();\r\n  const inputsConsumedAsArtifact = new Set<string>();\r\n\r\n  let vertexTasks: Record<string, vertex.PipelineTaskSpec> = {};\r\n  const taskStringToTaskId = new Map<string, string>();\r\n\r\n  const addTaskAndGetId = (\r\n    task: vertex.PipelineTaskSpec,\r\n    namePrefix: string = \"Task\"\r\n  ) => {\r\n    const serializedSpec = JSON.stringify(task);\r\n    const existingId = taskStringToTaskId.get(serializedSpec);\r\n    if (existingId !== undefined) {\r\n      return existingId;\r\n    }\r\n    const usedIds = new Set(Object.keys(vertexTasks));\r\n    const id = makeNameUniqueByAddingIndex(namePrefix, usedIds);\r\n    taskStringToTaskId.set(serializedSpec, id);\r\n    vertexTasks[id] = task;\r\n    return id;\r\n  };\r\n\r\n  const addMakeArtifactTaskAndGetArtifactArgumentSpec = (\r\n    parameterArgumentSpec: vertex.ParameterArgumentSpec,\r\n    namePrefix: string = \"Make artifact\"\r\n  ) => {\r\n    // These system names are expected to not conflict with user task names\r\n    const makeArtifactExecutorId = addExecutorAndGetId(\r\n      makeArtifactExecutorSpec,\r\n      MAKE_ARTIFACT_EXECUTOR_ID\r\n    );\r\n    const makeArtifactComponentSpecCopy = {\r\n      ...makeArtifactComponentSpec,\r\n      executorLabel: makeArtifactExecutorId,\r\n    };\r\n    const makeArtifactComponentsId = addComponentAndGetId(\r\n      makeArtifactComponentSpecCopy,\r\n      MAKE_ARTIFACT_COMPONENT_ID\r\n    );\r\n    const makeArtifactTaskSpec = buildMakeArtifactTaskSpec(\r\n      parameterArgumentSpec\r\n    );\r\n    makeArtifactTaskSpec.componentRef.name = makeArtifactComponentsId;\r\n    const taskId = addTaskAndGetId(makeArtifactTaskSpec, namePrefix);\r\n    const artifactArgumentSpec: vertex.ArtifactArgumentSpec = {\r\n      taskOutputArtifact: {\r\n        producerTask: taskId,\r\n        outputArtifactKey: MAKE_ARTIFACT_OUTPUT_NAME,\r\n      },\r\n    };\r\n    return artifactArgumentSpec;\r\n  };\r\n\r\n  for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n    if (taskSpec.componentRef.spec === undefined) {\r\n      throw Error(`Task \"${taskId}\" does not have taskSpec.componentRef.spec.`);\r\n    }\r\n    try {\r\n      const vertexTaskSpec = buildVertexTaskSpecFromTaskSpec(\r\n        taskSpec.componentRef.spec,\r\n        taskSpec.arguments ?? {},\r\n        inputsThatHaveParameterArguments,\r\n        addExecutorAndGetId,\r\n        addComponentAndGetId,\r\n        addMakeArtifactTaskAndGetArtifactArgumentSpec\r\n      );\r\n      if (taskId in vertexTasks) {\r\n        throw Error(\r\n          `Task ID \"${taskId}\" is not unique. This cannot happen (unless user task ID clashes with special task ID).`\r\n        );\r\n      }\r\n      vertexTasks[taskId] = vertexTaskSpec;\r\n\r\n      for (const argument of Object.values(\r\n        vertexTaskSpec.inputs?.parameters ?? {}\r\n      )) {\r\n        if (argument.componentInputParameter !== undefined) {\r\n          inputsConsumedAsParameter.add(argument.componentInputParameter);\r\n        }\r\n      }\r\n      for (const argument of Object.values(\r\n        vertexTaskSpec.inputs?.artifacts ?? {}\r\n      )) {\r\n        if (\"componentInputArtifact\" in argument) {\r\n          inputsConsumedAsArtifact.add(argument.componentInputArtifact);\r\n        }\r\n      }\r\n    } catch (err) {\r\n      if (err instanceof Error) {\r\n        err.message = `Error compiling task ${taskId}: ` + err.message;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Sanity checks\r\n  const inputNamesThatAreUsedBothAsParameterAndArtifact = Array.from(\r\n    inputsConsumedAsParameter\r\n  ).filter((x) => inputsConsumedAsArtifact.has(x));\r\n  if (inputNamesThatAreUsedBothAsParameterAndArtifact.length > 0) {\r\n    throw Error(\r\n      `Compiler error: When compiling component \"${componentSpec.name}\" some inputs are used both as parameter and artifact: \"${inputNamesThatAreUsedBothAsParameterAndArtifact}\". Please file a bug report.`\r\n    );\r\n  }\r\n  const inputNamesThatAreParametersButAreConsumedAsArtifacts = Array.from(\r\n    inputsThatHaveParameterArguments\r\n  ).filter((x) => inputsConsumedAsArtifact.has(x));\r\n  if (inputNamesThatAreParametersButAreConsumedAsArtifacts.length > 0) {\r\n    throw Error(\r\n      `Compiler error: When compiling component \"${componentSpec.name}\" some parameter arguments are consumed as artifact: \"${inputNamesThatAreParametersButAreConsumedAsArtifacts}\". Please file a bug report.`\r\n    );\r\n  }\r\n\r\n  const dagOutputArtifactSpecs = transformRecordValues(\r\n    graphSpec.outputValues ?? {},\r\n    (taskOutputArgument) => {\r\n      const result: vertex.DagOutputArtifactSpec = {\r\n        artifactSelectors: [\r\n          {\r\n            producerSubtask: taskOutputArgument.taskOutput.taskId,\r\n            outputArtifactKey: taskOutputArgument.taskOutput.outputName,\r\n          },\r\n        ],\r\n      };\r\n      return result;\r\n    }\r\n  );\r\n\r\n  const inputMap = new Map(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => [inputSpec.name, inputSpec])\r\n  );\r\n\r\n  const vertexComponentInputsSpec: vertex.ComponentInputsSpec = {\r\n    parameters: Object.fromEntries(\r\n      Array.from(inputsConsumedAsParameter.values()).map((inputName) => [\r\n        inputName,\r\n        typeSpecToVertexParameterSpec(inputMap.get(inputName)?.type),\r\n      ])\r\n    ),\r\n    artifacts: Object.fromEntries(\r\n      Array.from(inputsConsumedAsArtifact.values()).map((inputName) => [\r\n        inputName,\r\n        typeSpecToVertexArtifactSpec(inputMap.get(inputName)?.type),\r\n      ])\r\n    ),\r\n  };\r\n\r\n  const vertexComponentOutputsSpec: vertex.ComponentOutputsSpec = {\r\n    // parameters: {},\r\n    artifacts: Object.fromEntries(\r\n      (componentSpec.outputs ?? []).map((outputSpec) => [\r\n        outputSpec.name,\r\n        typeSpecToVertexArtifactSpec(outputSpec.type),\r\n      ])\r\n    ),\r\n  };\r\n\r\n  const vertexComponentSpec: vertex.ComponentSpec = {\r\n    inputDefinitions: vertexComponentInputsSpec,\r\n    outputDefinitions: vertexComponentOutputsSpec,\r\n    dag: {\r\n      tasks: vertexTasks,\r\n      outputs: {\r\n        artifacts: dagOutputArtifactSpecs,\r\n        // parameters: {},\r\n      },\r\n    },\r\n  };\r\n  return vertexComponentSpec;\r\n}\r\n\r\nfunction buildVertexComponentSpecFromComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>,\r\n  addExecutorAndGetId: (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix?: string\r\n  ) => string,\r\n  addComponentAndGetId: (\r\n    component: vertex.ComponentSpec,\r\n    namePrefix?: string\r\n  ) => string\r\n) {\r\n  if (isContainerImplementation(componentSpec.implementation)) {\r\n    return buildVertexComponentSpecFromContainerComponentSpec(\r\n      componentSpec,\r\n      taskArguments,\r\n      inputsThatHaveParameterArguments,\r\n      addExecutorAndGetId\r\n    );\r\n  } else if (isGraphImplementation(componentSpec.implementation)) {\r\n    return buildVertexComponentSpecFromGraphComponentSpec(\r\n      componentSpec,\r\n      taskArguments,\r\n      inputsThatHaveParameterArguments,\r\n      addExecutorAndGetId,\r\n      addComponentAndGetId\r\n    );\r\n  } else {\r\n    throw Error(\r\n      `Unsupported component implementation kind: ${componentSpec.implementation}`\r\n    );\r\n  }\r\n}\r\n\r\nconst buildVertexTaskSpecFromTaskSpec = (\r\n  componentSpec: ComponentSpec,\r\n  //passedArgumentNames: string[],\r\n  taskArguments: Record<string, ArgumentType>,\r\n  graphInputsWithParameterArguments: Set<string>,\r\n  addExecutorAndGetId: (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix?: string\r\n  ) => string,\r\n  addComponentAndGetId: (\r\n    component: vertex.ComponentSpec,\r\n    namePrefix?: string\r\n  ) => string,\r\n  addMakeArtifactTaskAndGetArtifactArgumentSpec: (\r\n    parameterArgumentSpec: vertex.ParameterArgumentSpec,\r\n    namePrefix?: string\r\n  ) => vertex.ArtifactArgumentSpec\r\n) => {\r\n  // So-called \"parameter\" arguments can either be constant arguments\r\n  // or come from the arguments to the graph component of the current task.\r\n  // In the current implementation the parameter arguments cannot come from task outputs since all task outputs are artifacts.\r\n  const inputsThatHaveParameterArguments = new Set(\r\n    (componentSpec.inputs ?? [])\r\n      .map((inputSpec) => inputSpec.name)\r\n      .filter((inputName) => {\r\n        const taskArgument = taskArguments[inputName];\r\n        if (taskArgument === undefined) {\r\n          // Missing arguments fall back to default values which are constant strings which are parameters.\r\n          return true;\r\n        }\r\n        if (typeof taskArgument === \"string\") {\r\n          return true;\r\n        }\r\n        if (\"graphInput\" in taskArgument) {\r\n          if (\r\n            graphInputsWithParameterArguments.has(\r\n              taskArgument.graphInput.inputName\r\n            )\r\n          ) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      })\r\n  );\r\n\r\n  const inputMap = new Map(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => [inputSpec.name, inputSpec])\r\n  );\r\n\r\n  const vertexComponentSpec: vertex.ComponentSpec =\r\n    buildVertexComponentSpecFromComponentSpec(\r\n      componentSpec,\r\n      taskArguments,\r\n      inputsThatHaveParameterArguments,\r\n      addExecutorAndGetId,\r\n      addComponentAndGetId\r\n    );\r\n\r\n  const vertexComponentId = addComponentAndGetId(\r\n    vertexComponentSpec,\r\n    componentSpec.name ?? \"Component\"\r\n  );\r\n\r\n  const vertexTaskParameterArguments = Object.fromEntries(\r\n    Object.keys(vertexComponentSpec.inputDefinitions?.parameters ?? {}).map(\r\n      (inputName) => [\r\n        inputName,\r\n        buildVertexParameterArgumentSpec(\r\n          taskArguments[inputName],\r\n          assertDefined(inputMap.get(inputName))\r\n        ),\r\n      ]\r\n    )\r\n  );\r\n\r\n  const vertexTaskArtifactArguments = Object.fromEntries(\r\n    Object.keys(vertexComponentSpec.inputDefinitions?.artifacts ?? {}).map(\r\n      (inputName) => [\r\n        inputName,\r\n        buildVertexArtifactArgumentSpec(\r\n          taskArguments[inputName],\r\n          assertDefined(inputMap.get(inputName)),\r\n          inputsThatHaveParameterArguments.has(inputName),\r\n          addMakeArtifactTaskAndGetArtifactArgumentSpec\r\n        ),\r\n      ]\r\n    )\r\n  );\r\n\r\n  const vertexTaskSpec: vertex.PipelineTaskSpec = {\r\n    taskInfo: {\r\n      // This is the task display name, not an ID\r\n      name: componentSpec.name ?? \"Component\",\r\n    },\r\n    inputs: {\r\n      parameters: vertexTaskParameterArguments,\r\n      artifacts: vertexTaskArtifactArguments,\r\n    },\r\n    // dependent_tasks: [],\r\n    cachingOptions: {\r\n      enableCache: true,\r\n    },\r\n    componentRef: {\r\n      name: vertexComponentId,\r\n    },\r\n    // triggerPolicy: {\r\n    //     condition: \"...\",\r\n    //     strategy: \"ALL_UPSTREAM_TASKS_SUCCEEDED\",\r\n    // },\r\n    // iterator: {\r\n    //     artifactIterator: {...},\r\n    //     parameterIterator: {...},\r\n    // },\r\n  };\r\n\r\n  return vertexTaskSpec;\r\n};\r\n\r\nconst makeNameUniqueByAddingIndex = (\r\n  name: string,\r\n  existingNames: Set<string>\r\n): string => {\r\n  let finalName = name;\r\n  let index = 1;\r\n  while (existingNames.has(finalName)) {\r\n    index++;\r\n    finalName = name + \" \" + index.toString();\r\n  }\r\n  return finalName;\r\n};\r\n\r\nexport const buildVertexPipelineSpecFromGraphComponentSpec = (\r\n  componentSpec: ComponentSpec,\r\n  pipelineContextName = \"pipeline\"\r\n) => {\r\n  let vertexExecutors: Record<string, vertex.ExecutorSpec> = {};\r\n  const executorStringToExecutorId = new Map<string, string>();\r\n  let vertexComponents: Record<string, vertex.ComponentSpec> = {};\r\n  const componentStringToComponentId = new Map<string, string>();\r\n\r\n  const addExecutorAndGetId = (\r\n    executor: vertex.ExecutorSpec,\r\n    namePrefix: string = \"Executor\"\r\n  ) => {\r\n    const serializedSpec = JSON.stringify(executor);\r\n    const existingId = executorStringToExecutorId.get(serializedSpec);\r\n    if (existingId !== undefined) {\r\n      return existingId;\r\n    }\r\n    const usedIds = new Set(Object.keys(vertexExecutors));\r\n    const id = makeNameUniqueByAddingIndex(namePrefix, usedIds);\r\n    executorStringToExecutorId.set(serializedSpec, id);\r\n    vertexExecutors[id] = executor;\r\n    return id;\r\n  };\r\n\r\n  const addComponentAndGetId = (\r\n    component: vertex.ComponentSpec,\r\n    namePrefix: string = \"Component\"\r\n  ) => {\r\n    const serializedSpec = JSON.stringify(component);\r\n    const existingId = componentStringToComponentId.get(serializedSpec);\r\n    if (existingId !== undefined) {\r\n      return existingId;\r\n    }\r\n    const usedIds = new Set(Object.keys(vertexComponents));\r\n    const id = makeNameUniqueByAddingIndex(namePrefix, usedIds);\r\n    componentStringToComponentId.set(serializedSpec, id);\r\n    vertexComponents[id] = component;\r\n    return id;\r\n  };\r\n\r\n  // All root graph inputs are parameters\r\n  const graphInputsWithParameterArguments = new Set(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => inputSpec.name)\r\n  );\r\n\r\n  const pipelineArguments: Record<string, ArgumentType> = Object.fromEntries(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => {\r\n      const argument: ArgumentType = {\r\n        graphInput: { inputName: inputSpec.name },\r\n      };\r\n      return [inputSpec.name, argument];\r\n    })\r\n  );\r\n  const pipelineComponentSpec = buildVertexComponentSpecFromComponentSpec(\r\n    componentSpec,\r\n    pipelineArguments,\r\n    graphInputsWithParameterArguments,\r\n    addExecutorAndGetId,\r\n    addComponentAndGetId\r\n  );\r\n\r\n  const vertexPipelineSpec: vertex.PipelineSpec = {\r\n    pipelineInfo: {\r\n      name: sanitizePipelineInfoName(pipelineContextName),\r\n    },\r\n    sdkVersion: \"Cloud-Pipelines\",\r\n    schemaVersion: \"2.0.0\",\r\n    deploymentSpec: {\r\n      executors: vertexExecutors,\r\n    },\r\n    components: vertexComponents,\r\n    root: pipelineComponentSpec,\r\n  };\r\n  return vertexPipelineSpec;\r\n};\r\n\r\nexport const buildVertexPipelineJobFromGraphComponent = (\r\n  componentSpec: ComponentSpec,\r\n  gcsOutputDirectory: string,\r\n  pipelineArguments?: Map<string, string>,\r\n  pipelineContextName = \"pipeline\"\r\n) => {\r\n  // The pipelineContextName affects caching\r\n\r\n  const pipelineSpec = buildVertexPipelineSpecFromGraphComponentSpec(\r\n    componentSpec,\r\n    pipelineContextName\r\n  );\r\n  const inputParameterDefinitions =\r\n    (pipelineSpec.root.inputDefinitions ?? {}).parameters ?? {};\r\n\r\n  // Adding the default values\r\n  pipelineArguments = pipelineArguments || new Map();\r\n  const defaultInputValuePairs = (componentSpec.inputs ?? [])\r\n    .filter((inputSpec) => inputSpec.default !== undefined)\r\n    .map((inputSpec): [string, string] => [\r\n      inputSpec.name,\r\n      String(inputSpec.default),\r\n    ]);\r\n  const allPipelineArguments = new Map(\r\n    defaultInputValuePairs.concat(Array.from(pipelineArguments.entries()))\r\n  );\r\n\r\n  // Converting the pipeline arguments\r\n  let convertedPipelineArguments: Record<string, any> = {};\r\n  for (const [key, value] of Array.from(allPipelineArguments.entries())) {\r\n    if (!(key in inputParameterDefinitions)) {\r\n      console.error(\r\n        `A pipeline argument was provided for the input \"${key}\" that does not exist in the pipeline spec.`\r\n      );\r\n      continue;\r\n    }\r\n    convertedPipelineArguments[key] = stringToMlmdValue(\r\n      value,\r\n      inputParameterDefinitions[key].type\r\n    );\r\n  }\r\n\r\n  const pipelineJob: vertex.PipelineJob = {\r\n    // name: \"<>\",\r\n    // Does not show up in the UX\r\n    displayName: componentSpec.name ?? \"Pipeline\",\r\n    // labels: {},\r\n    runtimeConfig: {\r\n      parameters: convertedPipelineArguments,\r\n      gcsOutputDirectory: gcsOutputDirectory,\r\n    },\r\n    pipelineSpec: pipelineSpec,\r\n    // encryptionSpec: {},\r\n    // serviceAccount: \"<>\",\r\n    // network: {},\r\n  };\r\n  return pipelineJob;\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { DragEvent, useState } from 'react';\r\n\r\nimport ComponentLibrary from './ComponentLibrary'\r\nimport ComponentSearch from './ComponentSearch'\r\nimport GraphComponentExporter from './GraphComponentExporter'\r\nimport VertexAiExporter from './VertexAiExporter'\r\nimport { ComponentSpec } from '../componentSpec';\r\nimport UserComponentLibrary from \"./UserComponentLibrary\";\r\nimport PipelineLibrary from \"./PipelineLibrary\";\r\nimport { AppSettings } from '../appSettings';\r\nimport PipelineSubmitter from \"./PipelineSubmitter\";\r\nimport AppSettingsDialog from './AppSettingsDialog';\r\nimport { DownloadDataType, downloadDataWithCache } from '../cacheUtils';\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData('application/reactflow', JSON.stringify(nodeData));\r\n  event.dataTransfer.setData(\r\n    \"DragStart.offset\",\r\n    JSON.stringify({\r\n      offsetX: event.nativeEvent.offsetX,\r\n      offsetY: event.nativeEvent.offsetY,\r\n    })\r\n  );\r\n  event.dataTransfer.effectAllowed = 'move';\r\n};\r\n\r\ninterface SidebarProps {\r\n  componentSpec?: ComponentSpec,\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void,\r\n  appSettings: AppSettings;\r\n  downloadData: DownloadDataType;\r\n}\r\n\r\nconst Sidebar = ({\r\n  componentSpec,\r\n  setComponentSpec,\r\n  appSettings,\r\n  downloadData = downloadDataWithCache\r\n}: SidebarProps) => {\r\n  const [isSettingsDialogOpen, setIsSettingsDialogOpen] = useState(false);\r\n\r\n  // Do not include the DebugScratch in the production build\r\n  let DebugScratchElement = () => null;\r\n  if (process?.env?.NODE_ENV === \"development\") {\r\n    try {\r\n      const DebugScratch = require(\"./DebugScratch\").default;\r\n      DebugScratchElement = () =>\r\n        DebugScratch({\r\n          componentSpec: componentSpec,\r\n          setComponentSpec: setComponentSpec,\r\n          downloadData: downloadData,\r\n        });\r\n    } catch (e) {}\r\n  }\r\n\r\n  return (\r\n    <aside className=\"nodeList\">\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Save/Load pipeline</summary>\r\n        <PipelineLibrary\r\n          componentSpec={componentSpec}\r\n          setComponentSpec={setComponentSpec}\r\n          samplePipelineLibraryUrl={appSettings.pipelineLibraryUrl}\r\n          downloadData={downloadData}\r\n        />\r\n      </details>\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Run pipeline</summary>\r\n        <PipelineSubmitter\r\n          componentSpec={componentSpec}\r\n          googleCloudOAuthClientId={appSettings.googleCloudOAuthClientId}\r\n        />\r\n      </details>\r\n      <h3>Drag components to the canvas:</h3>\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary><strong>Special</strong></summary>\r\n        <div className=\"react-flow__node react-flow__node-input sidebar-node\" onDragStart={(event: DragEvent) => onDragStart(event, { input: { label: \"Input\" } })} draggable>\r\n          Input\r\n        </div>\r\n        <div className=\"react-flow__node react-flow__node-output sidebar-node\" onDragStart={(event: DragEvent) => onDragStart(event, { output: { label: \"Output\" } })} draggable>\r\n          Output\r\n        </div>\r\n      </details>\r\n      <details open>\r\n        <summary style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n          <strong>Component library</strong>\r\n        </summary>\r\n        <div style={{ paddingLeft: \"10px\" }}>\r\n          <ComponentLibrary\r\n            url={appSettings.componentLibraryUrl}\r\n            downloadData={downloadData}\r\n          />\r\n        </div>\r\n      </details>\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>User components</summary>\r\n        <UserComponentLibrary/>\r\n      </details>\r\n      <details open style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Component search</summary>\r\n        <ComponentSearch\r\n          componentFeedUrls={appSettings.componentFeedUrls}\r\n          gitHubSearchLocations={appSettings.gitHubSearchLocations}\r\n          downloadData={downloadData}\r\n        />\r\n      </details>\r\n      {/* Unmounting the dialog control to reset the state when closed. */}\r\n      {isSettingsDialogOpen && (\r\n        <AppSettingsDialog\r\n          isOpen={isSettingsDialogOpen}\r\n          handleClose={() => {\r\n            setIsSettingsDialogOpen(false);\r\n          }}\r\n        />\r\n      )}\r\n      <details>\r\n        <summary>Debug and developer tools</summary>\r\n        <button\r\n          onClick={(e) => {\r\n            setIsSettingsDialogOpen(true);\r\n          }}\r\n        >\r\n          Settings\r\n        </button>\r\n        {componentSpec && <GraphComponentExporter componentSpec={componentSpec}/>}\r\n        {componentSpec && <VertexAiExporter componentSpec={componentSpec}/>}\r\n        <DebugScratchElement/>\r\n      </details>\r\n    </aside>\r\n  );\r\n};\r\n\r\nexport default Sidebar;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useEffect, useState } from \"react\";\r\nimport {\r\n  DownloadDataType,\r\n  downloadDataWithCache,\r\n  loadObjectFromYamlData,\r\n} from \"../cacheUtils\";\r\nimport { ComponentReference } from \"../componentSpec\";\r\nimport {\r\n  ComponentReferenceWithSpec,\r\n  fullyLoadComponentRef,\r\n} from \"../componentStore\";\r\nimport DraggableComponent from \"./DraggableComponent\";\r\n\r\nexport type ComponentLibraryFolder = {\r\n  name: string;\r\n  folders: ComponentLibraryFolder[];\r\n  components: ComponentReference[];\r\n};\r\n\r\nexport type ComponentLibraryStruct = {\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n  folders: ComponentLibraryFolder[];\r\n};\r\n\r\nexport const isValidComponentLibraryStruct = (\r\n  obj: object\r\n): obj is ComponentLibraryStruct => \"folders\" in obj;\r\n\r\ninterface DraggableComponentRowProps {\r\n  componentRef: ComponentReference;\r\n  downloadData: DownloadDataType;\r\n}\r\n\r\nexport const DraggableComponentRow = ({\r\n  componentRef,\r\n  downloadData = downloadDataWithCache,\r\n}: DraggableComponentRowProps) => {\r\n  const [componentRefWithSpec, setComponentRefWithSpec] = useState<\r\n    ComponentReferenceWithSpec | undefined\r\n  >(undefined);\r\n  useEffect(() => {\r\n    // TODO: Validate the component\r\n    // Loading the component (preloading the graph component children as well).\r\n    fullyLoadComponentRef(componentRef, downloadData).then(\r\n      setComponentRefWithSpec\r\n    );\r\n  }, [componentRef, downloadData]);\r\n\r\n  if (componentRefWithSpec === undefined) {\r\n    return <div>Loading...</div>;\r\n  } else {\r\n    return <DraggableComponent componentReference={componentRefWithSpec} />;\r\n  }\r\n};\r\n\r\nexport const FoldersAndComponentsVis = ({\r\n  folder,\r\n  isOpen = false,\r\n  downloadData = downloadDataWithCache,\r\n}: {\r\n  folder: ComponentLibraryFolder;\r\n  isOpen?: boolean;\r\n  downloadData: DownloadDataType;\r\n}) => {\r\n  return (\r\n    <>\r\n      {folder.folders &&\r\n        Array.from(folder.folders).map((componentFolder, index) => (\r\n          <SingleFolderVis\r\n            key={componentFolder.name}\r\n            folder={componentFolder}\r\n            isOpen={isOpen && index === 0}\r\n            downloadData={downloadData}\r\n          />\r\n        ))}\r\n      {folder.components &&\r\n        Array.from(folder.components).map((componentReference) => (\r\n          <DraggableComponentRow\r\n            key={\r\n              componentReference.digest ||\r\n              componentReference.url ||\r\n              componentReference.text\r\n            }\r\n            componentRef={componentReference}\r\n            downloadData={downloadData}\r\n          />\r\n        ))}\r\n    </>\r\n  );\r\n};\r\n\r\nexport const SingleFolderVis = ({\r\n  folder,\r\n  isOpen = false,\r\n  downloadData = downloadDataWithCache,\r\n}: {\r\n  folder: ComponentLibraryFolder;\r\n  isOpen?: boolean;\r\n  downloadData: DownloadDataType;\r\n}) => {\r\n  return (\r\n    <details\r\n      key={folder.name}\r\n      open={isOpen}\r\n      style={{\r\n        border: \"1px solid #aaa\",\r\n        borderRadius: \"4px\",\r\n        padding: \"4px\",\r\n        paddingLeft: \"10px\",\r\n      }}\r\n    >\r\n      <summary\r\n        style={{\r\n          borderWidth: \"1px\",\r\n          padding: \"4px\",\r\n          // Managing the summary text overflow\r\n          // Having the styles in <strong> causes the summary marker and the text to be on different lines.\r\n          textOverflow: \"ellipsis\",\r\n          //maxWidth: \"90%\",\r\n          overflow: \"hidden\",\r\n          whiteSpace: \"nowrap\",\r\n          //display: \"block\",\r\n        }}\r\n        title={folder.name}\r\n      >\r\n        <strong>{folder.name}</strong>\r\n      </summary>\r\n      <FoldersAndComponentsVis\r\n        folder={folder}\r\n        isOpen={isOpen}\r\n        downloadData={downloadData}\r\n      />\r\n    </details>\r\n  );\r\n};\r\n\r\nexport const ComponentLibraryVisFromStruct = ({\r\n  componentLibraryStruct,\r\n  downloadData = downloadDataWithCache,\r\n}: {\r\n  componentLibraryStruct: ComponentLibraryStruct;\r\n  downloadData: DownloadDataType;\r\n}) => {\r\n  return (\r\n    <>\r\n      {Array.from(componentLibraryStruct.folders).map(\r\n        (componentFolder, index) => (\r\n          <SingleFolderVis\r\n            key={componentFolder.name}\r\n            folder={componentFolder}\r\n            isOpen={index === 0}\r\n            downloadData={downloadData}\r\n          />\r\n        )\r\n      )}\r\n    </>\r\n  );\r\n};\r\n\r\nconst loadComponentLibraryStructFromData = async (data: ArrayBuffer) => {\r\n  const componentLibrary = loadObjectFromYamlData(data);\r\n  if (!isValidComponentLibraryStruct(componentLibrary)) {\r\n    throw Error(\r\n      `Invalid Component library data structure: ${componentLibrary}`\r\n    );\r\n  }\r\n  return componentLibrary;\r\n};\r\n\r\nconst loadComponentLibraryStructFromUrl = async (\r\n  url: string,\r\n  downloadData: DownloadDataType = downloadDataWithCache\r\n) => {\r\n  const componentLibrary = await downloadData(\r\n    url,\r\n    loadComponentLibraryStructFromData\r\n  );\r\n  return componentLibrary;\r\n};\r\n\r\ninterface ComponentLibraryVisFromUrlProps {\r\n  url: string;\r\n  downloadData: DownloadDataType;\r\n}\r\n\r\nconst ComponentLibraryVisFromUrl = ({\r\n  url,\r\n  downloadData = downloadDataWithCache,\r\n}: ComponentLibraryVisFromUrlProps) => {\r\n  const [componentLibraryStruct, setComponentLibraryStruct] = useState<\r\n    ComponentLibraryStruct | undefined\r\n  >();\r\n\r\n  useEffect(() => {\r\n    if (componentLibraryStruct === undefined) {\r\n      (async () => {\r\n        try {\r\n          const loadedComponentLibrary =\r\n            await loadComponentLibraryStructFromUrl(url, downloadData);\r\n          setComponentLibraryStruct(loadedComponentLibrary);\r\n        } catch (err) {\r\n          console.error(err);\r\n        }\r\n      })();\r\n    }\r\n  }, [componentLibraryStruct, url, downloadData]);\r\n\r\n  return componentLibraryStruct === undefined ? (\r\n    <>\"The library is not loaded\"</>\r\n  ) : (\r\n    <ComponentLibraryVisFromStruct\r\n      componentLibraryStruct={componentLibraryStruct}\r\n      downloadData={downloadData}\r\n    />\r\n  );\r\n};\r\n\r\nexport default ComponentLibraryVisFromUrl;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { augmentComponentSpec } from './GraphComponentSpecFlow'\r\nimport { componentSpecToYaml } from \"../componentStore\";\r\nimport { useState } from \"react\";\r\n\r\ninterface GraphComponentExporterProps {\r\n  componentSpec: ComponentSpec,\r\n}\r\n\r\nconst GraphComponentExporter = ({\r\n  componentSpec,\r\n}: GraphComponentExporterProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n  const [includeComponentSpecs, ] = useState(false);\r\n\r\n  let componentText = \"\";\r\n  try {\r\n    const graphComponent = augmentComponentSpec(componentSpec, nodes, includeComponentSpecs, true);\r\n    componentText = componentSpecToYaml(graphComponent);\r\n  } catch(err) {\r\n    componentText = String(err);\r\n  }\r\n\r\n  const componentTextBlob = new Blob([componentText], { type: \"text/yaml\" }); // Or application/x-yaml (which leads to downloading)\r\n  const downloadLink = <a href={URL.createObjectURL(componentTextBlob)} download={\"component.yaml\"}>component.yaml</a>\r\n\r\n  return (\r\n    <details>\r\n      <summary>Graph {downloadLink}</summary>\r\n      <pre style={{overflow: \"auto\"}}>{componentText}</pre>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default GraphComponentExporter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\nimport { buildVertexPipelineSpecFromGraphComponentSpec } from '../compilers/GoogleCloudVertexAIPipelines/vertexAiCompiler'\r\n\r\ninterface VertexAiExporterProps {\r\n  componentSpec: ComponentSpec;\r\n}\r\n\r\nconst VertexAiExporter = ({componentSpec}: VertexAiExporterProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  let vertexPipelineSpecText = \"\";\r\n  try {\r\n    // Augmenting the componentSpec might be useless right now, but it can stabilize the output (e.g. ordering).\r\n    // Also, in the future, the original spec might be included in the vertexPipelineSpec\r\n    componentSpec = augmentComponentSpec(componentSpec, nodes, true, true);\r\n    const vertexPipelineSpec = buildVertexPipelineSpecFromGraphComponentSpec(componentSpec);\r\n    vertexPipelineSpecText = JSON.stringify(vertexPipelineSpec, undefined, 2);\r\n  } catch(err) {\r\n    vertexPipelineSpecText = String(err);\r\n  }\r\n\r\n  const vertexPipelineSpecTextBlob = new Blob([vertexPipelineSpecText], { type: \"application/json\" }); // Or application/x-yaml (which leads to downloading)\r\n  // TODO: Call vertexPipelineSpecTextBlobUrl.revokeObjectURL in the future\r\n  const vertexPipelineSpecTextBlobUrl = URL.createObjectURL(vertexPipelineSpecTextBlob);\r\n\r\n  return (\r\n    <details>\r\n      <summary>\r\n        Cloud IR <a\r\n          href={vertexPipelineSpecTextBlobUrl}\r\n          download={\"vertex_pipeline_spec.json\"}\r\n        >\r\n          vertex_pipeline_spec.json\r\n        </a>\r\n      </summary>\r\n      <pre style={{ overflow: \"auto\" }}>{vertexPipelineSpecText}</pre>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default VertexAiExporter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  Button,\r\n  Dialog,\r\n  DialogActions,\r\n  DialogContent,\r\n  DialogTitle,\r\n  Menu,\r\n  MenuItem,\r\n  TextField,\r\n} from \"@material-ui/core\";\r\nimport { useCallback, useState, useEffect, useRef } from \"react\";\r\nimport { useDropzone } from \"react-dropzone\";\r\nimport {\r\n  addComponentToListByText,\r\n  deleteComponentFileFromList,\r\n  ComponentFileEntry,\r\n  getAllComponentFilesFromList,\r\n  addComponentToListByUrl,\r\n} from \"../componentStore\";\r\nimport DraggableComponent from \"./DraggableComponent\";\r\n\r\nconst USER_COMPONENTS_LIST_NAME = \"user_components\";\r\n\r\nconst UserComponentLibrary = () => {\r\n  const [errorMessage, setErrorMessage] = useState(\"\");\r\n  const [componentFiles, setComponentFiles] = useState(\r\n    new Map<string, ComponentFileEntry>()\r\n  );\r\n  const [contextMenuFileName, setContextMenuFileName] = useState<string>();\r\n  const [contextMenuAnchor, setContextMenuAnchor] = useState<HTMLElement>();\r\n  const [isImportComponentDialogOpen, setIsImportComponentDialogOpen] =\r\n    useState(false);\r\n\r\n  const refreshComponents = useCallback(() => {\r\n    getAllComponentFilesFromList(USER_COMPONENTS_LIST_NAME).then(\r\n      setComponentFiles\r\n    );\r\n  }, [setComponentFiles]);\r\n\r\n  useEffect(refreshComponents, [refreshComponents]);\r\n\r\n  const onDrop = useCallback((acceptedFiles: File[]) => {\r\n    acceptedFiles.forEach((file) => {\r\n      const reader = new FileReader();\r\n      reader.onabort = () => console.log(\"file reading was aborted\");\r\n      reader.onerror = () => console.log(\"file reading has failed\");\r\n      reader.onload = async () => {\r\n        const binaryStr = reader.result;\r\n        if (binaryStr === null || binaryStr === undefined) {\r\n          console.error(`Dropped file reader result was ${binaryStr}`);\r\n          return;\r\n        }\r\n        try {\r\n          const componentRefPlusData = await addComponentToListByText(\r\n            USER_COMPONENTS_LIST_NAME,\r\n            binaryStr,\r\n          );\r\n          const componentRef = componentRefPlusData.componentRef;\r\n          console.debug(\"storeComponentText succeeded\", componentRef);\r\n          (window as any).gtag?.(\"event\", \"UserComponents_component_import\", {\r\n            result: \"succeeded\",\r\n          });\r\n          setErrorMessage(\"\");\r\n          refreshComponents();\r\n        } catch (err) {\r\n          const errorMessage =\r\n            typeof err === \"object\" && err ? err.toString() : String(err);\r\n          setErrorMessage(\r\n            `Error parsing the dropped file as component: ${errorMessage}.`\r\n          );\r\n          console.error(\"Error parsing the dropped file as component\", err);\r\n          (window as any).gtag?.(\"event\", \"UserComponents_component_import\", {\r\n            result: \"failed\",\r\n          });\r\n        }\r\n      };\r\n      reader.readAsArrayBuffer(file);\r\n    });\r\n  }, [refreshComponents]);\r\n\r\n  const onImportFromUrl = useCallback(\r\n    async (url: string) => {\r\n      try {\r\n        const componentFileEntry = await addComponentToListByUrl(\r\n          USER_COMPONENTS_LIST_NAME,\r\n          url\r\n        );\r\n        const componentRef = componentFileEntry.componentRef;\r\n        console.debug(\"addComponentToListByUrl succeeded\", componentRef);\r\n        (window as any).gtag?.(\r\n          \"event\",\r\n          \"UserComponents_component_import_from_url_succeeded\"\r\n        );\r\n        setErrorMessage(\"\");\r\n        refreshComponents();\r\n        setIsImportComponentDialogOpen(false);\r\n      } catch (err) {\r\n        const errorMessage =\r\n          typeof err === \"object\" && err ? err.toString() : String(err);\r\n        setErrorMessage(\r\n          `Error parsing the file as component: ${errorMessage}.`\r\n        );\r\n        console.error(\"Error importing component from the URL\", err);\r\n        (window as any).gtag?.(\r\n          \"event\",\r\n          \"UserComponents_component_import_from_url_failed\"\r\n        );\r\n      }\r\n    },\r\n    [refreshComponents]\r\n  );\r\n\r\n  const handleContextMenuDelete = async () => {\r\n    if (contextMenuFileName) {\r\n      setContextMenuFileName(undefined);\r\n      await deleteComponentFileFromList(\r\n        USER_COMPONENTS_LIST_NAME,\r\n        contextMenuFileName\r\n      );\r\n      refreshComponents();\r\n    }\r\n  };\r\n\r\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({\r\n    onDrop,\r\n    accept: \".yaml\",\r\n  });\r\n\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={(e) => setIsImportComponentDialogOpen(true)}\r\n        style={{ marginBottom: \"4px\" }}\r\n      >\r\n        Import from URL\r\n      </button>\r\n      <div {...getRootProps()}>\r\n        <input {...getInputProps()} />\r\n        <div\r\n          style={{\r\n            border: \"1px solid black\",\r\n            padding: \"4px\",\r\n            minHeight: \"3em\",\r\n          }}\r\n        >\r\n          {isDragActive\r\n            ? \"Drop the files here ...\"\r\n            : errorMessage ||\r\n              \"Drag and drop component.yaml files or click to select files\"}\r\n          {Array.from(componentFiles.entries()).map(([fileName, fileEntry]) => (\r\n            <DraggableComponent\r\n              key={fileName}\r\n              componentReference={fileEntry.componentRef}\r\n              onContextMenu={(e) => {\r\n                e.preventDefault();\r\n                setContextMenuAnchor(e.currentTarget);\r\n                setContextMenuFileName(fileName);\r\n              }}\r\n            />\r\n          ))}\r\n        </div>\r\n      </div>\r\n      <Menu\r\n        open={contextMenuFileName !== undefined}\r\n        anchorEl={contextMenuAnchor}\r\n        onClose={() => {\r\n          setContextMenuFileName(undefined);\r\n        }}\r\n      >\r\n        <MenuItem dense={true} onClick={handleContextMenuDelete}>\r\n          Delete\r\n        </MenuItem>\r\n      </Menu>\r\n      <ImportComponentFromUrlDialog\r\n        isOpen={isImportComponentDialogOpen}\r\n        onCancel={() => setIsImportComponentDialogOpen(false)}\r\n        initialValue={\"https://raw.githubusercontent.com/.../component.yaml\"}\r\n        onImport={onImportFromUrl}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default UserComponentLibrary;\r\n\r\ninterface SaveAsDialogProps {\r\n  isOpen: boolean;\r\n  onImport: (name: string) => void;\r\n  onCancel: () => void;\r\n  initialValue: string | undefined;\r\n}\r\n\r\nconst ImportComponentFromUrlDialog = ({\r\n  isOpen,\r\n  onImport,\r\n  onCancel,\r\n  initialValue,\r\n}: SaveAsDialogProps) => {\r\n  const urlInputRef = useRef<HTMLInputElement>();\r\n  return (\r\n    <Dialog open={isOpen} fullWidth>\r\n      <DialogTitle>{\"Import component\"}</DialogTitle>\r\n      <form\r\n        onSubmit={(e) => {\r\n          if (urlInputRef.current) {\r\n            onImport(urlInputRef.current.value);\r\n          }\r\n          e.preventDefault();\r\n        }}\r\n      >\r\n        <DialogContent>\r\n          <TextField\r\n            id=\"name\"\r\n            type=\"text\"\r\n            placeholder={initialValue}\r\n            label=\"Component URL\"\r\n            inputRef={urlInputRef}\r\n            required\r\n            autoFocus\r\n            fullWidth\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={onCancel}>Cancel</Button>\r\n          <Button color=\"primary\" type=\"submit\" autoFocus>\r\n            Import\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2022 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2022 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  Button,\r\n  Dialog,\r\n  DialogActions,\r\n  DialogContent,\r\n  DialogTitle,\r\n  TextField,\r\n} from \"@material-ui/core\";\r\nimport { useState } from \"react\";\r\nimport { getMutableAppSettings } from \"../appSettings\";\r\n\r\ntype AppSettingsDialogProps = {\r\n  isOpen: boolean;\r\n  handleClose: () => void;\r\n};\r\n\r\nconst AppSettingsDialog = ({ isOpen, handleClose }: AppSettingsDialogProps) => {\r\n  const appSettings = getMutableAppSettings();\r\n\r\n  const [componentLibraryUrl, setComponentLibraryUrl] = useState(\r\n    appSettings.componentLibraryUrl.value\r\n  );\r\n  const [pipelineLibraryUrl, setPipelineLibraryUrl] = useState(\r\n    appSettings.pipelineLibraryUrl.value\r\n  );\r\n  const [defaultPipelineUrl, setDefaultPipelineUrl] = useState(\r\n    appSettings.defaultPipelineUrl.value\r\n  );\r\n  const [componentFeedUrls, setComponentFeedUrls] = useState(\r\n    appSettings.componentFeedUrls.value\r\n  );\r\n  const [gitHubSearchLocations, setGitHubSearchLocations] = useState(\r\n    appSettings.gitHubSearchLocations.value\r\n  );\r\n  const [googleCloudOAuthClientId, setGoogleCloudOAuthClientId] = useState(\r\n    appSettings.googleCloudOAuthClientId.value\r\n  );\r\n\r\n  const handleSave = () => {\r\n    appSettings.componentLibraryUrl.value = componentLibraryUrl;\r\n    appSettings.pipelineLibraryUrl.value = pipelineLibraryUrl;\r\n    appSettings.defaultPipelineUrl.value = defaultPipelineUrl;\r\n    appSettings.componentFeedUrls.value = componentFeedUrls;\r\n    appSettings.gitHubSearchLocations.value = gitHubSearchLocations;\r\n    appSettings.googleCloudOAuthClientId.value = googleCloudOAuthClientId;\r\n    handleClose();\r\n  };\r\n\r\n  const handleReset = () => {\r\n    setComponentLibraryUrl(appSettings.componentLibraryUrl.resetToDefault());\r\n    setPipelineLibraryUrl(appSettings.pipelineLibraryUrl.resetToDefault());\r\n    setDefaultPipelineUrl(appSettings.defaultPipelineUrl.resetToDefault());\r\n    setComponentFeedUrls(appSettings.componentFeedUrls.resetToDefault());\r\n    setGitHubSearchLocations(\r\n      appSettings.gitHubSearchLocations.resetToDefault()\r\n    );\r\n    setGoogleCloudOAuthClientId(\r\n      appSettings.googleCloudOAuthClientId.resetToDefault()\r\n    );\r\n  };\r\n\r\n  return (\r\n    <Dialog open={isOpen} onClose={handleClose}>\r\n      <DialogTitle>Settings</DialogTitle>\r\n      <DialogContent>\r\n        {/* <DialogContentText>Application settings</DialogContentText> */}\r\n        <TextField\r\n          id=\"component_library_url\"\r\n          label=\"Component library URL\"\r\n          variant=\"outlined\"\r\n          margin=\"normal\"\r\n          fullWidth\r\n          value={componentLibraryUrl}\r\n          onChange={(e) => setComponentLibraryUrl(e.target.value)}\r\n        />\r\n        <TextField\r\n          id=\"pipeline_library_url\"\r\n          label=\"Pipeline library URL\"\r\n          variant=\"outlined\"\r\n          margin=\"normal\"\r\n          fullWidth\r\n          value={pipelineLibraryUrl}\r\n          onChange={(e) => setPipelineLibraryUrl(e.target.value)}\r\n        />\r\n        <TextField\r\n          id=\"default_pipeline_url\"\r\n          label=\"Default pipeline URL\"\r\n          variant=\"outlined\"\r\n          margin=\"normal\"\r\n          fullWidth\r\n          value={defaultPipelineUrl}\r\n          onChange={(e) => setDefaultPipelineUrl(e.target.value)}\r\n        />\r\n        <TextField\r\n          id=\"component_search_feed_urls\"\r\n          label=\"Component search feed URLs\"\r\n          variant=\"outlined\"\r\n          margin=\"normal\"\r\n          fullWidth\r\n          multiline\r\n          value={componentFeedUrls.join(\"\\n\")}\r\n          onChange={(e) => setComponentFeedUrls(e.target.value.split(\"\\n\"))}\r\n        />\r\n        <TextField\r\n          id=\"component_search_locations_github\"\r\n          label=\"Component search locations - GitHub\"\r\n          variant=\"outlined\"\r\n          margin=\"normal\"\r\n          fullWidth\r\n          multiline\r\n          value={gitHubSearchLocations.join(\"\\n\")}\r\n          onChange={(e) => setGitHubSearchLocations(e.target.value.split(\"\\n\"))}\r\n        />\r\n        <TextField\r\n          id=\"google_cloud_client_id\"\r\n          label=\"Google Cloud OAuth client ID\"\r\n          variant=\"outlined\"\r\n          margin=\"normal\"\r\n          fullWidth\r\n          value={googleCloudOAuthClientId}\r\n          onChange={(e) => setGoogleCloudOAuthClientId(e.target.value)}\r\n        />\r\n      </DialogContent>\r\n      <DialogActions>\r\n        <Button onClick={handleClose} color=\"default\">\r\n          Cancel\r\n        </Button>\r\n        <Button onClick={handleSave} color=\"primary\">\r\n          Save\r\n        </Button>\r\n        <Button onClick={handleReset} color=\"secondary\">\r\n          Reset\r\n        </Button>\r\n      </DialogActions>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nexport default AppSettingsDialog;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\n/* global gapi */\r\n\r\nimport { useEffect, useState } from 'react';\r\n\r\nimport { ComponentSpec } from '../componentSpec';\r\nimport { buildVertexPipelineJobFromGraphComponent } from '../compilers/GoogleCloudVertexAIPipelines/vertexAiCompiler'\r\nimport { PipelineJob } from '../compilers/GoogleCloudVertexAIPipelines/vertexPipelineSpec';\r\n\r\nconst LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY = \"GoogleCloudSubmitter/gcsOutputDirectory\";\r\nconst LOCAL_STORAGE_PROJECT_ID_KEY = \"GoogleCloudSubmitter/projectId\";\r\nconst LOCAL_STORAGE_REGION_KEY = \"GoogleCloudSubmitter/region\";\r\nconst LOCAL_STORAGE_PROJECT_IDS_KEY = \"GoogleCloudSubmitter/projectIds\";\r\n\r\nconst VERTEX_AI_PIPELINES_REGIONS = [\r\n  'us-central1',\r\n  'us-east1',\r\n  'us-west1',\r\n  'europe-west1',\r\n  'europe-west2',\r\n  'europe-west4',\r\n  'asia-east1',\r\n  'asia-southeast1',\r\n  'northamerica-northeast1',\r\n];\r\n\r\nconst VERTEX_AI_PIPELINES_DEFAULT_REGION = 'us-central1';\r\n\r\nconst authorizeGoogleCloudClient = async (\r\n  clientId: string,\r\n  scopes: string[],\r\n  immediate = false, // Setting immediate to true prevents auth window showing every time. But it needs to be false the first time (when cookies are not set).\r\n) => {\r\n  return new Promise<GoogleApiOAuth2TokenObject>(\r\n    (resolve, reject) => {\r\n      gapi.auth.authorize(\r\n        {\r\n          client_id: clientId,\r\n          scope: scopes,\r\n          immediate: immediate,\r\n        },\r\n        (authResult) => {\r\n          // console.debug(\"authorizeGoogleCloudClient: called back\");\r\n          if (authResult === undefined) {\r\n            console.error(\"authorizeGoogleCloudClient failed\");\r\n            reject(\"gapi.auth.authorize result is undefined\");\r\n          } else if (authResult.error) {\r\n            console.error(\r\n              \"authorizeGoogleCloudClient failed\",\r\n              authResult.error\r\n            );\r\n            reject(authResult.error);\r\n          } else {\r\n            // console.debug(\"authorizeGoogleCloudClient: Success\");\r\n            // Working around the Google Auth bug: The request succeeds, but the returned token does not have the requested scopes.\r\n            // See https://github.com/google/google-api-javascript-client/issues/743\r\n            const receivedScopesString = (authResult as any).scope as string | undefined;\r\n            const receivedScopes = receivedScopesString?.split(\" \");\r\n            if (receivedScopes === undefined || !scopes.every((scope) => receivedScopes.includes(scope))) {\r\n              const errorMessage = `Authorization call succeeded, but the returned scopes are ${receivedScopesString}`;\r\n              console.error(errorMessage);\r\n              reject(errorMessage);\r\n            } else {\r\n              resolve(authResult);\r\n            }\r\n          }\r\n        }\r\n      );\r\n    }\r\n  );\r\n};\r\n\r\nexport const ensureGoogleCloudAuthorizesScopes = async (\r\n  googleCloudOAuthClientId: string,\r\n  scopes: string[]\r\n) => {\r\n  try {\r\n    // console.debug('Before ensureGoogleCloudAuthorizesScopes(immediate=true)');\r\n    const oauthToken = await authorizeGoogleCloudClient(\r\n      googleCloudOAuthClientId,\r\n      scopes,\r\n      true,\r\n    );\r\n    // console.debug('After ensureGoogleCloudAuthorizesScopes(immediate=true)');\r\n    (window as any).gtag?.(\"event\", \"GoogleCloud_auth\", {\r\n      result: \"succeeded\",\r\n      immediate: \"true\"\r\n    });\r\n    return oauthToken;\r\n  } catch (err) {\r\n    // console.error('ensureGoogleCloudAuthorizesScopes(immediate=true)', err);\r\n    try {\r\n      const oauthToken = await authorizeGoogleCloudClient(\r\n        googleCloudOAuthClientId,\r\n        scopes,\r\n        false\r\n      );\r\n      (window as any).gtag?.(\"event\", \"GoogleCloud_auth\", {\r\n        result: \"succeeded\",\r\n        immediate: \"false\"\r\n      });\r\n      return oauthToken;\r\n    } catch (err) {\r\n      // console.error('ensureGoogleCloudAuthorizesScopes(immediate=false)', err);\r\n      (window as any).gtag?.(\"event\", \"GoogleCloud_auth\", {\r\n        result: \"failed\",\r\n        immediate: \"false\"\r\n      });\r\n    }\r\n  }\r\n};\r\n\r\nconst cloudresourcemanagerListProjects = async (\r\n  googleCloudOAuthClientId: string\r\n) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    googleCloudOAuthClientId,\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: \"https://cloudresourcemanager.googleapis.com/v1/projects/\",\r\n  });\r\n  return response.result;\r\n}\r\n\r\nconst aiplatformCreatePipelineJob = async (\r\n  projectId: string,\r\n  region = \"us-central1\",\r\n  pipelineJob: Record<string, any>,\r\n  googleCloudOAuthClientId: string,\r\n  pipelineJobId?: string,\r\n) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    googleCloudOAuthClientId,\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: `https://${region}-aiplatform.googleapis.com/v1beta1/projects/${projectId}/locations/${region}/pipelineJobs?pipelineJobId=${pipelineJobId}`,\r\n    method: \"POST\",\r\n    body: JSON.stringify(pipelineJob),\r\n  });\r\n  (window as any).gtag?.(\"event\", \"GoogleCloud_submit_pipeline_job\", {\r\n    result: \"succeeded\"\r\n  });\r\n  return response.result;\r\n}\r\n\r\ninterface GoogleCloudSubmitterProps {\r\n  componentSpec?: ComponentSpec,\r\n  pipelineArguments?: Map<string, string>,\r\n  googleCloudOAuthClientId: string;\r\n};\r\n\r\nconst GoogleCloudSubmitter = ({\r\n  componentSpec,\r\n  pipelineArguments,\r\n  googleCloudOAuthClientId\r\n}: GoogleCloudSubmitterProps) => {\r\n  const [projects, setProjects] = useState<string[]>(\r\n    () => JSON.parse(window.localStorage?.getItem(LOCAL_STORAGE_PROJECT_IDS_KEY) ?? \"[]\")\r\n  );\r\n  const [project, setProject] = useState<string>(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_PROJECT_ID_KEY) ?? \"\"\r\n  ); // undefined causes error: https://reactjs.org/docs/forms.html#controlled-components https://stackoverflow.com/a/47012342\r\n  const [region, setRegion] = useState(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_REGION_KEY) ?? VERTEX_AI_PIPELINES_DEFAULT_REGION\r\n  );\r\n  const [error, setError] = useState(\"\");\r\n  const [gcsOutputDirectory, setGcsOutputDirectory] = useState(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY) ?? \"\"\r\n  );\r\n  const [pipelineJobWebUrl, setPipelineJobWebUrl] = useState<\r\n    string | undefined\r\n  >(undefined);\r\n  const [compilationError, setCompilationError] = useState<string | undefined>(\r\n    undefined\r\n  );\r\n  const [vertexPipelineJob, setVertexPipelineJob] = useState<\r\n    PipelineJob | undefined\r\n  >(undefined);\r\n  const [vertexPipelineJsonBlobUrl, setVertexPipelineJsonBlobUrl] = useState<\r\n    string | undefined\r\n  >(undefined);\r\n\r\n  useEffect(() => {\r\n    if (componentSpec !== undefined) {\r\n      try {\r\n        const vertexPipelineJob = buildVertexPipelineJobFromGraphComponent(\r\n          componentSpec,\r\n          gcsOutputDirectory,\r\n          pipelineArguments\r\n        );\r\n        setCompilationError(undefined);\r\n        vertexPipelineJob.labels = {\r\n          sdk: \"cloud-pipelines-editor\",\r\n          \"cloud-pipelines-editor-version\": \"0-0-1\",\r\n        };\r\n        setVertexPipelineJob(vertexPipelineJob);\r\n        const vertexPipelineJobJson = JSON.stringify(\r\n          vertexPipelineJob,\r\n          undefined,\r\n          2\r\n        );\r\n        const vertexPipelineJsonBlobUrl = URL.createObjectURL(\r\n          new Blob([vertexPipelineJobJson], { type: \"application/json\" })\r\n        );\r\n        setVertexPipelineJsonBlobUrl(vertexPipelineJsonBlobUrl);\r\n      } catch (err) {\r\n        const errorMessage =\r\n          typeof err === \"object\" && err instanceof Error\r\n            ? err.toString()\r\n            : String(err);\r\n        setCompilationError(errorMessage);\r\n        setVertexPipelineJob(undefined);\r\n        setVertexPipelineJsonBlobUrl(undefined);\r\n      }\r\n    }\r\n  }, [componentSpec, pipelineArguments, gcsOutputDirectory]);\r\n\r\n  const readyToSubmit =\r\n    project !== \"\" && region !== \"\" && vertexPipelineJob !== undefined;\r\n\r\n  return (\r\n    <form\r\n      onSubmit={async (e) => {\r\n        e.preventDefault();\r\n        if (vertexPipelineJob === undefined) {\r\n          return;\r\n        }\r\n        setPipelineJobWebUrl(undefined);\r\n        try {\r\n          // setItem might throw exception on iOS in incognito mode\r\n          try {\r\n            window.localStorage?.setItem(LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY, gcsOutputDirectory);\r\n            window.localStorage?.setItem(LOCAL_STORAGE_PROJECT_ID_KEY, project);\r\n            window.localStorage?.setItem(LOCAL_STORAGE_REGION_KEY, region);\r\n          } catch(err) {\r\n            console.error(\"GoogleCloudSubmitter: Error writing properties to the localStorage\", err);\r\n          }\r\n          const displayName = (\r\n            (componentSpec?.name ?? \"Pipeline\") +\r\n            \" \" +\r\n            new Date().toISOString().replace(\"T\", \" \").replace(\"Z\", \"\")\r\n          ).substring(0, 127);\r\n          const desiredPipelineJobId = displayName\r\n            .toLowerCase()\r\n            .replace(/[^-a-z0-9]/g, \"-\")\r\n            .replace(/^-+/, \"\"); // No leading dashes\r\n          vertexPipelineJob.displayName = displayName;\r\n          const result = await aiplatformCreatePipelineJob(\r\n            project,\r\n            region,\r\n            vertexPipelineJob,\r\n            googleCloudOAuthClientId,\r\n            desiredPipelineJobId\r\n          );\r\n          const pipelineJobName: string = result.name;\r\n          const pipelineJobId = pipelineJobName.split('/').slice(-1)[0];\r\n          const pipelineJobWebUrl = `https://console.cloud.google.com/vertex-ai/locations/${region}/pipelines/runs/${pipelineJobId}?project=${project}`;\r\n          setPipelineJobWebUrl(pipelineJobWebUrl);\r\n          setError(\"\");\r\n        } catch (err: any) {\r\n          console.error(err);\r\n          setError(err?.result?.error?.message ?? \"Error\");\r\n          (window as any).gtag?.(\"event\", \"GoogleCloud_submit_pipeline_job\", {\r\n            result: \"failed\"\r\n          });\r\n        }\r\n      }}\r\n    >\r\n      <div style={{\r\n        whiteSpace: \"nowrap\",\r\n        margin: \"5px\",\r\n      }}>\r\n        <label htmlFor=\"project\">Project: </label>\r\n        <input\r\n          id=\"project\"\r\n          required\r\n          type=\"text\"\r\n          list=\"projects\"\r\n          placeholder=\"<my-project-id>\"\r\n          value={project}\r\n          onChange={(e) => setProject(e.target.value)}\r\n        />\r\n        <datalist id=\"projects\">\r\n          {projects.map((projectId) => (\r\n            <option key={projectId} value={projectId} />\r\n          ))}\r\n        </datalist>\r\n        <button\r\n          type=\"button\" // The default button type is \"submit\", not \"button\". WTF!?\r\n          onClick={async (e) => {\r\n            try {\r\n              const result = await cloudresourcemanagerListProjects(\r\n                googleCloudOAuthClientId\r\n              );\r\n              const projectIds = (result.projects as any[]).map<string>(\r\n                (projectInfo) => projectInfo.projectId\r\n              );\r\n              setProjects(projectIds);\r\n              setError(\"\");\r\n              try {\r\n                window.localStorage?.setItem(LOCAL_STORAGE_PROJECT_IDS_KEY, JSON.stringify(projectIds));\r\n              } catch(err) {\r\n                console.error(\"GoogleCloudSubmitter: Error writing properties to the localStorage\", err);\r\n              }\r\n              (window as any).gtag?.(\"event\", \"GoogleCloud_list_projects\", { result: \"succeeded\" });\r\n            } catch (err: any) {\r\n              console.error(err);\r\n              setError(err?.result?.error?.message ?? \"Error\");\r\n              (window as any).gtag?.(\"event\", \"GoogleCloud_list_projects\", { result: \"failed\" });\r\n            }\r\n          }}\r\n        >\r\n          {/*        */}\r\n        </button>\r\n      </div>\r\n      <div style={{\r\n        whiteSpace: \"nowrap\",\r\n        margin: \"5px\",\r\n      }}>\r\n        <label htmlFor=\"region\">Region: </label>\r\n        <input\r\n          id=\"region\"\r\n          required\r\n          type=\"text\"\r\n          list=\"regions\"\r\n          value={region}\r\n          onChange={(e) => setRegion(e.target.value)}\r\n        />\r\n        <datalist id=\"regions\">\r\n          {VERTEX_AI_PIPELINES_REGIONS.map((region) => (\r\n            <option key={region} value={region} />\r\n          ))}\r\n        </datalist>\r\n      </div>\r\n      <div style={{\r\n        whiteSpace: \"nowrap\",\r\n        margin: \"5px\",\r\n      }}>\r\n        <label htmlFor=\"region\">GCS dir: </label>\r\n        <input\r\n          id=\"gcsOutputDirectory\"\r\n          required\r\n          type=\"text\"\r\n          value={gcsOutputDirectory}\r\n          onChange={(e) => setGcsOutputDirectory(e.target.value)}\r\n        />\r\n      </div>\r\n      <div style={{\r\n        whiteSpace: \"nowrap\",\r\n        margin: \"5px\",\r\n      }}>\r\n        <input\r\n          type=\"submit\"\r\n          disabled={!readyToSubmit}\r\n          value=\"Submit pipeline job\"\r\n        />\r\n        {pipelineJobWebUrl && <a href={pipelineJobWebUrl} target=\"_blank\" rel=\"noreferrer\" style={{ margin: \"5px\" }}>Job</a>}\r\n      </div>\r\n      {vertexPipelineJsonBlobUrl !== undefined && (\r\n        <div\r\n          style={{\r\n            margin: \"5px\",\r\n          }}\r\n        >\r\n          Or download the{\" \"}\r\n          <a href={vertexPipelineJsonBlobUrl} download={\"vertex_pipeline_job.json\"}>\r\n            pipeline_job.json\r\n          </a>{\" \"}\r\n          file, then go to{\" \"}\r\n          <a href=\"https://console.cloud.google.com/vertex-ai/pipelines\">\r\n            Vertex Pipelines\r\n          </a>{\" \"}\r\n          and{\" \"}\r\n          <a href=\"https://cloud.google.com/vertex-ai/docs/pipelines/run-pipeline#console\">\r\n            create a new run\r\n          </a>\r\n          .\r\n        </div>\r\n      )}\r\n      {compilationError && <div>{compilationError}</div>}\r\n      {error && <div>Error: {error}</div>}\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default GoogleCloudSubmitter;\r\n","/**\r\n * @license\r\n * Copyright 2022 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2022 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  ArgumentType,\r\n  ComponentSpec,\r\n  StringOrPlaceholder,\r\n  isContainerImplementation,\r\n  isGraphImplementation,\r\n  InputSpec,\r\n} from \"../../componentSpec\";\r\n\r\nimport { assertDefined, notUndefined } from \"../../utils\";\r\n\r\nimport * as argo from \"./argo-workflows/ui/src/models/workflows\";\r\n\r\nexport type {\r\n  Workflow,\r\n  WorkflowSpec,\r\n} from \"./argo-workflows/ui/src/models/workflows\";\r\n\r\n// # How to handle I/O:\r\n// Rules (might have exceptions)\r\n// output = output artifact\r\n// inputValue => input parameter\r\n// inputPath => input artifact\r\n// # Fixing conflicts:\r\n// 1) Artifact (may only come from task output) is consumed as value.\r\n//   Solution 1): Change input from parameter to artifact and use the input.artifact.value placeholder.\r\n//      Cons: The downstream component input definitions depend on arguments. (Some inputs are changed from parameter to artifact.)\r\n//            Argo does not support artifact value placeholder.\r\n//   Solution 2): Add parameter output (with the same name as the artifact output) to the upstream component. The paths should be the same, so a single file will be treated as both parameter and output.\r\n//      Cons: The upstream component output definitions depend on downstream consumption style. (Although parameter outputs are added, not changed.)\r\n//   Solution 3) (implemented): Insert a \"Downloader\" task (artifact to parameter) between upstream and downstream.\r\n//      Cons: Extra container task\r\n// 2) Parameter (pipeline input or constant value) is consumed as artifact (as file).\r\n//   Solution 0) (used): Argo directly supports \"raw\" artifacts.\r\n//   Solution 1): Insert an \"Uploader\" task to convert parameter to artifact.\r\n//      Cons: Extra container task\r\n\r\n// Argo directly supports pipeline artifact arguments.\r\n// Argo supports raw artifacts. So consuming constant strings is trivial. (Also parameter task outputs if they existed)\r\n// Argo does *not* support artifact.value placeholder.\r\n//\r\n// Problem: Artifact is consumed as parameter (as value):\r\n//   In the Kubeflow Pipelines compiler I've implemented Solution 2: I modify the upstream template to produce output parameter in addition to output artifact\r\n//   In this compiler I've implemented artifact-to-parameter converter task (~Solution 3)\r\n\r\n// General compilation logic sequence to compile artifacts vs parameters:\r\n// 1. Generate command line (in some cases (e.g. Vertex Pipelines) following hints about the argument source kind).\r\n// 2. Generate input definitions based on how the arguments are consumed.\r\n// 3. Generate task arguments based on task arguments and input definitions. Insert converters if incompatible.\r\n\r\n// TODO: Include the KFP-compatible original component spec in the compiled workflow (as a template annotation).\r\n// TODO: Include the KFP-compatible input/output name and type mapping in the compiled workflow (as a template annotation).\r\n\r\nconst CONTAINER_INPUTS_DIR = \"/tmp/inputs\";\r\nconst CONTAINER_OUTPUTS_DIR = \"/tmp/outputs\";\r\nconst IO_FILE_NAME = \"data\";\r\n\r\nconst sanitizeParameterOrArtifactName = (name: string) => {\r\n  return name.replaceAll(/[^-a-zA-Z0-9_]/g, \"-\");\r\n};\r\n\r\nconst sanitizeID = (name: string) => {\r\n  const sanitized1 = name.replaceAll(/[^-a-zA-Z0-9]/g, \"-\");\r\n  const sanitized2 =\r\n    sanitized1.length === 0 || sanitized1[0].match(/[^a-zA-Z0-9]/g)\r\n      ? \"id\" + sanitized1\r\n      : sanitized1;\r\n  return sanitized2;\r\n};\r\n\r\ntype ResolvedCommandLineAndArgs = {\r\n  command?: string[];\r\n  args?: string[];\r\n  inputsConsumedAsParameter: Set<string>;\r\n  inputsConsumedAsArtifact: Set<string>;\r\n};\r\n\r\nconst resolveCommandLine = (\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>\r\n): ResolvedCommandLineAndArgs => {\r\n  if (!isContainerImplementation(componentSpec.implementation)) {\r\n    throw Error(\"resolveCommandLine only supports container components\");\r\n  }\r\n  const containerSpec = componentSpec.implementation.container;\r\n\r\n  const inputsConsumedAsParameter = new Set<string>();\r\n  const inputsConsumedAsArtifact = new Set<string>();\r\n  const convertArg = (arg: StringOrPlaceholder): string[] => {\r\n    if (typeof arg == \"string\") {\r\n      return [arg];\r\n    } else if (\"inputValue\" in arg) {\r\n      const inputName = arg.inputValue;\r\n      // TODO: Replace with proper name mapping to prevent collisions after sanitization.\r\n      const argoInputName = sanitizeParameterOrArtifactName(inputName);\r\n      // Argo does not support {{inputs.artifacts.${inputName}.value}}, so there is only one way\r\n      inputsConsumedAsParameter.add(inputName);\r\n      return [`{{inputs.parameters.${argoInputName}}}`];\r\n    } else if (\"inputPath\" in arg) {\r\n      const inputName = arg.inputPath;\r\n      // TODO: Replace with proper name mapping to prevent collisions after sanitization.\r\n      const argoInputName = sanitizeParameterOrArtifactName(inputName);\r\n      inputsConsumedAsArtifact.add(inputName);\r\n      return [`{{inputs.artifacts.${argoInputName}.path}}`];\r\n    } else if (\"outputPath\" in arg) {\r\n      const outputName = arg.outputPath;\r\n      // TODO: Replace with proper name mapping to prevent collisions after sanitization.\r\n      const argoOutputName = sanitizeParameterOrArtifactName(outputName);\r\n      return [`{{outputs.artifacts.${argoOutputName}.path}}`];\r\n    } else if (\"if\" in arg) {\r\n      const [ifCond, ifThen, ifElse] = [arg.if.cond, arg.if.then, arg.if.else];\r\n      // TODO: Check false values, not just check for true\r\n      let condEvaluatesToTrue = false;\r\n      if (typeof ifCond === \"string\") {\r\n        condEvaluatesToTrue = ifCond.toLowerCase() === \"true\";\r\n      } else if (typeof ifCond === \"boolean\") {\r\n        condEvaluatesToTrue = ifCond;\r\n      } else if (\"isPresent\" in ifCond) {\r\n        const inputName = ifCond.isPresent;\r\n        condEvaluatesToTrue = inputName in taskArguments;\r\n      } else if (\"inputValue\" in ifCond) {\r\n        const inputName = ifCond.inputValue;\r\n        if (!(inputName in taskArguments)) {\r\n          condEvaluatesToTrue = false;\r\n        } else {\r\n          const taskArgument = taskArguments[inputName];\r\n          if (typeof taskArgument === \"string\") {\r\n            condEvaluatesToTrue = taskArgument.toLowerCase() === \"true\";\r\n          } else {\r\n            throw Error(\r\n              \"Using runtime conditions in component command line placeholders is not supported yet.\"\r\n            );\r\n          }\r\n        }\r\n      } else {\r\n        throw Error(\"Unexpected condition kind: \" + ifCond);\r\n      }\r\n      const unresolvedArgs = condEvaluatesToTrue ? ifThen : ifElse;\r\n      if (unresolvedArgs === undefined) {\r\n        return [];\r\n      }\r\n      return unresolvedArgs.flatMap(convertArg);\r\n    } else if (\"concat\" in arg) {\r\n      const concatArgs = arg.concat;\r\n      return [concatArgs.flatMap(convertArg).join(\"\")];\r\n    } else {\r\n      throw Error(`Unknown kind of command-line argument: ${arg}`);\r\n    }\r\n  };\r\n\r\n  const result = {\r\n    command: containerSpec.command?.flatMap(convertArg),\r\n    args: containerSpec.args?.flatMap(convertArg),\r\n    inputsConsumedAsParameter: inputsConsumedAsParameter,\r\n    inputsConsumedAsArtifact: inputsConsumedAsArtifact,\r\n  };\r\n  return result;\r\n};\r\n\r\nconst MAKE_PARAMETER_TEMPLATE_ID = \"Convert artifact to parameter\";\r\nconst MAKE_PARAMETER_INPUT_NAME = \"artifact\";\r\nconst MAKE_PARAMETER_OUTPUT_NAME = \"parameter\";\r\n\r\nconst buildMakeParameterTaskSpec = (\r\n  artifactArgument: argo.Artifact\r\n): argo.DAGTask => {\r\n  const taskId = artifactArgument.from?.match(/{{tasks.([^.]+)./)?.[1];\r\n  const taskSpec: argo.DAGTask = {\r\n    name: \"<to be set later>\",\r\n    template: MAKE_PARAMETER_TEMPLATE_ID,\r\n    arguments: {\r\n      artifacts: [\r\n        // Setting the argument name\r\n        { ...artifactArgument, name: MAKE_PARAMETER_INPUT_NAME },\r\n      ],\r\n    },\r\n    dependencies: taskId === undefined ? undefined : [taskId],\r\n  };\r\n  return taskSpec;\r\n};\r\n\r\nconst makeParameterTemplate: argo.Template = {\r\n  name: MAKE_PARAMETER_TEMPLATE_ID,\r\n  inputs: {\r\n    artifacts: [\r\n      {\r\n        name: MAKE_PARAMETER_INPUT_NAME,\r\n        path:\r\n          CONTAINER_INPUTS_DIR +\r\n          \"/\" +\r\n          MAKE_PARAMETER_INPUT_NAME +\r\n          \"/\" +\r\n          IO_FILE_NAME,\r\n      },\r\n    ],\r\n  },\r\n  outputs: {\r\n    parameters: [\r\n      {\r\n        name: MAKE_PARAMETER_OUTPUT_NAME,\r\n        valueFrom: {\r\n          path:\r\n            CONTAINER_INPUTS_DIR +\r\n            \"/\" +\r\n            MAKE_PARAMETER_OUTPUT_NAME +\r\n            \"/\" +\r\n            IO_FILE_NAME,\r\n        },\r\n      },\r\n    ],\r\n  },\r\n  container: {\r\n    name: \"main\",\r\n    image: \"alpine\",\r\n    command: [\r\n      \"sh\",\r\n      \"-ec\",\r\n      'mkdir -p \"$(dirname \"$1\")\"; cp \"$0\" \"$1\"',\r\n      `{{inputs.artifacts.${MAKE_PARAMETER_INPUT_NAME}.path}}`,\r\n      `{{outputs.parameters.${MAKE_PARAMETER_OUTPUT_NAME}.path}}`,\r\n    ],\r\n  },\r\n};\r\n\r\nfunction buildArgoParameterArgument(\r\n  taskArgument: ArgumentType | undefined,\r\n  inputSpec: InputSpec,\r\n  upstreamCannotBeParameter: boolean,\r\n  addMakeParameterTaskAndGetParameterArgument: (\r\n    artifactArgument: argo.Artifact,\r\n    namePrefix?: string\r\n  ) => argo.Parameter\r\n): argo.Parameter {\r\n  if (taskArgument === undefined) {\r\n    if (inputSpec.default !== undefined) {\r\n      taskArgument = inputSpec.default;\r\n    } else {\r\n      if (inputSpec.optional === true) {\r\n        // TODO: Decide what the behavior should be\r\n        // throw Error(`Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`);\r\n        console.error(\r\n          `Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`\r\n        );\r\n        taskArgument = \"\";\r\n      } else {\r\n        throw Error(\r\n          `Argument was not provided for required input \"${inputSpec.name}\"`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  const argoInputName = sanitizeParameterOrArtifactName(inputSpec.name);\r\n  let result: argo.Parameter = {\r\n    name: argoInputName,\r\n  };\r\n  if (typeof taskArgument === \"string\") {\r\n    result.value = taskArgument;\r\n    return result;\r\n  } else if (\"graphInput\" in taskArgument) {\r\n    const argoGraphInputName = sanitizeParameterOrArtifactName(\r\n      taskArgument.graphInput.inputName\r\n    );\r\n    if (upstreamCannotBeParameter) {\r\n      const artifactArgument: argo.Artifact = {\r\n        name: \"<to be set later>\",\r\n        from: `{{inputs.artifacts.${argoGraphInputName}}}`,\r\n      };\r\n      const convertedParameterArgument =\r\n        addMakeParameterTaskAndGetParameterArgument(\r\n          artifactArgument,\r\n          \"Make parameter for \" + taskArgument.graphInput.inputName\r\n        );\r\n      result.value = convertedParameterArgument.value;\r\n    } else {\r\n      result.value = `{{inputs.parameters.${argoGraphInputName}}}`;\r\n    }\r\n\r\n    return result;\r\n  } else if (\"taskOutput\" in taskArgument) {\r\n    const taskOutputArgoOutputName = sanitizeParameterOrArtifactName(\r\n      taskArgument.taskOutput.outputName\r\n    );\r\n    // FIX: !! Sanitizing the ID here is not enough. There needs to be proper ID mapping.\r\n    // FIX: Task IDs might conflict after sanitization\r\n    const taskOutputArgoTaskId = sanitizeID(taskArgument.taskOutput.taskId);\r\n    const artifactArgument: argo.Artifact = {\r\n      name: \"<to be set later>\",\r\n      from: `{{tasks.${taskOutputArgoTaskId}.outputs.artifacts.${taskOutputArgoOutputName}}}`,\r\n    };\r\n    // TODO: Maybe use the taskArgument as part of the name?\r\n    const convertedParameterArgument =\r\n      addMakeParameterTaskAndGetParameterArgument(\r\n        artifactArgument,\r\n        `Make parameter for ${taskArgument.taskOutput.taskId} output ${taskArgument.taskOutput.outputName}`\r\n      );\r\n    result.value = convertedParameterArgument.value;\r\n    return result;\r\n  } else {\r\n    throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n  }\r\n}\r\n\r\nfunction buildArgoArtifactArgument(\r\n  taskArgument: ArgumentType | undefined,\r\n  inputSpec: InputSpec\r\n) {\r\n  //if (! (inputName in taskArguments)) {\r\n  if (taskArgument === undefined) {\r\n    // Checking for default value\r\n    if (inputSpec.default !== undefined) {\r\n      taskArgument = inputSpec.default;\r\n    } else {\r\n      if (inputSpec.optional === true) {\r\n        // TODO: Decide what the behavior should be\r\n        // throw Error(`Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`);\r\n        console.error(\r\n          `Input \"${inputSpec.name}\" is optional, but command-line still uses it when when it's not present.`\r\n        );\r\n        taskArgument = \"\";\r\n      } else {\r\n        throw Error(\r\n          `Argument was not provided for required input \"${inputSpec.name}\"`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  const inputArgoName = sanitizeParameterOrArtifactName(inputSpec.name);\r\n  let result: argo.Artifact = {\r\n    name: inputArgoName,\r\n  };\r\n  if (typeof taskArgument === \"string\") {\r\n    result.raw = {\r\n      data: taskArgument,\r\n    };\r\n    return result;\r\n  } else if (\"graphInput\" in taskArgument) {\r\n    const graphInputArgoName = sanitizeParameterOrArtifactName(\r\n      taskArgument.graphInput.inputName\r\n    );\r\n    result.from = `{{inputs.artifacts.${graphInputArgoName}}}`;\r\n    return result;\r\n  } else if (\"taskOutput\" in taskArgument) {\r\n    // FIX: Task IDs might conflict after sanitization\r\n    // FIX: !! Need proper task ID mapping\r\n    const upstreamTaskOutputArgoName = sanitizeParameterOrArtifactName(\r\n      taskArgument.taskOutput.outputName\r\n    );\r\n    const upstreamTaskArgoId = sanitizeID(taskArgument.taskOutput.taskId);\r\n    result.from = `{{tasks.${upstreamTaskArgoId}.outputs.artifacts.${upstreamTaskOutputArgoName}}}`;\r\n    return result;\r\n  } else {\r\n    throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n  }\r\n}\r\n\r\nfunction buildArgoContainerTemplateFromContainerComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>\r\n) {\r\n  if (!isContainerImplementation(componentSpec.implementation)) {\r\n    throw Error(\"Only container components are supported by this function\");\r\n  }\r\n\r\n  const containerSpec = componentSpec.implementation.container;\r\n\r\n  const resolvedCommandLine = resolveCommandLine(componentSpec, taskArguments);\r\n\r\n  const argoTemplateInputs: argo.Inputs = {\r\n    parameters: Array.from(\r\n      resolvedCommandLine.inputsConsumedAsParameter.values()\r\n    ).map(\r\n      (inputName): argo.Parameter => ({\r\n        // TODO: Replace with proper name mapping to prevent collisions after sanitization.\r\n        name: sanitizeParameterOrArtifactName(inputName),\r\n        // TODO: Enable if needed (after verifying that it works).\r\n        // default: inputMap.get(inputName)?.default,\r\n        // TODO: Enable after verifying the required Argo version.\r\n        // description: inputMap.get(inputName)?.description,\r\n      })\r\n    ),\r\n    artifacts: Array.from(\r\n      resolvedCommandLine.inputsConsumedAsArtifact.values()\r\n    ).map(\r\n      (inputName): argo.Artifact => ({\r\n        // TODO: Replace with proper name mapping to prevent collisions after sanitization.\r\n        name: sanitizeParameterOrArtifactName(inputName),\r\n        // Sanitizing the output directory name to prevent potential issues.\r\n        path:\r\n          CONTAINER_INPUTS_DIR +\r\n          \"/\" +\r\n          inputName.replaceAll(/[/. ]/g, \"_\") +\r\n          \"/\" +\r\n          IO_FILE_NAME,\r\n        // TODO: Enable this default value feature if needed (after verifying that it works).\r\n        //raw: { data: inputMap.get(inputName)?.default },\r\n      })\r\n    ),\r\n  };\r\n\r\n  const argoTemplateOutputs: argo.Outputs = {\r\n    parameters: [],\r\n    artifacts: (componentSpec.outputs ?? []).map(\r\n      (outputSpec): argo.Artifact => ({\r\n        // TODO: Replace with proper name mapping to prevent collisions after sanitization.\r\n        name: sanitizeParameterOrArtifactName(outputSpec.name),\r\n        // I've encountered a bug where Argo fails to capture output from a directory with spaces.\r\n        // So I'm sanitizing the output directory name.\r\n        path:\r\n          CONTAINER_OUTPUTS_DIR +\r\n          \"/\" +\r\n          outputSpec.name.replaceAll(/[/. ]/g, \"_\") +\r\n          \"/\" +\r\n          IO_FILE_NAME,\r\n      })\r\n    ),\r\n  };\r\n\r\n  const argoTemplate: argo.Template = {\r\n    name: \"<to be set later>\",\r\n    inputs: argoTemplateInputs,\r\n    outputs: argoTemplateOutputs,\r\n    container: {\r\n      name: \"main\",\r\n      image: containerSpec.image,\r\n      command: resolvedCommandLine.command,\r\n      args: resolvedCommandLine.args,\r\n      // TODO: env:\r\n    },\r\n  };\r\n  return argoTemplate;\r\n}\r\n\r\nfunction buildArgoDagTemplateFromGraphComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  inputsThatHaveParameterArguments: Set<string>,\r\n  addTemplateAndGetId: (template: argo.Template, namePrefix?: string) => string\r\n) {\r\n  if (!isGraphImplementation(componentSpec.implementation)) {\r\n    throw Error(\"Only graph components are supported by this function\");\r\n  }\r\n\r\n  const graphSpec = componentSpec.implementation.graph;\r\n\r\n  let argoTasks: Record<string, argo.DAGTask> = {};\r\n  const taskStringToTaskId = new Map<string, string>();\r\n\r\n  // Only used in addMakeParameterTaskAndGetParameterArgument\r\n  // We probably should not de-duplicate any user tasks (some components might be volatile).\r\n  // TODO: Refactor away this code.\r\n  const addTaskAndGetId = (task: argo.DAGTask, namePrefix: string = \"Task\") => {\r\n    // Erasing the name, so that the structure can be used for lookup.\r\n    // We will generate the ID in this function and set name to it.\r\n    const taskCopyForHash: argo.DAGTask = { ...task, name: \"\" };\r\n    const serializedSpec = JSON.stringify(taskCopyForHash);\r\n    const existingId = taskStringToTaskId.get(serializedSpec);\r\n    if (existingId !== undefined) {\r\n      return existingId;\r\n    }\r\n    const usedIds = new Set(Object.keys(argoTasks));\r\n    const id = makeNameUniqueByAddingIndex(namePrefix, usedIds, sanitizeID);\r\n    taskStringToTaskId.set(serializedSpec, id);\r\n    argoTasks[id] = task;\r\n    // Setting the task name to the generated ID\r\n    task.name = id;\r\n    return id;\r\n  };\r\n\r\n  const addMakeParameterTaskAndGetParameterArgument = (\r\n    artifactArgument: argo.Artifact,\r\n    namePrefix: string = \"Make artifact\"\r\n  ) => {\r\n    // These system names are expected to not conflict with user task names\r\n    const makeArtifactTemplateId = addTemplateAndGetId(\r\n      makeParameterTemplate,\r\n      MAKE_PARAMETER_TEMPLATE_ID\r\n    );\r\n    const makeArtifactTaskSpec = buildMakeParameterTaskSpec(artifactArgument);\r\n    makeArtifactTaskSpec.template = makeArtifactTemplateId;\r\n    const taskId = addTaskAndGetId(makeArtifactTaskSpec, namePrefix);\r\n    const parameterArgument: argo.Parameter = {\r\n      name: \"<to be set later>\",\r\n      value: `{{tasks.${taskId}.outputs.parameters.${MAKE_PARAMETER_OUTPUT_NAME}}}`,\r\n    };\r\n    return parameterArgument;\r\n  };\r\n\r\n  for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n    if (taskSpec.componentRef.spec === undefined) {\r\n      throw Error(`Task \"${taskId}\" does not have taskSpec.componentRef.spec.`);\r\n    }\r\n    try {\r\n      const argoTask = buildArgoDagTaskFromTaskSpec(\r\n        taskSpec.componentRef.spec,\r\n        taskSpec.arguments ?? {},\r\n        inputsThatHaveParameterArguments,\r\n        addTemplateAndGetId,\r\n        addMakeParameterTaskAndGetParameterArgument\r\n      );\r\n      if (taskId in argoTasks) {\r\n        throw Error(\r\n          `Task ID \"${taskId}\" is not unique. This cannot happen (unless user task ID clashes with special task ID).`\r\n        );\r\n      }\r\n      // FIX: Need to establish task id->name mappings\r\n      // We should establish the mapping before processing any tasks and then pass it to buildArgoDagTaskFromTaskSpec calls.\r\n      // Without prior mapping, de-duplicating tasks breaks task output references.\r\n      const argoTaskId = sanitizeID(taskId);\r\n      argoTask.name = argoTaskId;\r\n      argoTasks[argoTaskId] = argoTask;\r\n    } catch (err) {\r\n      if (err instanceof Error) {\r\n        err.message = `Error compiling task ${taskId}: ` + err.message;\r\n      }\r\n      throw err;\r\n    }\r\n  }\r\n\r\n  // Scanning the compiled tasks to understand how the inputs are consumed.\r\n  const argoInputsConsumedAsParameter = new Set<string>();\r\n  const argoInputsConsumedAsArtifact = new Set<string>();\r\n  for (const argoTask of Object.values(argoTasks)) {\r\n    for (const argument of Object.values(\r\n      argoTask.arguments?.parameters ?? {}\r\n    )) {\r\n      const argoInputName = argument.value?.match(\r\n        /\\{\\{inputs\\.parameters\\.([^}]+)}}/\r\n      )?.[1];\r\n      if (argoInputName !== undefined) {\r\n        // TODO: Input name mapping\r\n        argoInputsConsumedAsParameter.add(argoInputName);\r\n      }\r\n    }\r\n    for (const argument of Object.values(argoTask.arguments?.artifacts ?? {})) {\r\n      const argoInputName = argument.from?.match(\r\n        /\\{\\{inputs\\.artifacts\\.([^}]+)}}/\r\n      )?.[1];\r\n      if (argoInputName !== undefined) {\r\n        argoInputsConsumedAsArtifact.add(argoInputName);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Sanity checks\r\n  // This is probably not an error for this Argo compiler.\r\n  // There are two options when dealing with inputs consumed both ways: Deal with at the lowest level it happens or let it propagate upstream (using this strategy for now).\r\n  // const inputNamesThatAreUsedBothAsParameterAndArtifact = Array.from(\r\n  //   inputsConsumedAsParameter\r\n  // ).filter((x) => inputsConsumedAsArtifact.has(x));\r\n  // if (inputNamesThatAreUsedBothAsParameterAndArtifact.length > 0) {\r\n  //   throw Error(\r\n  //     `Compiler error: When compiling component \"${componentSpec.name}\" some inputs are used both as parameter and artifact: \"${inputNamesThatAreUsedBothAsParameterAndArtifact}\". Please file a bug report.`\r\n  //   );\r\n  // }\r\n  // const inputNamesThatAreParametersButAreConsumedAsArtifacts = Array.from(\r\n  //   inputsThatHaveParameterArguments\r\n  // ).filter((x) => inputsConsumedAsArtifact.has(x));\r\n  // if (inputNamesThatAreParametersButAreConsumedAsArtifacts.length > 0) {\r\n  //   throw Error(\r\n  //     `Compiler error: When compiling component \"${componentSpec.name}\" some parameter arguments are consumed as artifact: \"${inputNamesThatAreParametersButAreConsumedAsArtifacts}\". Please file a bug report.`\r\n  //   );\r\n  // }\r\n\r\n  // We assume that the graphSpec.outputValues has same set of keys as component outputs.\r\n  // However even if there is discrepancy, the graphSpec.outputValues is the \"practical\" source of truth.\r\n  const dagOutputArtifactSources = Object.entries(\r\n    graphSpec.outputValues ?? {}\r\n  ).map(([outputName, taskOutputArgument]) => {\r\n    const outputArgoName = sanitizeParameterOrArtifactName(outputName);\r\n    const upstreamTaskOutputArgoName = sanitizeParameterOrArtifactName(\r\n      taskOutputArgument.taskOutput.outputName\r\n    );\r\n    // FIX: !! Need proper id mapping\r\n    const upstreamTaskArgoId = sanitizeID(taskOutputArgument.taskOutput.taskId);\r\n    const result: argo.Artifact = {\r\n      name: outputArgoName,\r\n      from: `{{tasks.${upstreamTaskArgoId}.outputs.artifacts.${upstreamTaskOutputArgoName}}}`,\r\n    };\r\n    return result;\r\n  });\r\n\r\n  const argoTemplateInputs: argo.Inputs = {\r\n    parameters: Array.from(argoInputsConsumedAsParameter.values()).map(\r\n      (argoInputName): argo.Parameter => ({\r\n        name: argoInputName,\r\n      })\r\n    ),\r\n    artifacts: Array.from(argoInputsConsumedAsArtifact.values()).map(\r\n      (argoInputName): argo.Artifact => ({ name: argoInputName })\r\n    ),\r\n  };\r\n\r\n  const argoTemplateOutputs: argo.Outputs = {\r\n    // parameters: [], // ! Dag output parameters use .valueFrom.parameter\r\n    artifacts: dagOutputArtifactSources,\r\n  };\r\n\r\n  const vertexComponentSpec: argo.Template = {\r\n    name: \"<to be set later>\",\r\n    inputs: argoTemplateInputs,\r\n    outputs: argoTemplateOutputs,\r\n    // Argo also supports containerSet. It's like a DAG template, but runs in a single Pod and can share data via shared volume.\r\n    dag: {\r\n      // TODO: Stabilize the ordering\r\n      tasks: Object.values(argoTasks),\r\n    },\r\n  };\r\n  return vertexComponentSpec;\r\n}\r\n\r\nfunction buildArgoTemplateFromComponentSpec(\r\n  componentSpec: ComponentSpec,\r\n  taskArguments: Record<string, ArgumentType>,\r\n  inputsThatHaveParameterArguments: Set<string>,\r\n  addTemplateAndGetId: (template: argo.Template, namePrefix?: string) => string\r\n) {\r\n  if (isContainerImplementation(componentSpec.implementation)) {\r\n    return buildArgoContainerTemplateFromContainerComponentSpec(\r\n      componentSpec,\r\n      taskArguments\r\n    );\r\n  } else if (isGraphImplementation(componentSpec.implementation)) {\r\n    return buildArgoDagTemplateFromGraphComponentSpec(\r\n      componentSpec,\r\n      inputsThatHaveParameterArguments,\r\n      addTemplateAndGetId\r\n    );\r\n  } else {\r\n    throw Error(\r\n      `Unsupported component implementation kind: ${componentSpec.implementation}`\r\n    );\r\n  }\r\n}\r\n\r\nconst buildArgoDagTaskFromTaskSpec = (\r\n  componentSpec: ComponentSpec,\r\n  //passedArgumentNames: string[],\r\n  taskArguments: Record<string, ArgumentType>,\r\n  graphInputsWithParameterArguments: Set<string>,\r\n  addTemplateAndGetId: (template: argo.Template, namePrefix?: string) => string,\r\n  addMakeParameterTaskAndGetParameterArgument: (\r\n    artifactArgument: argo.Artifact,\r\n    namePrefix?: string\r\n  ) => argo.Parameter\r\n) => {\r\n  // FIX: !! This part is likely broken or not needed.\r\n  // So-called \"parameter\" arguments can either be constant arguments\r\n  // or come from the arguments to the graph component of the current task.\r\n  // In the current implementation the parameter arguments cannot come from task outputs since all task outputs are artifacts.\r\n  const inputsThatHaveParameterArguments = new Set(\r\n    (componentSpec.inputs ?? [])\r\n      .map((inputSpec) => inputSpec.name)\r\n      .filter((inputName) => {\r\n        const taskArgument = taskArguments[inputName];\r\n        if (taskArgument === undefined) {\r\n          // Missing arguments fall back to default values which are constant strings which are parameters.\r\n          return true;\r\n        }\r\n        if (typeof taskArgument === \"string\") {\r\n          return true;\r\n        }\r\n        if (\"graphInput\" in taskArgument) {\r\n          if (\r\n            graphInputsWithParameterArguments.has(\r\n              taskArgument.graphInput.inputName\r\n            )\r\n          ) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      })\r\n  );\r\n\r\n  const inputMap = new Map(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => [inputSpec.name, inputSpec])\r\n  );\r\n\r\n  const inputNameToArgoInputName = new Map(\r\n    Array.from(inputMap.keys()).map((name) => [\r\n      name,\r\n      sanitizeParameterOrArtifactName(name),\r\n    ])\r\n  );\r\n\r\n  const argoInputNameToInputName = new Map(\r\n    Array.from(inputNameToArgoInputName.entries()).map(([name, argoName]) => [\r\n      argoName,\r\n      name,\r\n    ])\r\n  );\r\n\r\n  const argoTemplate: argo.Template = buildArgoTemplateFromComponentSpec(\r\n    componentSpec,\r\n    taskArguments,\r\n    inputsThatHaveParameterArguments,\r\n    addTemplateAndGetId\r\n  );\r\n\r\n  const argoTemplateId = addTemplateAndGetId(\r\n    argoTemplate,\r\n    componentSpec.name ?? \"Component\"\r\n  );\r\n\r\n  const argoTaskParameterArguments: argo.Parameter[] = (\r\n    argoTemplate.inputs?.parameters ?? []\r\n  ).map((parameter) => {\r\n    const argoInputName = parameter.name;\r\n    const inputName = assertDefined(\r\n      argoInputNameToInputName.get(argoInputName)\r\n    );\r\n    const inputSpec = assertDefined(inputMap.get(inputName));\r\n    return {\r\n      ...buildArgoParameterArgument(\r\n        taskArguments[inputName],\r\n        inputSpec,\r\n        inputsThatHaveParameterArguments.has(inputName),\r\n        addMakeParameterTaskAndGetParameterArgument\r\n      ),\r\n      // buildArgoParameterArgument does not set parameter name, so we set it here.\r\n      name: argoInputName,\r\n    };\r\n  });\r\n\r\n  const argoTaskArtifactArguments: argo.Artifact[] = (\r\n    argoTemplate.inputs?.artifacts ?? []\r\n  ).map((artifact) => {\r\n    const argoInputName = artifact.name;\r\n    const inputName = assertDefined(\r\n      argoInputNameToInputName.get(argoInputName)\r\n    );\r\n    const inputSpec = assertDefined(inputMap.get(inputName));\r\n    return {\r\n      ...buildArgoArtifactArgument(taskArguments[inputName], inputSpec),\r\n      // buildArgoArtifactArgument does not set artifact name, so we set it here.\r\n      name: argoInputName,\r\n    };\r\n  });\r\n  // We need to scan compiled arguments: The upstream could have been changed to a \"convert artifact to parameter\" task.\r\n  // So it's better to extract the dependency data from the compiled arguments instead of using the original argument map.\r\n  // const upstreamTaskIds = new Set(\r\n  //   Object.values(taskArguments)\r\n  //     .map((argument) => {\r\n  //       if (typeof argument !== \"string\" && \"taskOutput\" in argument) {\r\n  //         return argument.taskOutput.taskId;\r\n  //       } else {\r\n  //         return undefined;\r\n  //       }\r\n  //     })\r\n  //     .filter(notUndefined)\r\n  // );\r\n  // // FIX: !! Need proper id mapping\r\n  // const upstreamArgoTaskIds = Array.from(upstreamTaskIds.keys()).map(\r\n  //   sanitizeID\r\n  // );\r\n  const argoArgumentValues = argoTaskParameterArguments\r\n    .map((arg) => arg.value)\r\n    .concat(argoTaskArtifactArguments.map((arg) => arg.from))\r\n    .filter(notUndefined);\r\n  // Dependencies should be unique. Otherwise Argo considers the workflow to be invalid.\r\n  const upstreamArgoTaskIds = new Set(\r\n    argoArgumentValues\r\n      .map((arg) => arg.match(/{{tasks.([^.]+).outputs./)?.[1])\r\n      .filter(notUndefined)\r\n  );\r\n\r\n  const argoDagTask: argo.DAGTask = {\r\n    name: \"<to be set later>\",\r\n    template: argoTemplateId,\r\n    arguments: {\r\n      parameters: argoTaskParameterArguments,\r\n      artifacts: argoTaskArtifactArguments,\r\n    },\r\n    // FIX: Fix Argo's behavior when depending on conditionally skipped tasks\r\n    dependencies: Array.from(upstreamArgoTaskIds.values()).sort(),\r\n  };\r\n\r\n  return argoDagTask;\r\n};\r\n\r\nconst makeNameUniqueByAddingIndex = (\r\n  name: string,\r\n  existingNames: Set<string>,\r\n  sanitizer: (name: string) => string = (x) => x,\r\n  delimiter: string = \"-\"\r\n): string => {\r\n  let finalName = sanitizer(name);\r\n  let index = 1;\r\n  while (existingNames.has(finalName)) {\r\n    index++;\r\n    const newFinalName = sanitizer(name + delimiter + index.toString());\r\n    if (newFinalName === finalName) {\r\n      throw Error(\r\n        `The name sanitizer seems to truncate the name which makes it impossible to make the name unique. ${newFinalName}`\r\n      );\r\n    }\r\n    finalName = newFinalName;\r\n  }\r\n  return finalName;\r\n};\r\n\r\nexport const buildArgoWorkflowSpecFromGraphComponentSpec = (\r\n  componentSpec: ComponentSpec\r\n) => {\r\n  let argoTemplates: Record<string, argo.Template> = {};\r\n\r\n  const templateStringToTemplateId = new Map<string, string>();\r\n\r\n  const addTemplateAndGetId = (\r\n    template: argo.Template,\r\n    namePrefix: string = \"Component\"\r\n  ) => {\r\n    // Erasing the name, so that the structure can be used for lookup.\r\n    // We will generate the ID in this function and set name to it.\r\n    const templateCopyForHash: argo.Template = { ...template, name: \"\" };\r\n    const serializedSpec = JSON.stringify(templateCopyForHash);\r\n    const existingId = templateStringToTemplateId.get(serializedSpec);\r\n    if (existingId !== undefined) {\r\n      return existingId;\r\n    }\r\n    const usedIds = new Set(Object.keys(argoTemplates));\r\n    // Note: The generated ID should be used without changes (e.g. sanitization).\r\n    // Otherwise the result of de-duplication will be incorrect.\r\n    const id = makeNameUniqueByAddingIndex(\r\n      namePrefix,\r\n      usedIds,\r\n      sanitizeID,\r\n    );\r\n    templateStringToTemplateId.set(serializedSpec, id);\r\n    argoTemplates[id] = template;\r\n    // Setting the template name to the generated ID\r\n    template.name = id;\r\n    return id;\r\n  };\r\n\r\n  // Argo supports both pipeline and artifact arguments for pipeline.\r\n  const graphInputsWithParameterArguments = new Set<string>();\r\n\r\n  const pipelineArguments: Record<string, ArgumentType> = Object.fromEntries(\r\n    (componentSpec.inputs ?? []).map((inputSpec) => {\r\n      const argument: ArgumentType = {\r\n        graphInput: { inputName: inputSpec.name },\r\n      };\r\n      return [inputSpec.name, argument];\r\n    })\r\n  );\r\n  const rootArgoTemplate = buildArgoTemplateFromComponentSpec(\r\n    componentSpec,\r\n    pipelineArguments,\r\n    graphInputsWithParameterArguments,\r\n    addTemplateAndGetId\r\n  );\r\n\r\n  const rootArgoTemplateId = addTemplateAndGetId(\r\n    rootArgoTemplate,\r\n    componentSpec.name ?? \"Root\"\r\n  );\r\n\r\n  const workflowSpec: argo.WorkflowSpec = {\r\n    // Arguments will be set later\r\n    // arguments: {\r\n    //   parameters: [],\r\n    //   artifacts: [],\r\n    // },\r\n    entrypoint: rootArgoTemplateId,\r\n    // FIX: ! Stabilize template order\r\n    templates: Object.values(argoTemplates),\r\n  };\r\n  return workflowSpec;\r\n};\r\n\r\nexport const buildArgoWorkflowFromGraphComponent = (\r\n  componentSpec: ComponentSpec,\r\n  pipelineArguments: Map<string, string>\r\n) => {\r\n  const workflowSpec =\r\n    buildArgoWorkflowSpecFromGraphComponentSpec(componentSpec);\r\n\r\n  // Adding the default values\r\n  const defaultInputValuePairs = (componentSpec.inputs ?? [])\r\n    .filter((inputSpec) => inputSpec.default !== undefined)\r\n    .map((inputSpec): [string, string] => [\r\n      inputSpec.name,\r\n      String(inputSpec.default),\r\n    ]);\r\n  // TODO: Throw exception when non-default arguments are missing.\r\n  const allPipelineArguments = new Map(\r\n    defaultInputValuePairs.concat(Array.from(pipelineArguments.entries()))\r\n  );\r\n\r\n  // Converting the pipeline arguments\r\n  const templateMap = new Map(\r\n    workflowSpec.templates?.map((template) => [template.name, template])\r\n  );\r\n  const rootTemplate = assertDefined(\r\n    templateMap.get(assertDefined(workflowSpec.entrypoint))\r\n  );\r\n  const inputParameterNames =\r\n    rootTemplate?.inputs?.parameters?.map((parameter) => parameter.name) ?? [];\r\n  const inputArtifactsNames =\r\n    rootTemplate?.inputs?.artifacts?.map((artifact) => artifact.name) ?? [];\r\n\r\n  const pipelineArgumentsWithArgoNames = new Map(\r\n    Array.from(allPipelineArguments.entries()).map(([key, value]) => [\r\n      sanitizeParameterOrArtifactName(key),\r\n      value,\r\n    ])\r\n  );\r\n  const convertedPipelineArguments: argo.Arguments = {\r\n    parameters: inputParameterNames\r\n      .filter((name) => pipelineArgumentsWithArgoNames.has(name))\r\n      .map(\r\n        (argoInputName): argo.Parameter => ({\r\n          name: argoInputName,\r\n          value: pipelineArgumentsWithArgoNames.get(argoInputName),\r\n        })\r\n      ),\r\n    artifacts: inputArtifactsNames\r\n      .filter((name) => pipelineArgumentsWithArgoNames.has(name))\r\n      .map(\r\n        (argoInputName): argo.Artifact => ({\r\n          name: argoInputName,\r\n          raw: {\r\n            data: assertDefined(\r\n              pipelineArgumentsWithArgoNames.get(argoInputName)\r\n            ),\r\n          },\r\n        })\r\n      ),\r\n  };\r\n\r\n  // Setting the pipeline arguments\r\n  workflowSpec.arguments = convertedPipelineArguments;\r\n\r\n  // TODO: Sanitize better\r\n  const workflowKubernetesName = (\r\n    componentSpec.name?.toLowerCase().replace(/[^-a-z0-9.]/g, \"-\") || \"Pipeline\"\r\n  ).substring(0, 240); // 253 max\r\n\r\n  const workflow: argo.Workflow = {\r\n    apiVersion: \"argoproj.io/v1alpha1\",\r\n    kind: \"Workflow\",\r\n    metadata: {\r\n      generateName: workflowKubernetesName,\r\n      annotations: {\r\n        \"cloud-pipelines.net/pipeline-editor\": \"true\",\r\n      },\r\n    },\r\n    spec: workflowSpec,\r\n  };\r\n  return workflow;\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2022 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2022 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport yaml from \"js-yaml\";\r\nimport { useEffect, useState } from \"react\";\r\nimport {\r\n  buildArgoWorkflowFromGraphComponent,\r\n  Workflow,\r\n} from \"../compilers/Argo/argoCompiler\";\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { ensureGoogleCloudAuthorizesScopes } from \"./GoogleCloud\";\r\n\r\nconst LOCAL_STORAGE_ENDPOINT_KEY = \"KubeflowPipelinesSubmitter/endpoint\";\r\nconst LOCAL_STORAGE_AUTH_TOKEN_KEY = \"KubeflowPipelinesSubmitter/auth_token\";\r\n\r\nconst kfpSubmitPipelineRun = async (\r\n  argoWorkflowSpec: Record<string, any>,\r\n  endpoint: string,\r\n  authToken?: string,\r\n  googleCloudOAuthClientId?: string,\r\n  runName?: string\r\n) => {\r\n  // https://www.kubeflow.org/docs/components/pipelines/reference/api/kubeflow-pipeline-api-spec/#/definitions/apiRun\r\n  const kfpRun = {\r\n    name: runName ?? argoWorkflowSpec.name ?? \"Pipeline\",\r\n    pipeline_spec: {\r\n      workflow_manifest: JSON.stringify(argoWorkflowSpec),\r\n    },\r\n  };\r\n  if (!endpoint.includes(\"://\")) {\r\n    console.warn(\"Endpoint URL does not specify a protocol. Using HTTPS.\");\r\n    endpoint = \"https://\" + endpoint;\r\n  }\r\n  if (!endpoint.endsWith(\"/\")) {\r\n    endpoint = endpoint + \"/\";\r\n  }\r\n  const apiUrl = endpoint + \"apis/v1beta1/runs\";\r\n  if (!authToken) {\r\n    // Auth token not specified. Authenticating the request using Google Cloud\r\n    if (googleCloudOAuthClientId) {\r\n      const oauthToken = await ensureGoogleCloudAuthorizesScopes(\r\n        googleCloudOAuthClientId,\r\n        [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n      );\r\n      authToken = oauthToken?.access_token;\r\n    }\r\n  }\r\n  const response = await fetch(apiUrl, {\r\n    method: \"POST\",\r\n    body: JSON.stringify(kfpRun),\r\n    headers: new Headers({\r\n      Authorization: \"Bearer \" + authToken,\r\n    }),\r\n  });\r\n  (window as any).gtag?.(\r\n    \"event\",\r\n    \"KubeflowPipelinesSubmitter_submit_pipeline_run_succeeded\",\r\n    {}\r\n  );\r\n  return response.json();\r\n};\r\n\r\nconst generateKfpRunUrl = (endpoint: string, runId: string) => {\r\n  //https://xxx-dot-us-central2.pipelines.googleusercontent.com/#/runs/details/<runId>\r\n  if (!endpoint.includes(\"://\")) {\r\n    endpoint = \"https://\" + endpoint;\r\n  }\r\n  if (!endpoint.endsWith(\"/\")) {\r\n    endpoint = endpoint + \"/\";\r\n  }\r\n  return endpoint + \"#/runs/details/\" + runId;\r\n};\r\n\r\ninterface KubeflowPipelinesSubmitterProps {\r\n  componentSpec?: ComponentSpec;\r\n  pipelineArguments?: Map<string, string>;\r\n  googleCloudOAuthClientId?: string;\r\n}\r\n\r\nconst KubeflowPipelinesSubmitter = ({\r\n  componentSpec,\r\n  pipelineArguments,\r\n  googleCloudOAuthClientId,\r\n}: KubeflowPipelinesSubmitterProps) => {\r\n  const [argoWorkflow, setArgoWorkflow] = useState<Workflow | undefined>(\r\n    undefined\r\n  );\r\n  const [argoWorkflowYamlBlobUrl, setArgoWorkflowYamlBlobUrl] = useState<\r\n    string | undefined\r\n  >(undefined);\r\n  const [compilationError, setCompilationError] = useState<string | undefined>(\r\n    undefined\r\n  );\r\n  const [submissionError, setSubmissionError] = useState<string | undefined>(\r\n    undefined\r\n  );\r\n  const [endpoint, setEndpoint] = useState<string>(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_ENDPOINT_KEY) ?? \"\"\r\n  );\r\n  const [authToken, setAuthToken] = useState<string>(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_AUTH_TOKEN_KEY) ?? \"\"\r\n  );\r\n  const [, setPipelineRunId] = useState<string | undefined>(undefined);\r\n  const [, setWorkflowResourceName] = useState<string | undefined>(undefined);\r\n  const [pipelineRunWebUrl, setPipelineRunWebUrl] = useState<\r\n    string | undefined\r\n  >(undefined);\r\n\r\n  useEffect(() => {\r\n    if (componentSpec !== undefined) {\r\n      try {\r\n        const argoWorkflow = buildArgoWorkflowFromGraphComponent(\r\n          componentSpec,\r\n          pipelineArguments ?? new Map()\r\n        );\r\n        argoWorkflow.metadata.labels = {\r\n          sdk: \"cloud-pipelines-editor\",\r\n          \"cloud-pipelines.net/pipeline-editor\": \"true\",\r\n          \"pipelines.kubeflow.org/pipeline-sdk-type\": \"cloud-pipelines-editor\",\r\n        };\r\n        setArgoWorkflow(argoWorkflow);\r\n        const argoWorkflowYaml = yaml.dump(argoWorkflow, {\r\n          lineWidth: -1, // Don't fold long strings\r\n          quotingType: '\"',\r\n        });\r\n        const newArgoWorkflowYamlBlobUrl = URL.createObjectURL(\r\n          new Blob([argoWorkflowYaml], { type: \"application/yaml\" })\r\n        );\r\n        // Updating the workflow blob URL (revoking the old workflow blob URL first).\r\n        setArgoWorkflowYamlBlobUrl((currentArgoWorkflowYamlBlobUrl) => {\r\n          if (currentArgoWorkflowYamlBlobUrl !== undefined) {\r\n            URL.revokeObjectURL(currentArgoWorkflowYamlBlobUrl);\r\n          }\r\n          return newArgoWorkflowYamlBlobUrl;\r\n        });\r\n        setCompilationError(undefined);\r\n      } catch (err) {\r\n        const errorMessage =\r\n          typeof err === \"object\" && err instanceof Error\r\n            ? err.toString()\r\n            : String(err);\r\n        setCompilationError(errorMessage);\r\n      }\r\n    }\r\n  }, [componentSpec, pipelineArguments]);\r\n\r\n  const readyToSubmit = endpoint && argoWorkflow;\r\n\r\n  return (\r\n    <form\r\n      onSubmit={async (e) => {\r\n        e.preventDefault();\r\n        if (!endpoint || !argoWorkflow) {\r\n          return;\r\n        }\r\n        setPipelineRunWebUrl(undefined);\r\n        try {\r\n          // setItem might throw exception on iOS in incognito mode\r\n          try {\r\n            window.localStorage?.setItem(LOCAL_STORAGE_ENDPOINT_KEY, endpoint);\r\n            window.localStorage?.setItem(\r\n              LOCAL_STORAGE_AUTH_TOKEN_KEY,\r\n              authToken\r\n            );\r\n          } catch (err) {\r\n            console.error(\r\n              \"KubeflowPipelinesSubmitter: Error writing properties to the localStorage\",\r\n              err\r\n            );\r\n          }\r\n          const runName =\r\n            (componentSpec?.name ?? \"Pipeline\") +\r\n            \" \" +\r\n            new Date().toISOString().replace(\"T\", \" \").replace(\"Z\", \"\");\r\n          const result = await kfpSubmitPipelineRun(\r\n            argoWorkflow,\r\n            endpoint,\r\n            authToken,\r\n            googleCloudOAuthClientId,\r\n            runName\r\n          );\r\n          console.debug(result);\r\n          const runId = result?.run?.id;\r\n          if (typeof runId === \"string\") {\r\n            setPipelineRunId(runId);\r\n            const runUrl = generateKfpRunUrl(endpoint, runId);\r\n            setPipelineRunWebUrl(runUrl);\r\n          }\r\n          const runtimeWorkflowManifestString =\r\n            result?.pipeline_runtime?.workflow_manifest;\r\n          if (typeof runtimeWorkflowManifestString === \"string\") {\r\n            const runtimeWorkflowManifest = JSON.parse(\r\n              runtimeWorkflowManifestString\r\n            );\r\n            const resourceName = runtimeWorkflowManifest?.metadata?.name;\r\n            if (resourceName) {\r\n              setWorkflowResourceName(resourceName);\r\n            }\r\n          }\r\n          setSubmissionError(undefined);\r\n        } catch (err: any) {\r\n          console.error(err);\r\n          const errorMessage =\r\n            typeof err === \"object\" && err instanceof Error\r\n              ? err.toString()\r\n              : String(err);\r\n          setSubmissionError(errorMessage);\r\n          (window as any).gtag?.(\r\n            \"event\",\r\n            \"KubeflowPipelinesSubmitter_submit_pipeline_run_failed\",\r\n            {}\r\n          );\r\n        }\r\n      }}\r\n    >\r\n      <div\r\n        style={{\r\n          whiteSpace: \"nowrap\",\r\n          margin: \"5px\",\r\n        }}\r\n      >\r\n        <label htmlFor=\"Endpoint\">Endpoint: </label>\r\n        <input\r\n          id=\"Endpoint\"\r\n          required\r\n          type=\"text\"\r\n          placeholder=\"https://xxx.pipelines.googleusercontent.com/\"\r\n          title=\"https://xxx-dot-us-central2.pipelines.googleusercontent.com/\"\r\n          value={endpoint}\r\n          onChange={(e) => setEndpoint(e.target.value)}\r\n        />\r\n      </div>\r\n      <div\r\n        style={{\r\n          whiteSpace: \"nowrap\",\r\n          margin: \"5px\",\r\n        }}\r\n      >\r\n        <label htmlFor=\"Token\">Token: </label>\r\n        <input\r\n          id=\"Token\"\r\n          type=\"text\"\r\n          placeholder=\"ya29...\"\r\n          title=\"Authorization Bearer token\"\r\n          value={authToken}\r\n          onChange={(e) => setAuthToken(e.target.value)}\r\n        />\r\n      </div>\r\n      <div\r\n        style={{\r\n          whiteSpace: \"nowrap\",\r\n          margin: \"5px\",\r\n        }}\r\n      >\r\n        <input\r\n          type=\"submit\"\r\n          disabled={!readyToSubmit}\r\n          value=\"Submit pipeline\"\r\n        />\r\n        {pipelineRunWebUrl && (\r\n          <a\r\n            href={pipelineRunWebUrl}\r\n            target=\"_blank\"\r\n            rel=\"noreferrer\"\r\n            style={{ margin: \"5px\" }}\r\n          >\r\n            Run\r\n          </a>\r\n        )}\r\n      </div>\r\n      {argoWorkflowYamlBlobUrl && (\r\n        <div\r\n          style={{\r\n            margin: \"5px\",\r\n          }}\r\n        >\r\n          {/* TODO: Use pipeline name for the file name */}\r\n          Or download the{\" \"}\r\n          <a href={argoWorkflowYamlBlobUrl} download={\"kubeflow_pipeline.yaml\"}>\r\n            kubeflow_pipeline.yaml\r\n          </a>\r\n        </div>\r\n      )}\r\n      {compilationError && <div>{compilationError}</div>}\r\n      {submissionError && <div>Error: {submissionError}</div>}\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default KubeflowPipelinesSubmitter;\r\n","/**\r\n * @license\r\n * Copyright 2022 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2022 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useEffect, useState } from \"react\";\r\nimport { ArgumentType, ComponentSpec } from \"../componentSpec\";\r\nimport ArgumentsEditor from \"./ArgumentsEditor\";\r\nimport GoogleCloudSubmitter from \"./GoogleCloud\";\r\nimport KubeflowPipelinesSubmitter from \"./KubeflowPipelinesSubmitter\";\r\n\r\ninterface PipelineSubmitterProps {\r\n  componentSpec?: ComponentSpec;\r\n  googleCloudOAuthClientId: string;\r\n}\r\n\r\nconst PipelineSubmitter = ({\r\n  componentSpec,\r\n  googleCloudOAuthClientId,\r\n}: PipelineSubmitterProps) => {\r\n  const [pipelineArguments, setPipelineArguments] = useState<\r\n    Record<string, ArgumentType>\r\n  >({});\r\n\r\n  const [stringPipelineArguments, setStringPipelineArguments] =\r\n    useState<Map<string, string>>(new Map());\r\n\r\n  useEffect(() => {\r\n    // This filtering is just for typing as the pipeline arguments can only be strings here.\r\n    const newStringPipelineArguments = new Map(\r\n      Object.entries(pipelineArguments).filter(\r\n        // Type guard predicate\r\n        (pair): pair is [string, string] => typeof pair[1] === \"string\"\r\n      )\r\n    );\r\n    setStringPipelineArguments(newStringPipelineArguments)\r\n  }, [pipelineArguments]);\r\n\r\n  return (\r\n    <>\r\n      {componentSpec === undefined || // This check is redundant, but TypeScript needs it.\r\n      (componentSpec?.inputs?.length ?? 0) === 0 ? undefined : (\r\n        <fieldset\r\n          style={{\r\n            // Reduce the default padding\r\n            padding: \"2px\",\r\n            marginBottom: \"4px\",\r\n          }}\r\n        >\r\n          <legend>Arguments</legend>\r\n          <ArgumentsEditor\r\n            componentSpec={componentSpec}\r\n            componentArguments={pipelineArguments}\r\n            setComponentArguments={setPipelineArguments}\r\n            shrinkToWidth={true}\r\n          />\r\n        </fieldset>\r\n      )}\r\n      <details\r\n        style={{\r\n          border: \"1px solid #aaa\",\r\n          borderRadius: \"4px\",\r\n          padding: \"4px\",\r\n        }}\r\n      >\r\n        <summary\r\n          style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}\r\n        >\r\n          Submit to Google Cloud\r\n        </summary>\r\n        <GoogleCloudSubmitter\r\n          componentSpec={componentSpec}\r\n          pipelineArguments={stringPipelineArguments}\r\n          googleCloudOAuthClientId={googleCloudOAuthClientId}\r\n        />\r\n      </details>\r\n      <details\r\n        style={{\r\n          border: \"1px solid #aaa\",\r\n          borderRadius: \"4px\",\r\n          padding: \"4px\",\r\n        }}\r\n      >\r\n        <summary\r\n          style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}\r\n        >\r\n          Submit to Kubeflow Pipelines\r\n        </summary>\r\n        <KubeflowPipelinesSubmitter\r\n          componentSpec={componentSpec}\r\n          pipelineArguments={stringPipelineArguments}\r\n          googleCloudOAuthClientId={googleCloudOAuthClientId}\r\n        />\r\n      </details>\r\n    </>\r\n  );\r\n};\r\n\r\nexport default PipelineSubmitter;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useStoreState } from \"react-flow-renderer\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { componentSpecToYaml } from \"../componentStore\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\n\r\ninterface GraphComponentLinkProps {\r\n  componentSpec: ComponentSpec;\r\n  downloadFileName?: string;\r\n  linkText?: string;\r\n  linkRef?: React.Ref<HTMLAnchorElement>;\r\n  style?: React.CSSProperties;\r\n}\r\n\r\nconst GraphComponentLink = ({\r\n  componentSpec,\r\n  downloadFileName = \"component.yaml\",\r\n  linkText = \"component.yaml\",\r\n  linkRef,\r\n  style,\r\n}: GraphComponentLinkProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  try {\r\n    componentSpec = augmentComponentSpec(componentSpec, nodes, false, true);\r\n  } catch (err: any) {\r\n    if (err?.message?.startsWith(\"The nodes array does not\") !== true) {\r\n      console.error(err);\r\n      return <>err.toString()</>;\r\n    }\r\n  }\r\n  const componentText = componentSpecToYaml(componentSpec);\r\n  const componentTextBlob = new Blob([componentText], { type: \"text/yaml\" }); // Or application/x-yaml (which leads to downloading)\r\n  return (\r\n    <a\r\n      ref={linkRef}\r\n      href={URL.createObjectURL(componentTextBlob)}\r\n      download={downloadFileName}\r\n      style={style}\r\n    >\r\n      {linkText}\r\n    </a>\r\n  );\r\n};\r\n\r\nexport default GraphComponentLink;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useState, useEffect } from \"react\";\r\nimport { DownloadDataType, downloadDataWithCache, loadObjectFromYamlData } from \"../cacheUtils\";\r\nimport { ComponentReference, ComponentSpec } from \"../componentSpec\";\r\nimport {\r\n  ComponentReferenceWithSpec,\r\n  fullyLoadComponentRefFromUrl,\r\n} from \"../componentStore\";\r\n\r\ntype PipelineLibraryStruct = {\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n  components: ComponentReference[];\r\n};\r\n\r\nconst isValidPipelineLibraryStruct = (\r\n  obj: object\r\n): obj is PipelineLibraryStruct => \"components\" in obj;\r\n\r\nconst loadPipelineLibraryStructFromData = async (\r\n  data: ArrayBuffer,\r\n) => {\r\n  const pipelineLibrary = loadObjectFromYamlData(data);\r\n  if (!isValidPipelineLibraryStruct(pipelineLibrary)) {\r\n    throw Error(`Invalid Component library data structure: ${pipelineLibrary}`);\r\n  }\r\n  return pipelineLibrary;\r\n};\r\n\r\nconst loadPipelineLibraryStructFromUrl = async (\r\n  url: string,\r\n  downloadData: DownloadDataType = downloadDataWithCache,\r\n) => {\r\n  const pipelineLibrary = await downloadData(url, loadPipelineLibraryStructFromData);\r\n  return pipelineLibrary;\r\n};\r\n\r\nfunction notUndefined<T>(x: T | undefined): x is T {\r\n  return x !== undefined;\r\n}\r\n\r\ninterface PipelineLibraryProps {\r\n  pipelineLibraryUrl: string;\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void;\r\n  downloadData: DownloadDataType;\r\n}\r\n\r\nconst SamplePipelineLibrary = ({\r\n  pipelineLibraryUrl,\r\n  setComponentSpec,\r\n  downloadData = downloadDataWithCache\r\n}: PipelineLibraryProps) => {\r\n  const [componentRefs, setComponentRefs] = useState<\r\n    ComponentReferenceWithSpec[]\r\n  >([]);\r\n\r\n  useEffect(() => {\r\n    (async () => {\r\n      if (componentRefs.length === 0) {\r\n        try {\r\n          const loadedComponentLibrary = await loadPipelineLibraryStructFromUrl(\r\n            pipelineLibraryUrl,\r\n            downloadData\r\n          );\r\n          const pipelineUrls = loadedComponentLibrary.components\r\n            .map((componentRef) => componentRef.url)\r\n            .filter(notUndefined);\r\n          const loadedComponentRefs = await Promise.all(\r\n            pipelineUrls.map((url) =>\r\n              fullyLoadComponentRefFromUrl(url, downloadData)\r\n            )\r\n          );\r\n          setComponentRefs(loadedComponentRefs);\r\n        } catch (err) {\r\n          console.error(err);\r\n        }\r\n      }\r\n    })();\r\n  }, [pipelineLibraryUrl, downloadData, componentRefs.length]);\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        //border: \"1px solid black\",\r\n        overflow: \"auto\",\r\n        whiteSpace: \"nowrap\",\r\n      }}\r\n    >\r\n      <div style={{ overflow: \"auto\", marginLeft: \"10px\" }}>\r\n        {componentRefs.map((componentRef) => (\r\n          <div key={componentRef.digest}>\r\n             {/*    */}\r\n            <button\r\n              className=\"link-button\"\r\n              onClick={(e) => {\r\n                setComponentSpec?.(componentRef.spec);\r\n              }}\r\n            >\r\n              {componentRef.spec.name ?? \"<Pipeline>\"}\r\n            </button>\r\n          </div>\r\n        ))}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SamplePipelineLibrary;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport {\r\n  Button,\r\n  Dialog,\r\n  DialogActions,\r\n  DialogContent,\r\n  DialogTitle,\r\n  Menu,\r\n  MenuItem,\r\n  TextField,\r\n} from \"@material-ui/core\";\r\nimport { useCallback, useState, useEffect, useRef } from \"react\";\r\nimport { useStoreState } from \"react-flow-renderer\";\r\nimport { DownloadDataType, downloadDataWithCache } from \"../cacheUtils\";\r\nimport { ComponentSpec, isGraphImplementation } from \"../componentSpec\";\r\nimport {\r\n  loadComponentAsRefFromText,\r\n  getAllComponentFilesFromList,\r\n  ComponentFileEntry,\r\n  addComponentToListByText,\r\n  componentSpecToYaml,\r\n  writeComponentToFileListFromText,\r\n  getComponentFileFromList,\r\n  deleteComponentFileFromList,\r\n} from \"../componentStore\";\r\nimport GraphComponentLink from \"./GraphComponentLink\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\nimport SamplePipelineLibrary from \"./SamplePipelineLibrary\";\r\nimport { preloadComponentReferences } from \"../componentStore\";\r\n\r\nconst USER_PIPELINES_LIST_NAME = \"user_pipelines\";\r\n\r\ninterface PipelineLibraryProps {\r\n  componentSpec?: ComponentSpec;\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void;\r\n  samplePipelineLibraryUrl?: string;\r\n  downloadData: DownloadDataType;\r\n}\r\n\r\nconst removeSuffixes = (s: string, suffixes: string[]) => {\r\n  for (const suffix of suffixes) {\r\n    if (s.endsWith(suffix)) {\r\n      s = s.substring(0, s.length - suffix.length);\r\n    }\r\n  }\r\n  return s;\r\n};\r\n\r\ninterface SavePipelineAsDialogProps {\r\n  isOpen: boolean;\r\n  onPipelineSave: (name: string, overwrite: boolean) => Promise<void>;\r\n  onCancel: () => void;\r\n  initialName?: string;\r\n}\r\n\r\nconst SavePipelineAsDialog = ({\r\n  isOpen,\r\n  onPipelineSave,\r\n  onCancel,\r\n  initialName,\r\n}: SavePipelineAsDialogProps) => {\r\n  const [fileName, setFileName] = useState<string | undefined>(initialName);\r\n  const [isOverwriteDialogOpen, setIsOverwriteDialogOpen] = useState(false);\r\n\r\n  const handleSave = async (name: string) => {\r\n    setFileName(name);\r\n    try {\r\n      await onPipelineSave(name, false);\r\n    } catch {\r\n      setIsOverwriteDialogOpen(true);\r\n    }\r\n  };\r\n\r\n  const handleOverwriteOk = () => {\r\n    if (fileName) {\r\n      setIsOverwriteDialogOpen(false);\r\n      onPipelineSave(fileName, true);\r\n    }\r\n  };\r\n\r\n  const handleOverwriteCancel = () => {\r\n    setIsOverwriteDialogOpen(false);\r\n  };\r\n\r\n  return (\r\n    <>\r\n      <SaveAsDialog\r\n        isOpen={isOpen}\r\n        onSave={handleSave}\r\n        onCancel={onCancel}\r\n        initialValue={fileName}\r\n        inputLabel=\"Pipeline name\"\r\n      />\r\n      <OkCancelDialog\r\n        isOpen={isOpen && isOverwriteDialogOpen}\r\n        title=\"Overwrite?\"\r\n        okButtonText=\"Overwrite\"\r\n        onOk={handleOverwriteOk}\r\n        onCancel={handleOverwriteCancel}\r\n      />\r\n    </>\r\n  );\r\n};\r\n\r\ninterface OkCancelDialogProps {\r\n  isOpen: boolean;\r\n  title: string;\r\n  okButtonText?: string;\r\n  cancelButtonText?: string;\r\n  onOk: () => void;\r\n  onCancel: () => void;\r\n}\r\n\r\nconst OkCancelDialog = ({\r\n  isOpen,\r\n  title,\r\n  okButtonText = \"OK\",\r\n  cancelButtonText = \"Cancel\",\r\n  onOk,\r\n  onCancel,\r\n}: OkCancelDialogProps) => {\r\n  return (\r\n    <Dialog open={isOpen} aria-labelledby=\"alert-dialog-title\">\r\n      <DialogTitle id=\"alert-dialog-title\">{title}</DialogTitle>\r\n      <DialogActions>\r\n        <Button color=\"primary\" onClick={onCancel}>\r\n          {cancelButtonText}\r\n        </Button>\r\n        <Button color=\"secondary\" onClick={onOk}>\r\n          {okButtonText}\r\n        </Button>\r\n      </DialogActions>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\ninterface SaveAsDialogProps {\r\n  isOpen: boolean;\r\n  onSave: (name: string) => void;\r\n  onCancel: () => void;\r\n  initialValue: string | undefined;\r\n  inputLabel: string;\r\n}\r\n\r\nconst SaveAsDialog = ({\r\n  isOpen,\r\n  onSave,\r\n  onCancel,\r\n  initialValue,\r\n  inputLabel = \"Pipeline name\",\r\n}: SaveAsDialogProps) => {\r\n  const nameInputRef = useRef<HTMLInputElement>();\r\n  return (\r\n    <Dialog open={isOpen} aria-labelledby=\"alert-dialog-title\">\r\n      <DialogTitle id=\"alert-dialog-title\">{\"Save pipeline\"}</DialogTitle>\r\n      <form\r\n        onSubmit={(e) => {\r\n          if (nameInputRef.current) {\r\n            onSave(nameInputRef.current.value);\r\n          }\r\n          e.preventDefault();\r\n        }}\r\n      >\r\n        <DialogContent>\r\n          <TextField\r\n            id=\"name\"\r\n            type=\"text\"\r\n            defaultValue={initialValue}\r\n            label={inputLabel}\r\n            inputRef={nameInputRef}\r\n            required\r\n            autoFocus\r\n            fullWidth\r\n            margin=\"dense\"\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={onCancel}>Cancel</Button>\r\n          <Button color=\"primary\" type=\"submit\" autoFocus>\r\n            Save\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n};\r\n\r\nconst PipelineLibrary = ({\r\n  componentSpec,\r\n  setComponentSpec,\r\n  samplePipelineLibraryUrl,\r\n  downloadData = downloadDataWithCache\r\n}: PipelineLibraryProps) => {\r\n  // const [errorMessage, setErrorMessage] = useState(\"\");\r\n  const [componentFiles, setComponentFiles] = useState(\r\n    new Map<string, ComponentFileEntry>()\r\n  );\r\n  const [pipelineFile, setPipelineFile] = useState<ComponentFileEntry>();\r\n  const [saveAsDialogIsOpen, setSaveAsDialogIsOpen] = useState(false);\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  const [contextMenuFileName, setContextMenuFileName] = useState<string>();\r\n  const [contextMenuAnchor, setContextMenuAnchor] = useState<HTMLElement>();\r\n\r\n  const refreshPipelines = useCallback(() => {\r\n    getAllComponentFilesFromList(USER_PIPELINES_LIST_NAME).then(\r\n      setComponentFiles\r\n    );\r\n  }, [setComponentFiles]);\r\n\r\n  useEffect(refreshPipelines, [refreshPipelines]);\r\n\r\n  const openPipelineFile = useCallback(\r\n    async (fileEntry: ComponentFileEntry) => {\r\n      // Loading all child components\r\n      // TODO: Move this functionality to the setComponentSpec function\r\n      await preloadComponentReferences(\r\n        fileEntry.componentRef.spec,\r\n        downloadData\r\n      );\r\n      setComponentSpec?.(fileEntry.componentRef.spec);\r\n      setPipelineFile(fileEntry);\r\n    },\r\n    [setComponentSpec, setPipelineFile, downloadData]\r\n  );\r\n\r\n  const onDrop = useCallback(\r\n    (acceptedFiles: File[]) => {\r\n      acceptedFiles.forEach((file) => {\r\n        const reader = new FileReader();\r\n        reader.onabort = () => console.log(\"file reading was aborted\");\r\n        reader.onerror = () => console.log(\"file reading has failed\");\r\n        reader.onload = async () => {\r\n          const binaryStr = reader.result;\r\n          if (binaryStr === null || binaryStr === undefined) {\r\n            console.error(`Dropped file reader result was ${binaryStr}`);\r\n            return;\r\n          }\r\n          const fileName =\r\n            removeSuffixes(file.name, [\r\n              \".pipeline.component.yaml\",\r\n              \".component.yaml\",\r\n              \".pipeline.yaml\",\r\n              \".yaml\",\r\n            ]) || \"Pipeline\";\r\n          try {\r\n            const componentRef1 = await loadComponentAsRefFromText(\r\n              binaryStr\r\n            );\r\n            if (!isGraphImplementation(componentRef1.spec.implementation)) {\r\n              console.error(\"Dropped component is not a graph component\");\r\n              return;\r\n            }\r\n            // Caching the child components\r\n            await preloadComponentReferences(componentRef1.spec, downloadData);\r\n            // TODO: Do not load the component twice\r\n            const componentRefPlusData = await addComponentToListByText(\r\n              USER_PIPELINES_LIST_NAME,\r\n              binaryStr,\r\n              fileName\r\n            );\r\n            const componentRef = componentRefPlusData.componentRef;\r\n            console.debug(\"storeComponentText succeeded\", componentRef);\r\n            (window as any).gtag?.(\"event\", \"PipelineLibrary_pipeline_import\", {\r\n              result: \"succeeded\",\r\n            });\r\n            // setErrorMessage(\"\");\r\n            refreshPipelines();\r\n          } catch (err) {\r\n            // setErrorMessage(\r\n            //   `Error parsing the dropped file as component: ${err.toString()}.`\r\n            // );\r\n            console.error(\"Error parsing the dropped file as component\", err);\r\n            (window as any).gtag?.(\"event\", \"PipelineLibrary_pipeline_import\", {\r\n              result: \"failed\",\r\n            });\r\n          }\r\n        };\r\n        reader.readAsArrayBuffer(file);\r\n      });\r\n    },\r\n    [refreshPipelines, downloadData]\r\n  );\r\n\r\n  const openSaveAsDialog = useCallback(() => {\r\n    setSaveAsDialogIsOpen(true);\r\n  }, [setSaveAsDialogIsOpen]);\r\n\r\n  const closeSaveAsDialog = useCallback(() => {\r\n    setSaveAsDialogIsOpen(false);\r\n  }, [setSaveAsDialogIsOpen]);\r\n\r\n  const handlePipelineSave = useCallback(\r\n    async (name: string, overwrite: boolean = false) => {\r\n      if (!overwrite) {\r\n        const existingFileEntry = await getComponentFileFromList(\r\n          USER_PIPELINES_LIST_NAME,\r\n          name\r\n        );\r\n        if (existingFileEntry !== null) {\r\n          throw Error(`File \"${name}\" already exists.`);\r\n        }\r\n      }\r\n      if (!componentSpec) {\r\n        return;\r\n      }\r\n      const graphComponent = augmentComponentSpec(\r\n        componentSpec,\r\n        nodes,\r\n        false,\r\n        true\r\n      );\r\n      graphComponent.name = name;\r\n      const componentText = componentSpecToYaml(graphComponent);\r\n      const fileEntry = await writeComponentToFileListFromText(\r\n        USER_PIPELINES_LIST_NAME,\r\n        name,\r\n        componentText\r\n      );\r\n      await openPipelineFile(fileEntry);\r\n      closeSaveAsDialog();\r\n      refreshPipelines();\r\n    },\r\n    [\r\n      componentSpec,\r\n      closeSaveAsDialog,\r\n      nodes,\r\n      openPipelineFile,\r\n      refreshPipelines,\r\n    ]\r\n  );\r\n\r\n  const handleContextMenuDelete = async () => {\r\n    if (contextMenuFileName) {\r\n      setContextMenuFileName(undefined);\r\n      await deleteComponentFileFromList(\r\n        USER_PIPELINES_LIST_NAME,\r\n        contextMenuFileName\r\n      );\r\n      refreshPipelines();\r\n    }\r\n  };\r\n\r\n  const handleContextMenuOpen = async () => {\r\n    if (contextMenuFileName) {\r\n      setContextMenuFileName(undefined);\r\n      const fileEntry = await getComponentFileFromList(\r\n        USER_PIPELINES_LIST_NAME,\r\n        contextMenuFileName\r\n      );\r\n      if (!fileEntry) {\r\n        console.error(\r\n          `handleContextMenuOpen: File ${contextMenuFileName} does not exist.`\r\n        );\r\n        return;\r\n      }\r\n      await openPipelineFile(fileEntry);\r\n    }\r\n  };\r\n\r\n  const openSamplePipeline = useCallback(\r\n    (pipelineSpec) => {\r\n      //Reset current file\r\n      setPipelineFile(undefined);\r\n      setComponentSpec?.(pipelineSpec);\r\n    },\r\n    [setComponentSpec]\r\n  );\r\n\r\n  const fileInput = useRef<HTMLInputElement>(null);\r\n  const componentLink = useRef<HTMLAnchorElement>(null);\r\n\r\n  return (\r\n    <div\r\n      style={{\r\n        //border: \"1px solid black\",\r\n        overflow: \"auto\",\r\n        whiteSpace: \"nowrap\",\r\n      }}\r\n    >\r\n      <div style={{ margin: \"5px\" }}>\r\n        <button\r\n          onClick={(e) => {\r\n            if (pipelineFile) {\r\n              handlePipelineSave(pipelineFile?.name, true);\r\n            } else {\r\n              openSaveAsDialog();\r\n            }\r\n          }}\r\n        >\r\n          Save\r\n        </button>\r\n        <button onClick={openSaveAsDialog}>Save as</button>\r\n        {componentSpec && saveAsDialogIsOpen && (\r\n          <SavePipelineAsDialog\r\n            initialName={componentSpec.name}\r\n            isOpen={saveAsDialogIsOpen}\r\n            onCancel={closeSaveAsDialog}\r\n            onPipelineSave={handlePipelineSave}\r\n          />\r\n        )}\r\n        <input\r\n          ref={fileInput}\r\n          type=\"file\"\r\n          accept=\".yaml\"\r\n          onChange={(e) => onDrop(Array.from(e.target.files ?? []))}\r\n          style={{ display: \"none\" }}\r\n        />\r\n        <button onClick={(e) => fileInput.current?.click()}>+ Import</button>\r\n        <button\r\n          onClick={(e) => {\r\n            componentLink.current?.click();\r\n          }}\r\n        >\r\n          Export\r\n        </button>\r\n        {componentSpec && (\r\n          <GraphComponentLink\r\n            linkRef={componentLink}\r\n            componentSpec={componentSpec}\r\n            linkText=\"\"\r\n            downloadFileName={\r\n              (componentSpec.name ? componentSpec.name + \".\" : \"\") +\r\n              \"pipeline.component.yaml\"\r\n            }\r\n            style={{ textDecoration: \"none\" }}\r\n          />\r\n        )}\r\n      </div>\r\n      <div style={{ overflow: \"auto\", marginLeft: \"10px\" }}>\r\n        {Array.from(componentFiles.entries()).map(([fileName, fileEntry]) => (\r\n          <div key={fileName}>\r\n             {/*    */}\r\n            <button\r\n              className=\"link-button\"\r\n              onClick={(e) => openPipelineFile(fileEntry)}\r\n              style={\r\n                fileName === pipelineFile?.name\r\n                  ? { fontWeight: \"bold\" }\r\n                  : undefined\r\n              }\r\n              onContextMenu={(e) => {\r\n                e.preventDefault();\r\n                setContextMenuAnchor(e.currentTarget);\r\n                setContextMenuFileName(fileName);\r\n              }}\r\n            >\r\n              {fileName}\r\n            </button>\r\n          </div>\r\n        ))}\r\n        <Menu\r\n          open={contextMenuFileName !== undefined}\r\n          anchorEl={contextMenuAnchor}\r\n          onClose={() => {\r\n            setContextMenuFileName(undefined);\r\n          }}\r\n        >\r\n          <MenuItem dense={true} onClick={handleContextMenuOpen}>\r\n            Open\r\n          </MenuItem>\r\n          <MenuItem dense={true} onClick={handleContextMenuDelete}>\r\n            Delete\r\n          </MenuItem>\r\n        </Menu>\r\n      </div>\r\n      <details\r\n        open\r\n        style={{\r\n          border: \"1px solid #aaa\",\r\n          borderRadius: \"4px\",\r\n          padding: \"4px\",\r\n        }}\r\n      >\r\n        <summary>\r\n          <strong>Sample pipelines</strong>\r\n        </summary>\r\n        {samplePipelineLibraryUrl === undefined ? (\r\n          \"Sample pipeline library URL is undefined\"\r\n        ) : (\r\n          <SamplePipelineLibrary\r\n            setComponentSpec={openSamplePipeline}\r\n            pipelineLibraryUrl={samplePipelineLibraryUrl}\r\n            downloadData={downloadData}\r\n          />\r\n        )}\r\n      </details>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PipelineLibrary;\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport yaml from \"js-yaml\";\r\nimport localForage from \"localforage\";\r\nimport { DownloadDataType, downloadData as defaultDownloadData, downloadDataWithCache, loadObjectFromYamlData, loadObjectFromJsonData } from \"./cacheUtils\";\r\nimport {\r\n  ComponentSpec,\r\n  ComponentReference,\r\n  isValidComponentSpec,\r\n} from \"./componentSpec\";\r\nimport {\r\n  loadComponentFromUrlAsRef,\r\n  preloadComponentReferences,\r\n} from \"./componentStore\";\r\n\r\n// const COMPONENT_FILE_NAME_SUFFIX = \"component.yaml\";\r\n// const COMPONENT_FILE_MAX_SIZE = 100000;\r\n\r\n// IndexedDB: DB and table names\r\nconst DB_NAME = \"components\";\r\nconst HASH_TO_CONTENT_DB_TABLE_NAME = \"hash_to_data\";\r\nconst HASH_TO_COMPONENT_NAME_DB_TABLE_NAME = \"hash_to_component_name\";\r\nconst URL_TO_HASH_DB_TABLE_NAME = \"url_to_hash\";\r\nconst HASH_TO_URL_DB_TABLE_NAME = \"hash_to_url\";\r\nconst URL_PROCESSING_VERSION_TABLE_NAME = \"url_version\";\r\nconst CURRENT_URL_PROCESSING_VERSION = 1;\r\nconst BAD_HASHES_TABLE_NAME = \"bad_hashes\";\r\n\r\ntype GitHubCodeSearchResultsStruct = {\r\n  items: any[];\r\n};\r\n\r\nconst isValidGitHubCodeSearchResultsStruct = (\r\n  obj: any\r\n): obj is GitHubCodeSearchResultsStruct =>\r\n  \"items\" in obj && Array.isArray(obj.items);\r\n\r\nconst getSingleGitHubCodeSearchPage = async (\r\n  query: string,\r\n  page = 1,\r\n  sort = \"indexed\",\r\n  order = \"desc\",\r\n  downloadData: DownloadDataType = defaultDownloadData\r\n): Promise<GitHubCodeSearchResultsStruct> => {\r\n  // TODO: Paging\r\n  const encodedQuery = encodeURIComponent(query);\r\n  const encodedSort = encodeURIComponent(sort);\r\n  const encodedOrder = encodeURIComponent(order);\r\n  const searchUrl = `https://api.github.com/search/code?q=${encodedQuery}&sort=${encodedSort}&order=${encodedOrder}&per_page=100&page=${page}`;\r\n  const responseObject = await downloadData(searchUrl, loadObjectFromJsonData);\r\n  if (!isValidGitHubCodeSearchResultsStruct(responseObject)) {\r\n    throw Error(\r\n      \"The downloaded data is not a valid GitHub code search results page\"\r\n    );\r\n  }\r\n  return responseObject;\r\n};\r\n\r\nconst githubHtmlUrlToDownloadUrl = (htmlUrl: string): string => {\r\n  // https://github.com/               kubeflow/pipelines/blob/24bc9162a56c2fe3c50947d655ef280f71ba058f/components/gcp/dataflow/launch_flex_template/component.yaml\r\n  // https://raw.githubusercontent.com/kubeflow/pipelines     /24bc9162a56c2fe3c50947d655ef280f71ba058f/components/gcp/dataflow/launch_flex_template/component.yaml\r\n  return htmlUrl\r\n    .replace(\"https://github.com/\", \"https://raw.githubusercontent.com/\")\r\n    .replace(\"/blob/\", \"/\");\r\n};\r\n\r\ntype UrlAndHash = {\r\n  url: string;\r\n  hash: string;\r\n};\r\n\r\nasync function* searchComponentsOnGitHubToGetUrlsAndHashes(\r\n  searchLocations: string[]\r\n) {\r\n  let urlsAndHashes: UrlAndHash[] = [];\r\n  // TODO: If the number of components exceeds 1000 we should issue separate query for each location.\r\n  // TODO: Perhaps try to filter by component contents (inputValue, inputPath, outputPath, graph, implementation)\r\n  const queryParts = [\"filename:component.yaml\"].concat(searchLocations);\r\n  const query = queryParts.join(\" \");\r\n  for (let page = 1; page < 100; page++) {\r\n    const searchResults = await getSingleGitHubCodeSearchPage(\r\n      query,\r\n      page\r\n    );\r\n    // \"total_count\": 512,\r\n    // \"incomplete_results\": false,\r\n    // \"items\": [\r\n    const items: any[] = searchResults.items;\r\n    if (items.length === 0) {\r\n      break;\r\n    }\r\n    for (let item of items) {\r\n      yield {\r\n        url: githubHtmlUrlToDownloadUrl(item.html_url),\r\n        hash: item.sha as string,\r\n      };\r\n    }\r\n    await new Promise((resolve) =>\r\n      setTimeout(resolve, ((60 * 1000) / 10) * (1 + 0.1))\r\n    );\r\n  }\r\n  return urlsAndHashes;\r\n}\r\n\r\nconst importComponentsFromGitHubSearch = async (\r\n  searchLocations: string[],\r\n  downloadData: DownloadDataType = downloadDataWithCache\r\n) => {\r\n  console.debug(\"Starting importComponentsFromGitHubSearch\");\r\n  const urlsAndHashesIterator =\r\n    searchComponentsOnGitHubToGetUrlsAndHashes(searchLocations);\r\n\r\n  // const cache = await caches.open(BLOB_CACHE_NAME);\r\n  const urlToHashDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_TO_HASH_DB_TABLE_NAME,\r\n  });\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  const hashToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  const urlProcessingVersionDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_PROCESSING_VERSION_TABLE_NAME,\r\n  });\r\n  const badHashesDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: BAD_HASHES_TABLE_NAME,\r\n  });\r\n  for await (const item of urlsAndHashesIterator) {\r\n    const hash = item.hash.toLowerCase();\r\n    const htmlUrl = item.url;\r\n    const badHashReason = await badHashesDb.getItem<string>(hash);\r\n    if (badHashReason !== null) {\r\n      console.debug(\r\n        `Skipping url ${htmlUrl} with hash ${hash} due to error: \"${badHashReason}\"`\r\n      );\r\n      continue;\r\n    }\r\n    try {\r\n      const downloadUrl: string = githubHtmlUrlToDownloadUrl(htmlUrl);\r\n      if (!downloadUrl.endsWith(\"component.yaml\")) {\r\n        console.debug(\r\n          `Skipping url ${downloadUrl} since it does not end with \"component.yaml\"`\r\n        );\r\n        continue;\r\n      }\r\n      // Sanity check\r\n      const cachedHash = await urlToHashDb.getItem<string>(downloadUrl);\r\n      if (cachedHash !== null && cachedHash !== hash) {\r\n        console.error(\r\n          `Component cache is broken. Stored hash for ${downloadUrl}: ${cachedHash} != ${hash}.`\r\n        );\r\n      }\r\n      // Check whether the processing is complete\r\n      const urlVersion = await urlProcessingVersionDb.getItem<string>(\r\n        downloadUrl\r\n      );\r\n\r\n      if (\r\n        cachedHash !== null && // Not sure we should check this, but it improves the sanity\r\n        urlVersion !== null &&\r\n        Number.parseInt(urlVersion) >= CURRENT_URL_PROCESSING_VERSION\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      console.debug(`Processing new component candidate: ${downloadUrl}.`);\r\n      let componentSpec: ComponentSpec;\r\n      let componentText: string;\r\n      try {\r\n        // TODO: Consider fully preloading graph component children here.\r\n        const componentRef = await loadComponentFromUrlAsRef(\r\n          downloadUrl,\r\n          downloadData\r\n        );\r\n        componentText = componentRef.text;\r\n        componentSpec = componentRef.spec;\r\n      } catch (err) {\r\n        const errorMessage =\r\n          typeof err === \"object\" && err ? err.toString() : String(err);\r\n        badHashesDb.setItem(hash, errorMessage);\r\n        continue;\r\n      }\r\n\r\n      // Blobs are cumbersome (need await to get text) - store text instead\r\n      // await hashToContentDb.setItem(hash, data);\r\n      await hashToContentDb.setItem(hash, componentText);\r\n\r\n      // Only adding hash -> URL once\r\n      const urlForHash = await hashToUrlDb.getItem<string>(hash);\r\n      if (urlForHash === null) {\r\n        await hashToUrlDb.setItem(hash, downloadUrl);\r\n      }\r\n\r\n      // Only storing names when they exist\r\n      if (componentSpec.name) {\r\n        await hashToComponentNameDb.setItem(hash, componentSpec.name);\r\n      }\r\n\r\n      await urlToHashDb.setItem(downloadUrl, hash);\r\n\r\n      // Marking the processing as completed\r\n      await urlProcessingVersionDb.setItem(\r\n        downloadUrl,\r\n        CURRENT_URL_PROCESSING_VERSION\r\n      );\r\n    } catch (err) {\r\n      console.error(\r\n        `Error when processing component candidate ${htmlUrl} Error: ${err}.`\r\n      );\r\n    }\r\n  }\r\n  console.debug(\"Finished importComponentsFromGitHubSearch\");\r\n};\r\n\r\ninterface ComponentFeedEntry {\r\n  componentRef: ComponentReference;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n  data: string;\r\n}\r\n\r\ninterface ComponentFeed {\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n  components: ComponentFeedEntry[];\r\n}\r\n\r\n// Type guards\r\nconst isComponentFeedEntry = (obj: any): obj is ComponentFeedEntry =>\r\n  \"componentRef\" in obj;\r\n\r\nconst isComponentFeedEntryArray = (obj: any): obj is ComponentFeedEntry[] =>\r\n  Array.isArray(obj) && obj.every(isComponentFeedEntry);\r\n\r\nconst isComponentFeed = (obj: any): obj is ComponentFeed =>\r\n  typeof obj === \"object\" &&\r\n  \"components\" in obj &&\r\n  isComponentFeedEntryArray(obj[\"components\"]);\r\n\r\nfunction notUndefined<T>(x: T | undefined): x is T {\r\n  return x !== undefined;\r\n}\r\n\r\nconst calculateGitBlobSha1HashHex = async (data: string | ArrayBuffer) => {\r\n  // TODO: Avoid string roundtrip\r\n  const dataString =\r\n    typeof data === \"string\" ? data : new TextDecoder().decode(data);\r\n  const gitDataString =\r\n    \"blob \" + dataString.length.toString() + \"\\0\" + dataString;\r\n  const gitDataBytes = new TextEncoder().encode(gitDataString);\r\n  const hashBuffer = await crypto.subtle.digest(\"SHA-1\", gitDataBytes);\r\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n  const hashHex = hashArray\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\");\r\n  return hashHex;\r\n};\r\n\r\nconst importComponentsFromFeed = async (\r\n  componentFeedUrl: string,\r\n  downloadData: DownloadDataType = downloadDataWithCache\r\n) => {\r\n  console.debug(\"Starting importComponentsFromFeed\");\r\n  console.debug(`Downloading component feed: ${componentFeedUrl}.`);\r\n  const componentFeedCandidateObject = await downloadData(\r\n    componentFeedUrl,\r\n    loadObjectFromYamlData\r\n  );\r\n  if (!isComponentFeed(componentFeedCandidateObject)) {\r\n    throw new Error(\r\n      `Component feed loaded from \"${componentFeedUrl}\" had invalid content inside.`\r\n    );\r\n  }\r\n  const componentFeed = componentFeedCandidateObject;\r\n\r\n  const urlsHashesAndData = (\r\n    await Promise.all(\r\n      componentFeed.components.map(async (entry) => {\r\n        const url = entry.componentRef.url;\r\n        if (url === undefined) {\r\n          console.error(\"Component feed entry has no reference URL.\");\r\n          return undefined;\r\n        }\r\n        return {\r\n          url: url,\r\n          hash: await calculateGitBlobSha1HashHex(entry.data),\r\n          data: entry.data,\r\n        };\r\n      })\r\n    )\r\n  ).filter(notUndefined);\r\n\r\n  // const cache = await caches.open(BLOB_CACHE_NAME);\r\n  const urlToHashDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_TO_HASH_DB_TABLE_NAME,\r\n  });\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  const hashToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  const urlProcessingVersionDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_PROCESSING_VERSION_TABLE_NAME,\r\n  });\r\n  const badHashesDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: BAD_HASHES_TABLE_NAME,\r\n  });\r\n  for await (const item of urlsHashesAndData) {\r\n    const hash = item.hash.toLowerCase();\r\n    const htmlUrl = item.url;\r\n    const badHashReason = await badHashesDb.getItem<string>(hash);\r\n    if (badHashReason !== null) {\r\n      console.debug(\r\n        `Skipping url ${htmlUrl} with hash ${hash} due to error: \"${badHashReason}\"`\r\n      );\r\n      continue;\r\n    }\r\n    try {\r\n      const downloadUrl = item.url;\r\n      // Sanity check\r\n      const cachedHash = await urlToHashDb.getItem<string>(downloadUrl);\r\n      if (cachedHash !== null && cachedHash !== hash) {\r\n        console.error(\r\n          `Component cache is broken. Stored hash for ${downloadUrl}: ${cachedHash} != ${hash}.`\r\n        );\r\n      }\r\n      // Check whether the processing is complete\r\n      const urlVersion = await urlProcessingVersionDb.getItem<string>(\r\n        downloadUrl\r\n      );\r\n\r\n      if (\r\n        cachedHash !== null && // Not sure we should check this, but it improves the sanity\r\n        urlVersion !== null &&\r\n        Number.parseInt(urlVersion) >= CURRENT_URL_PROCESSING_VERSION\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      console.debug(`Processing new component candidate: ${downloadUrl}.`);\r\n      let componentText = item.data;\r\n      if (componentText === undefined) {\r\n        try {\r\n          // TODO: Consider fully preloading graph component children here.\r\n          const componentRef = await loadComponentFromUrlAsRef(\r\n            downloadUrl,\r\n            downloadData\r\n          );\r\n          componentText = componentRef.text;\r\n          //componentSpec = componentRef.spec;\r\n        } catch (err) {\r\n          const error_message =\r\n            err instanceof Error ? err.name + \": \" + err.message : String(err);\r\n          badHashesDb.setItem(hash, error_message);\r\n          continue;\r\n        }\r\n      }\r\n      // TODO: Extract component loading and validation into a separate function.\r\n      const componentSpecObj = yaml.load(componentText);\r\n      if (typeof componentSpecObj !== \"object\" || componentSpecObj === null) {\r\n        throw Error(\r\n          `componentText is not a YAML-encoded object: ${componentSpecObj}`\r\n        );\r\n      }\r\n      if (!isValidComponentSpec(componentSpecObj)) {\r\n        throw Error(\r\n          `componentText does not encode a valid pipeline component: ${componentSpecObj}`\r\n        );\r\n      }\r\n      const componentSpec = componentSpecObj;\r\n      if (componentSpec.implementation === undefined) {\r\n        badHashesDb.setItem(\r\n          hash,\r\n          'Component lacks the \"implementation\" section.'\r\n        );\r\n        continue;\r\n      }\r\n\r\n      // Blobs are cumbersome (need await to get text) - store text instead\r\n      // await hashToContentDb.setItem(hash, data);\r\n      await hashToContentDb.setItem(hash, componentText);\r\n\r\n      // Only adding hash -> URL once\r\n      const urlForHash = await hashToUrlDb.getItem<string>(hash);\r\n      if (urlForHash === null) {\r\n        await hashToUrlDb.setItem(hash, downloadUrl);\r\n      }\r\n\r\n      //TODO: Store fully-loaded component spec as well.\r\n\r\n      // Only storing names when they exist\r\n      if (componentSpec.name) {\r\n        await hashToComponentNameDb.setItem(hash, componentSpec.name);\r\n      }\r\n\r\n      await urlToHashDb.setItem(downloadUrl, hash);\r\n\r\n      // Marking the processing as completed\r\n      await urlProcessingVersionDb.setItem(\r\n        downloadUrl,\r\n        CURRENT_URL_PROCESSING_VERSION\r\n      );\r\n    } catch (err) {\r\n      console.error(\r\n        `Error when processing component candidate ${htmlUrl} Error: ${err}.`\r\n      );\r\n    }\r\n  }\r\n  console.debug(\"Finished importComponentsFromFeed\");\r\n};\r\n\r\nexport interface ComponentSearchConfig {\r\n  ComponentFeedUrls?: string[];\r\n  GitHubSearchLocations?: string[];\r\n}\r\n\r\nexport const refreshComponentDb = async (\r\n  componentSearchConfig: ComponentSearchConfig,\r\n  downloadData: DownloadDataType = downloadDataWithCache\r\n) => {\r\n  if (componentSearchConfig.ComponentFeedUrls) {\r\n    for (const componentFeedUrl of componentSearchConfig.ComponentFeedUrls) {\r\n      try {\r\n        await importComponentsFromFeed(componentFeedUrl, downloadData);\r\n      } catch (error) {\r\n        console.error(\r\n          `Error importing component feed \"${componentFeedUrl}\": ${error}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n  if (componentSearchConfig.GitHubSearchLocations !== undefined) {\r\n    await importComponentsFromGitHubSearch(\r\n      componentSearchConfig.GitHubSearchLocations,\r\n      downloadData\r\n    );\r\n  }\r\n};\r\n\r\nexport const getAllComponentsAsRefs = async (\r\n  downloadData: DownloadDataType = downloadDataWithCache\r\n) => {\r\n  // Perhaps use urlProcessingVersionDb as source of truth. Hmm. It is URL-based\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  let hashToComponentRef = new Map<string, ComponentReference>();\r\n\r\n  // !!! Iterating using hashToContentDb.iterate<string, void> causes all values to be `[object Blob]`\r\n  //await hashToContentDb.iterate<Blob, void>(\r\n  await hashToContentDb.iterate<string, void>(\r\n    // !!! async processor causes only 1 item to be processed since it returns Promise instead of undefined.\r\n    //async (componentData, hash, iterationNumber) => {\r\n    (componentText, hash, iterationNumber) => {\r\n      //const componentText = await componentData.text();\r\n      try {\r\n        const componentSpec = yaml.load(componentText) as ComponentSpec;\r\n        // TODO: Store preloaded components.\r\n        preloadComponentReferences(componentSpec, downloadData);\r\n        hashToComponentRef.set(hash, {\r\n          spec: componentSpec,\r\n        });\r\n      } catch (err) {\r\n        console.error(\r\n          `Error when parsing cached component. Hash: ${hash}. Error: ${err}. Component text: ${componentText}`\r\n        );\r\n      }\r\n    }\r\n  );\r\n  await hashToUrlDb.iterate<string, void>((url, hash, iterationNumber) => {\r\n    let componentRef = hashToComponentRef.get(hash);\r\n    if (componentRef === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with url ${url} and hash ${hash} has no content in the DB.`\r\n      );\r\n    } else {\r\n      componentRef.url = url;\r\n    }\r\n  });\r\n  let componentRefs: ComponentReference[] = [];\r\n  // TODO: Improve the iteration once TypeScript property supports it\r\n  hashToComponentRef.forEach((componentRef, hash) => {\r\n    if (componentRef.url === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with hash ${hash} has content, but no URL in the DB.`\r\n      );\r\n    } else {\r\n      componentRefs.push(componentRef);\r\n    }\r\n  });\r\n  return componentRefs;\r\n};\r\n\r\nexport const isComponentDbEmpty = async () => {\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  return (await hashToContentDb.length()) === 0;\r\n};\r\n\r\nexport const searchComponentsByName = async (\r\n  name: string,\r\n  downloadData: DownloadDataType = downloadDataWithCache\r\n) => {\r\n  const componentRefs = await getAllComponentsAsRefs(downloadData);\r\n  return componentRefs.filter(\r\n    (ref) => ref.spec?.name?.toLowerCase().includes(name.toLowerCase()) ?? false\r\n  );\r\n};\r\n","/**\r\n * @license\r\n * Copyright 2021 Alexey Volkov\r\n * SPDX-License-Identifier: Apache-2.0\r\n * @author         Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n * @copyright 2021 Alexey Volkov <alexey.volkov+oss@ark-kun.com>\r\n */\r\n\r\nimport { useState } from \"react\";\r\nimport { DownloadDataType, downloadDataWithCache } from \"../cacheUtils\";\r\nimport { ComponentReference } from \"../componentSpec\";\r\nimport {\r\n  isComponentDbEmpty,\r\n  refreshComponentDb,\r\n  searchComponentsByName,\r\n} from \"../github\";\r\nimport DraggableComponent from \"./DraggableComponent\";\r\n\r\ninterface ComponentSearchProps {\r\n  componentFeedUrls?: string[],\r\n  gitHubSearchLocations?: string[],\r\n  downloadData: DownloadDataType;\r\n}\r\n\r\nconst SearchPanel = ({\r\n  componentFeedUrls,\r\n  gitHubSearchLocations,\r\n  downloadData = downloadDataWithCache,\r\n}: ComponentSearchProps) => {\r\n  const [error, setError] = useState<string | undefined>(undefined);\r\n  const [firstTime, setFirstTime] = useState(true);\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const [query, setQuery] = useState(\"\");\r\n  const [items, setItems] = useState<ComponentReference[]>([]);\r\n\r\n  const onQueryChange = (e: any) => {\r\n    setQuery(e.target.value);\r\n  };\r\n\r\n  async function fetchData(\r\n    query: string,\r\n  ) {\r\n    // If the DB is populated, return results immediately, then refresh the DB and update the results.\r\n    try {\r\n      if (!(await isComponentDbEmpty())) {\r\n        const componentRefs = await searchComponentsByName(query);\r\n        setIsLoaded(true);\r\n        setItems(componentRefs);\r\n      } else {\r\n        console.debug(\"Component DB is empty. Need to populate the DB first.\");\r\n      }\r\n      await refreshComponentDb(\r\n        {\r\n          ComponentFeedUrls: componentFeedUrls,\r\n          GitHubSearchLocations: gitHubSearchLocations,\r\n        },\r\n        downloadData\r\n      );\r\n      setIsLoaded(true);\r\n      const componentRefs = await searchComponentsByName(query);\r\n      setItems(componentRefs);\r\n    } catch (error: any) {\r\n      setError(error.message);\r\n    }\r\n  }\r\n\r\n  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {\r\n    e.preventDefault();\r\n    if (query !== \"\") {\r\n      setFirstTime(false);\r\n      fetchData(query);\r\n    }\r\n    (window as any).gtag?.(\"event\", \"ComponentSearch_search\", {});\r\n  };\r\n\r\n  let results = <span></span>;\r\n  if (firstTime) {\r\n    results = <div>Enter search query</div>;\r\n  } else if (error !== undefined) {\r\n    results = <div>Error: {error}</div>;\r\n  } else if (!firstTime && !isLoaded) {\r\n    results = <div>Searching...</div>;\r\n  } else if (items !== undefined) {\r\n    const componentElements = items.map((componentRef) => (\r\n      <DraggableComponent\r\n        key={componentRef.digest ?? componentRef.url}\r\n        componentReference={componentRef}\r\n      />\r\n    ));\r\n    results = <>{componentElements}</>;\r\n  }\r\n  return (\r\n    <div className=\"nodeList\">\r\n      <form onSubmit={onSubmit}>\r\n        <input type=\"search\" placeholder=\"XGBoost\" onChange={onQueryChange} />\r\n        <input type=\"submit\" />\r\n      </form>\r\n      <div>{results}</div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SearchPanel;\r\n"],"sourceRoot":""}