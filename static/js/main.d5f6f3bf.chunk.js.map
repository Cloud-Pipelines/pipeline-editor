{"version":3,"sources":["github.ts","DragNDrop/ComponentLibrary.tsx","DragNDrop/graphComponentFromFlow.ts","DragNDrop/GraphComponentExporter.tsx","DragNDrop/vertexAiCompiler.ts","DragNDrop/GoogleCloud.tsx","DragNDrop/VertexAiExporter.tsx","DragNDrop/Sidebar.tsx","DragNDrop/ComponentSearch.tsx","DragNDrop/MultiHandleNode.tsx","DragNDrop/ComponentTaskNode.tsx","DragNDrop/index.tsx","App.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","index.tsx"],"names":["SEARCH_CACHE_NAME","BLOB_CACHE_NAME","DB_NAME","HASH_TO_CONTENT_DB_TABLE_NAME","HASH_TO_COMPONENT_NAME_DB_TABLE_NAME","URL_TO_HASH_DB_TABLE_NAME","HASH_TO_URL_DB_TABLE_NAME","URL_PROCESSING_VERSION_TABLE_NAME","BAD_HASHES_TABLE_NAME","httpGetWithCache","urlOrRequest","cacheName","a","updateIfInCache","caches","open","cache","match","undefined","response","add","response2","Promise","reject","searchGitHubCodeWithCache","query","page","sort","order","encodedQuery","encodeURIComponent","encodedSort","encodedOrder","searchUrl","json","githubHtmlUrlToDownloadUrl","htmlUrl","replace","getComponentUrlsAndHashes","users","urlsAndHashes","map","user","join","searchResults","items","length","item","url","html_url","hash","sha","resolve","setTimeout","downloadComponentDataWithCache","blob","data","text","componentText","componentSpec","yaml","load","cacheAllComponents","console","debug","urlsAndHashesIterator","urlToHashDb","localForage","createInstance","name","storeName","hashToUrlDb","hashToContentDb","hashToComponentNameDb","urlProcessingVersionDb","badHashesDb","toLowerCase","getItem","badHashReason","downloadUrl","endsWith","cachedHash","error","urlVersion","Number","parseInt","setItem","message","implementation","getAllComponentsAsRefs","hashToComponentRef","Map","cachePromise","iterate","iterationNumber","set","spec","err","componentRef","get","componentRefs","forEach","push","searchComponentsByName","filter","ref","includes","DraggableComponentRow","componentUrl","useState","setComponentSpec","useEffect","then","className","draggable","onDragStart","event","nodeData","dataTransfer","setData","JSON","stringify","effectAllowed","task","ComponentGroupList","componentGroups","Array","from","index","category","componentUrls","style","border","borderRadius","borderWidth","padding","ComponentLibrary","paddingLeft","getNodePositionAnnotations","node","x","__rf","position","y","width","height","nodeOrderComparer","n1","n2","createGraphComponentSpecFromFlowElements","nodes","edges","annotations","includePositions","includeSpecs","inputNodes","type","outputNodes","taskNodes","inputSpecs","id","outputSpecs","taskMap","reduce","accumulator","taskSpec","Object","assign","graphOutputValues","edge","sourceTaskId","source","sourceOutputName","sourceHandle","targetTaskId","target","targetInputName","targetHandle","argument","taskOutput","taskId","outputName","graphInput","inputName","targetTask","arguments","taskOutputArgument","graphComponent","inputs","outputs","metadata","graph","tasks","outputValues","keys","GraphComponentExporter","pipelineName","useStoreState","store","dump","lineWidth","componentTextBlob","Blob","downloadLink","href","URL","createObjectURL","download","overflow","typeSpecToVertexPrimitiveTypeEnum","typeSpec","typeSpecToVertexParameterSpec","taskSpecToVertexTaskSpecComponentSpecAndExecutorSpec","taskArguments","Error","containerSpec","container","resolvedCommandLine","inputsConsumedAsValue","Set","inputsConsumedAsPath","convertArg","arg","inputValue","inputPath","outputPath","if","cond","else","ifCond","ifThen","ifElse","condEvaluatesToTrue","isPresent","taskArgument","unresolvedArgs","flatMap","concat","command","args","resolveCommandLine","vertexExecutorSpec","image","inputMap","inputSpec","vertexComponentSpec","outputSpec","inputDefinitions","parameters","fromEntries","values","artifacts","artifactType","schemaTitle","outputDefinitions","executorLabel","vertexTaskSpec","taskInfo","default","optional","runtimeValue","constantValue","stringValue","componentInputParameter","taskOutputParameter","producerTask","outputParameterKey","componentInputArtifact","taskOutputArtifact","outputArtifactKey","cachingOptions","enableCache","graphComponentSpecToVertexPipelineSpec","vertexComponentInputsSpec","graphSpec","vertexExecutors","vertexComponents","vertexTasks","entries","vertexExecutorId","vertexComponentId","vertexTaskId","componentName","pipelineInfo","sdkVersion","schemaVersion","deploymentSpec","executors","components","root","dag","generateVertexPipelineJobFromGraphComponent","gcsOutputDirectory","pipelineArguments","convertedPipelineArguments","key","value","runtimeConfig","pipelineSpec","CLIENT_ID","API_KEY","VERTEX_AI_PIPELINES_REGIONS","authorizeGoogleCloudClient","scopes","immediate","apiKey","clientId","gapi","client","setApiKey","auth","authorize","client_id","scope","authResult","ensureGoogleCloudAuthorizesScopes","cloudresourcemanagerListProjects","request","path","result","aiplatformListPipelineJobs","projetId","region","aiplatformCreatePipelineJob","pipelineJob","method","body","GoogleCloudSubmitter","projects","setProjects","project","setProject","setRegion","setError","setGcsOutputDirectory","pipelineJobWebUrl","setPipelineJobWebUrl","onSubmit","e","preventDefault","log","vertexPipelineJob","pipelineJobName","pipelineJobId","split","slice","htmlFor","required","list","placeholder","onChange","projectId","onClick","projectIds","projectInfo","CloudIrExporter","vertexPipelineSpecText","vertexPipelineSpec","String","vertexPipelineSpecTextBlob","COMPONENT_LIBRARY","Sidebar","fontWeight","GoogleCloud","input","label","output","VertexAiExporter","multihandle","handles","top","ids","bottom","left","right","inputNames","outputNames","COMPONENT_ORGS","SearchPanel","props","firstTime","setFirstTime","isLoaded","setIsLoaded","setQuery","setItems","results","componentElements","title","fetchData","MultiHandleNode","handleComponents","sideHandles","numHandles","i","positionPercentString","Position","Top","Bottom","isConnectable","memo","inputHandlePosition","outputHandlePosition","generateHandles","ioSpecs","handleType","idPrefix","ioSpec","ioTypeName","toString","ComponentTaskNode","inputHandles","outputHandles","nodeTypes","initialElements","onDragOver","dropEffect","DnDFlow","reactFlowInstance","setReactFlowInstance","elements","setElements","onConnect","params","els","addEdge","onElementsRemove","elementsToRemove","removeElements","onEdgeUpdateStart","_","onEdgeUpdateEnd","onEdgeUpdate","oldEdge","newConnection","updateEdge","onLoad","_reactFlowInstance","onDrop","droppedData","getData","droppedDataObject","parse","nodeType","clientX","clientY","newNode","es","deleteKeyCode","multiSelectionKeyCode","snapToGrid","snapGrid","gap","ComponentSearch","App","isLocalhost","Boolean","window","location","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","process","origin","addEventListener","fetch","headers","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration"],"mappings":"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","file":"static/js/main.d5f6f3bf.chunk.js","sourcesContent":["import yaml from \"js-yaml\";\r\nimport localForage from \"localforage\";\r\nimport { ComponentSpec, ComponentReference } from \"./componentSpec\";\r\n\r\n// const COMPONENT_FILE_NAME_SUFFIX = \"component.yaml\";\r\n// const COMPONENT_FILE_MAX_SIZE = 100000;\r\nconst SEARCH_CACHE_NAME = \"https://api.github.com/search\";\r\nconst BLOB_CACHE_NAME = \"raw.githubusercontent.com/.../component.yaml\";\r\n\r\n// IndexedDB: DB and table names\r\nconst DB_NAME = \"components\";\r\nconst HASH_TO_CONTENT_DB_TABLE_NAME = \"hash_to_data\";\r\nconst HASH_TO_COMPONENT_NAME_DB_TABLE_NAME = \"hash_to_component_name\";\r\nconst URL_TO_HASH_DB_TABLE_NAME = \"url_to_hash\";\r\nconst HASH_TO_URL_DB_TABLE_NAME = \"hash_to_url\";\r\nconst URL_PROCESSING_VERSION_TABLE_NAME = \"url_version\";\r\nconst CURRENT_URL_PROCESSING_VERSION = 1;\r\nconst BAD_HASHES_TABLE_NAME = \"bad_hashes\";\r\n\r\n\r\nexport const httpGetWithCache = async (\r\n  urlOrRequest: string | RequestInfo,\r\n  cacheName: string,\r\n  updateIfInCache: boolean = false\r\n): Promise<Response> => {\r\n  const cache = await caches.open(cacheName);\r\n  const response = await cache.match(urlOrRequest);\r\n  if (response !== undefined) {\r\n    if (updateIfInCache) {\r\n      cache.add(urlOrRequest);\r\n    }\r\n    return response;\r\n  }\r\n  await cache.add(urlOrRequest);\r\n  const response2 = await cache.match(urlOrRequest);\r\n  if (response2 === undefined) {\r\n    return Promise.reject(\"Added object to cache, but counld not find it\");\r\n  }\r\n  return response2;\r\n};\r\n\r\n\r\nexport const searchGitHubCodeWithCache = async (\r\n  query: string,\r\n  page = 1,\r\n  sort = \"indexed\",\r\n  order = \"desc\",\r\n): Promise<any> => {\r\n  // TODO: Paging\r\n  const encodedQuery = encodeURIComponent(query);\r\n  const encodedSort = encodeURIComponent(sort);\r\n  const encodedOrder = encodeURIComponent(order);\r\n  const searchUrl = `https://api.github.com/search/code?q=${encodedQuery}&sort=${encodedSort}&order=${encodedOrder}&per_page=100&page=${page}`;\r\n  const response = await httpGetWithCache(searchUrl, SEARCH_CACHE_NAME, true);\r\n  return response.json();\r\n};\r\n\r\n\r\nconst githubHtmlUrlToDownloadUrl = (htmlUrl: string): string => {\r\n  // https://github.com/               kubeflow/pipelines/blob/24bc9162a56c2fe3c50947d655ef280f71ba058f/components/gcp/dataflow/launch_flex_template/component.yaml\r\n  // https://raw.githubusercontent.com/kubeflow/pipelines     /24bc9162a56c2fe3c50947d655ef280f71ba058f/components/gcp/dataflow/launch_flex_template/component.yaml\r\n  return htmlUrl\r\n    .replace(\"https://github.com/\", \"https://raw.githubusercontent.com/\")\r\n    .replace(\"/blob/\", \"/\");\r\n};\r\n\r\n\r\ntype UrlAndHash = {\r\n  url: string;\r\n  hash: string;\r\n};\r\n\r\n\r\nexport async function * getComponentUrlsAndHashes(\r\n  users = [\"kubeflow\", \"Ark-kun\"]\r\n) {\r\n  let urlsAndHashes: UrlAndHash[] = [];\r\n  const query =\r\n    \"filename:component.yaml \" + users.map((user) => \"user:\" + user).join(\" \");\r\n  for (let page = 1; page < 100; page++) {\r\n    const searchResults = await searchGitHubCodeWithCache(query, page);\r\n    // \"total_count\": 512,\r\n    // \"incomplete_results\": false,\r\n    // \"items\": [\r\n    const items: any[] = searchResults.items;\r\n    if (items.length === 0) {\r\n      break;\r\n    }\r\n    for (let item of items) {\r\n      yield { url: githubHtmlUrlToDownloadUrl(item.html_url), hash: item.sha as string };\r\n    }\r\n    await new Promise( resolve => setTimeout(resolve, (60 * 1000 / 10) * (1 + 0.1)));\r\n  }\r\n  return urlsAndHashes;\r\n};\r\n\r\n\r\nexport const cacheComponentCandidateBlobs = async (\r\n  users = [\"kubeflow\", \"Ark-kun\"]\r\n): Promise<any[]> => {\r\n  let urlsAndHashes: UrlAndHash[] = [];\r\n  let urls = [];\r\n  for await (const urlAndHash of getComponentUrlsAndHashes(users)) {\r\n    urlsAndHashes.push(urlAndHash);\r\n    urls.push(urlAndHash.url);\r\n  }\r\n  const cache = await caches.open(BLOB_CACHE_NAME);\r\n  await cache.addAll(urls);\r\n  return urlsAndHashes;\r\n};\r\n\r\nexport const downloadComponentDataWithCache = async (url: string) => {\r\n  const response = await httpGetWithCache(url, BLOB_CACHE_NAME)\r\n  const data = await response.blob();\r\n  const componentText = await data.text();\r\n  const componentSpec = yaml.load(componentText) as ComponentSpec;\r\n  return componentSpec;\r\n}\r\n\r\nexport const cacheAllComponents = async (users = [\"kubeflow\", \"Ark-kun\"]) => {\r\n  console.debug(\"Starting cacheAllComponents\");\r\n  const urlsAndHashesIterator = getComponentUrlsAndHashes(users);\r\n\r\n  // const cache = await caches.open(BLOB_CACHE_NAME);\r\n  const urlToHashDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_TO_HASH_DB_TABLE_NAME,\r\n  });\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  const hashToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  const urlProcessingVersionDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_PROCESSING_VERSION_TABLE_NAME,\r\n  });\r\n  const badHashesDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: BAD_HASHES_TABLE_NAME,\r\n  });\r\n  for await (const item of urlsAndHashesIterator) {\r\n    const hash = item.hash.toLowerCase();\r\n    const htmlUrl = item.url;\r\n    const badHashReason = await badHashesDb.getItem<string>(hash);\r\n    if (badHashReason !== null) {\r\n      console.debug(`Skipping url ${htmlUrl} with hash ${hash} due to error: \"${badHashReason}\"`);\r\n      continue;\r\n    }\r\n    try {\r\n      const downloadUrl: string = githubHtmlUrlToDownloadUrl(htmlUrl);\r\n      if (!downloadUrl.endsWith(\"component.yaml\")) {\r\n        console.debug(`Skipping url ${downloadUrl} since it does not end with \"component.yaml\"`);\r\n        continue;\r\n      }\r\n      // Sanity check\r\n      const cachedHash = await urlToHashDb.getItem<string>(downloadUrl);\r\n      if (cachedHash !== null && cachedHash !== hash) {\r\n        console.error(\r\n          `Component cache is broken. Stored hash for ${downloadUrl}: ${cachedHash} != ${hash}.`\r\n        );\r\n      }\r\n      // Check whether the processing is complete\r\n      const urlVersion = await urlProcessingVersionDb.getItem<string>(\r\n        downloadUrl\r\n      );\r\n\r\n      if (\r\n        cachedHash !== null && // Not sure we should check this, but it improves the sanity\r\n        urlVersion !== null &&\r\n        Number.parseInt(urlVersion) >= CURRENT_URL_PROCESSING_VERSION\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      console.debug(`Processing new component candidate: ${downloadUrl}.`);\r\n      const response = await httpGetWithCache(downloadUrl, BLOB_CACHE_NAME);\r\n      let componentSpec: ComponentSpec;\r\n      let componentText: string;\r\n      try {\r\n        const data = await response.blob();\r\n        componentText = await data.text();\r\n        componentSpec = yaml.load(componentText) as ComponentSpec;\r\n      } catch(err) {\r\n        badHashesDb.setItem(hash, err.name + \": \" + err.message);\r\n        continue;\r\n      }\r\n      if (componentSpec.implementation === undefined) {\r\n        badHashesDb.setItem(hash, 'Component lacks the \"impelmentation\" section.');\r\n        continue;\r\n      }\r\n\r\n      // Blobs are cumbersome (need await to get text) - store text instead\r\n      // await hashToContentDb.setItem(hash, data);\r\n      await hashToContentDb.setItem(hash, componentText);\r\n\r\n      // Only adding hash -> URL once\r\n      const urlForHash = await hashToUrlDb.getItem<string>(hash);\r\n      if (urlForHash === null) {\r\n        await hashToUrlDb.setItem(hash, downloadUrl);\r\n      }\r\n\r\n      // Only storing names when they exist\r\n      if (componentSpec.name) {\r\n        await hashToComponentNameDb.setItem(hash, componentSpec.name);\r\n      }\r\n\r\n      await urlToHashDb.setItem(downloadUrl, hash);\r\n\r\n      // Marking the processing as completed\r\n      await urlProcessingVersionDb.setItem(\r\n        downloadUrl,\r\n        CURRENT_URL_PROCESSING_VERSION\r\n      );\r\n    } catch (err) {\r\n      console.error(\r\n        `Error when processing component candidate ${htmlUrl} Error: ${err}.`\r\n      );\r\n    }\r\n  }\r\n  console.debug(\"Finished cacheAllComponents\");\r\n};\r\n\r\n\r\nexport const getAllComponentsAsRefs = async (users = [\"kubeflow\", \"Ark-kun\"]) => {\r\n  // Perhaps use urlProcessingVersionDb as source of truth. Hmm. It is URL-based\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  let hashToComponentRef = new Map<string, ComponentReference>();\r\n\r\n  const cachePromise = cacheAllComponents(users);\r\n  if ((await hashToContentDb.length()) === 0) {\r\n    await cachePromise;\r\n  }\r\n\r\n  // !!! Iterating using hashToContentDb.iterate<string, void> causes all values to be `[object Blob]`\r\n  //await hashToContentDb.iterate<Blob, void>(\r\n  await hashToContentDb.iterate<string, void>(\r\n    // !!! async processor causes only 1 item to be processed since it returns Promise instead of undefined.\r\n    //async (componentData, hash, iterationNumber) => {\r\n    (componentText, hash, iterationNumber) => {\r\n      //const componentText = await componentData.text();\r\n      try {\r\n        const componentSpec = yaml.load(componentText) as ComponentSpec;\r\n        hashToComponentRef.set(hash, {\r\n          spec: componentSpec,\r\n        });\r\n      } catch (err) {\r\n        console.error(\r\n          `Error when parsing cached component. Hash: ${hash}. Error: ${err}. Component text: ${componentText}`\r\n        );\r\n      }\r\n    }\r\n  );\r\n  await hashToUrlDb.iterate<string, void>((url, hash, iterationNumber) => {\r\n    let componentRef = hashToComponentRef.get(hash);\r\n    if (componentRef === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with url ${url} and hash ${hash} has no content in the DB.`\r\n      );\r\n    } else {\r\n      componentRef.url = url;\r\n    }\r\n  });\r\n  let componentRefs: ComponentReference[] = [];\r\n  // TODO: Improve the iteration onve TypeScript propertly supports it\r\n  hashToComponentRef.forEach((componentRef, hash) => {\r\n    if (componentRef.url === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with hash ${hash} has content, but no URL in the DB.`\r\n      );\r\n    } else {\r\n      componentRefs.push(componentRef);\r\n    }\r\n  });\r\n  return componentRefs;\r\n};\r\n\r\n\r\nexport const searchComponentsByName = async (name: string, users = [\"kubeflow\", \"Ark-kun\"]) => {\r\n  const componentRefs = await getAllComponentsAsRefs(users);\r\n  return componentRefs.filter((ref) => ref.spec?.name?.toLowerCase().includes(name.toLowerCase()) ?? false);\r\n};\r\n","import { DragEvent, useEffect, useState } from 'react';\r\n\r\nimport {downloadComponentDataWithCache} from '../github'\r\nimport {ComponentSpec, TaskSpec} from '../componentSpec'\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData('application/reactflow', JSON.stringify(nodeData));\r\n  event.dataTransfer.effectAllowed = 'move';\r\n};\r\n\r\ntype ComponentGroup = {\r\n  category: string;\r\n  componentUrls: string[];\r\n};\r\n\r\nconst DraggableComponentRow = ({componentUrl}: {componentUrl: string}) => {\r\n  const [componentSpec, setComponentSpec] = useState<ComponentSpec | undefined>(undefined);\r\n  useEffect(() => {\r\n    downloadComponentDataWithCache(componentUrl).then(setComponentSpec);\r\n  }, [componentUrl]);\r\n\r\n  if (componentSpec === undefined) {\r\n    return <span>Loading...</span>\r\n  } else {\r\n    return (\r\n      <div\r\n        className=\"react-flow__node react-flow__node-task\"\r\n        draggable\r\n        onDragStart={(event: DragEvent) => {\r\n          const taskSpec: TaskSpec = {\r\n            componentRef: {\r\n              url: componentUrl,\r\n              spec: componentSpec,\r\n            },\r\n          };\r\n          return onDragStart(event, { task: taskSpec });\r\n        }}\r\n      >\r\n        {componentSpec.name}\r\n      </div>\r\n    );\r\n  }\r\n};\r\n\r\nconst ComponentGroupList = ({ componentGroups }: { componentGroups: ComponentGroup[] }) => {\r\n  return (\r\n    <>\r\n      {Array.from(componentGroups).map(\r\n        ({ category, componentUrls }, index) => (\r\n          <details key={category} open={index === 0} style={{ border: \"1px solid #aaa\", borderRadius: \"4px\" }}>\r\n            <summary style={{ borderWidth: \"1px\", padding: \"8px\" }}>\r\n              <strong>{category}</strong>\r\n            </summary>\r\n            {componentUrls.map((componentUrl) => (\r\n              <DraggableComponentRow key={componentUrl} componentUrl={componentUrl} />\r\n            ))}\r\n          </details>\r\n        )\r\n      )}\r\n    </>\r\n  );\r\n};\r\n\r\nconst ComponentLibrary = ({ componentGroups }: { componentGroups: ComponentGroup[] }) => {\r\n  return (\r\n    <details open>\r\n      <summary style={{ border: \"1px solid #aaa\", padding: \"5px\", borderRadius: \"8px\" }}>\r\n        <strong>Component library</strong>\r\n      </summary>\r\n      <div style={{ paddingLeft: \"10px\" }}>\r\n        <ComponentGroupList componentGroups={componentGroups}/>\r\n      </div>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default ComponentLibrary;\r\n","import {\r\n  Node,\r\n  Edge,\r\n} from \"react-flow-renderer\";\r\n\r\nimport {\r\n  ComponentSpec,\r\n  TaskSpec,\r\n  InputSpec,\r\n  OutputSpec,\r\n  ArgumentType,\r\n  GraphInputArgument,\r\n  TaskOutputArgument,\r\n  GraphImplementation,\r\n} from \"../componentSpec\";\r\n\r\nconst getNodePositionAnnotations = (node: Node): { [k: string]: string } => ({\r\n  \"editor.position\": JSON.stringify({\r\n    // node.position cannot be used since set at 1st drop and never updated\r\n    x: node.__rf.position.x,\r\n    y: node.__rf.position.y,\r\n    width: node.__rf.width,\r\n    height: node.__rf.height,\r\n  }),\r\n});\r\n\r\nconst nodeOrderComparer = (n1: Node, n2: Node) =>\r\n  n1.__rf.position.x - n2.__rf.position.x;\r\n\r\nconst createGraphComponentSpecFromFlowElements = (\r\n  nodes: Node[],\r\n  edges: Edge[],\r\n  name = \"Component\",\r\n  annotations: Record<string, string> = {},\r\n  includePositions: boolean = true,\r\n  includeSpecs: boolean = false\r\n): ComponentSpec => {\r\n  // Input and output nodes\r\n  // Sorting them by horisontal position to make reordering inputs and outputs easy.\r\n  const inputNodes = nodes.filter((node) => node.type === \"input\").sort(nodeOrderComparer);\r\n  const outputNodes = nodes.filter((node) => node.type === \"output\").sort(nodeOrderComparer);\r\n  // Task nodes. They should all be ComponentTaskNode components\r\n  const taskNodes = nodes\r\n    .filter((node) => node.type === \"task\")\r\n    .map((node) => node as Node<TaskSpec>);\r\n  \r\n  const inputSpecs = inputNodes.map<InputSpec>((node) => {\r\n    let spec: InputSpec = { name: node.id };\r\n    if (includePositions) {\r\n      spec.annotations = getNodePositionAnnotations(node);\r\n    }\r\n    return spec;\r\n  });\r\n\r\n  const outputSpecs = outputNodes.map<OutputSpec>((node) => {\r\n    let spec: OutputSpec = { name: node.id };\r\n    if (includePositions) {\r\n      spec.annotations = spec.annotations = getNodePositionAnnotations(node);\r\n    }\r\n    return spec;\r\n  });\r\n\r\n  // const originalTaskMap = taskNodes.reduce((map, node) => {\r\n  //   const taskSpec = node.data;\r\n  //   if (taskSpec !== undefined) {\r\n  //     map.set(node.id, taskSpec);\r\n  //   }\r\n  //   return map;\r\n  // }, new Map<string, TaskSpec>());\r\n\r\n  const taskMap = taskNodes.reduce((accumulator, node) => {\r\n    let taskSpec = node.data;\r\n    if (taskSpec !== undefined) {\r\n      // Cloning the spec to modify it\r\n      taskSpec = Object.assign({}, taskSpec);\r\n      if (!includeSpecs) {\r\n        taskSpec.componentRef = Object.assign({}, taskSpec.componentRef);\r\n        delete taskSpec.componentRef.spec;\r\n      }\r\n      if (includePositions) {\r\n        taskSpec.annotations = getNodePositionAnnotations(node);\r\n      }\r\n      accumulator[node.id] = taskSpec;\r\n    }\r\n    return accumulator;\r\n  }, {} as Record<string, TaskSpec>);\r\n\r\n  let graphOutputValues: Record<string, TaskOutputArgument> = {};\r\n\r\n  for (const edge of edges) {\r\n    const sourceTaskId = edge.source;\r\n    const sourceOutputName = edge.sourceHandle?.replace(/^output_/, '');\r\n    const targetTaskId = edge.target;\r\n    const targetInputName = edge.targetHandle?.replace(/^input_/, '');\r\n\r\n    // if (!sourceOutputName || !targetInputName) {\r\n    //   console.error(\"Enexpected edge without a source or target handle:\", edge);\r\n    //   continue;\r\n    // }\r\n\r\n    // Checking the source task for sanity\r\n    if (!!sourceOutputName && taskMap[sourceTaskId] === undefined) {\r\n      console.error(\"Task node is connected to unknown node type:\", edge);\r\n      continue;\r\n    }\r\n\r\n    // FIX: For now, detecting the graph inputs and outputs by sourceOutputName or targetInputName being null\r\n    const argument: ArgumentType =\r\n      !!sourceOutputName\r\n        ? ({\r\n            taskOutput: { taskId: sourceTaskId, outputName: sourceOutputName },\r\n          } as TaskOutputArgument)\r\n        : ({\r\n            // Using input node ID as graph input name\r\n            graphInput: { inputName: sourceTaskId },\r\n          } as GraphInputArgument);\r\n    if (!!targetInputName) {\r\n      let targetTask = taskMap[targetTaskId];\r\n      if (targetTask === undefined) {\r\n        console.error(\"Task node is connected to unknown node type:\", edge);\r\n        continue;\r\n      }\r\n      if (targetTask.arguments === undefined) {\r\n        targetTask.arguments = {};\r\n      }\r\n      targetTask.arguments[targetInputName] = argument;\r\n    } else {\r\n      // graph output\r\n      // Using output node ID as graph output name\r\n      const taskOutputArgument = argument as TaskOutputArgument;\r\n      // FIX BUG This check does not work to guard against incompatible arguments\r\n      if (!!taskOutputArgument) {\r\n        graphOutputValues[targetTaskId] = taskOutputArgument;\r\n      } else {\r\n        console.error(\"Graph outputs can only come from task outputs.\")\r\n      }\r\n    }\r\n  }\r\n\r\n  // // Verify arguments\r\n  // // TODO: Also sort them\r\n  // for (const [taskId, taskSpec] of Object.entries(taskMap)) {\r\n    \r\n  // }\r\n\r\n  const graphComponent: ComponentSpec = {\r\n    name: name,\r\n    inputs: inputSpecs,\r\n    outputs: outputSpecs,\r\n    metadata: {\r\n      annotations: annotations\r\n    },\r\n    implementation: {\r\n      graph: {\r\n        tasks: taskMap,\r\n        outputValues: graphOutputValues,\r\n      },\r\n    },\r\n  };\r\n\r\n  // Cleanup.\r\n  // I could have prevented these attributes from being added, but then the attribute serialization ordering will be ugly\r\n  // (the first attribute would be \"implementation\" since it's required).\r\n  if (inputSpecs.length === 0) {\r\n    delete graphComponent.inputs;\r\n  }\r\n  if (outputSpecs.length === 0) {\r\n    delete graphComponent.outputs;\r\n  }\r\n  if (Object.keys(annotations).length === 0) {\r\n    delete graphComponent.metadata;\r\n  }\r\n  if (Object.keys(graphOutputValues).length === 0) {\r\n    delete (graphComponent.implementation as GraphImplementation).graph.outputValues;\r\n  }\r\n  return graphComponent;\r\n};\r\n\r\nexport { createGraphComponentSpecFromFlowElements };\r\n","import {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\nimport yaml from \"js-yaml\";\r\n\r\nimport {createGraphComponentSpecFromFlowElements} from './graphComponentFromFlow'\r\n\r\nconst GraphComponentExporter = ({pipelineName}: {pipelineName?: string}) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n  const edges = useStoreState((store) => store.edges);\r\n\r\n  pipelineName = pipelineName ?? \"Pipeline\";\r\n\r\n  const graphComponent = createGraphComponentSpecFromFlowElements(nodes, edges, pipelineName);\r\n  const componentText = yaml.dump(graphComponent, { lineWidth: 10000 });\r\n\r\n  const componentTextBlob = new Blob([componentText], { type: \"text/yaml\" }); // Or application/x-yaml (which leads to downloading)\r\n  const downloadLink = <a href={URL.createObjectURL(componentTextBlob)} download={\"component.yaml\"}>component.yaml</a>\r\n\r\n  return (\r\n    <details>\r\n      <summary>Graph {downloadLink}</summary>\r\n      <pre style={{overflow: \"auto\"}}>{componentText}</pre>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default GraphComponentExporter;\r\n","import { ComponentSpec, TaskSpec, ContainerImplementation, ImplementationType, StringOrPlaceholder, ArgumentType, TypeSpecType } from \"../componentSpec\";\r\n\r\nconst sanitizePipelineInfoName = (componentName: string) => {\r\n    return componentName.toLowerCase().replace(/\\W/, '-')\r\n}\r\n\r\ntype ResolvedCommandLineAndArgs = {\r\n    command?: string[],\r\n    args?: string[],\r\n    inputsConsumedAsValue: Set<string>,\r\n    inputsConsumedAsPath: Set<string>,\r\n};\r\n\r\n// # How to handle I/O:\r\n// output = output artifact\r\n// inputValue => input parameter\r\n// inputPath => input artifact\r\n// downstream input parameter => spread \"parameterness\" upstream - add output parameters when needed (AFAIK, the paths are the same - required)\r\n// const argument or pipeline parameter + artifact input => need to insert uploader task\r\n\r\nconst resolveCommandLine = (componentSpec: ComponentSpec, taskArguments: Record<string, ArgumentType>): ResolvedCommandLineAndArgs => {\r\n    // TODO: Investigate how to properly narrow the ImplementationType union type\r\n    const containerImplementation = componentSpec.implementation as ContainerImplementation;\r\n    const containerSpec = containerImplementation.container;\r\n\r\n    // ?! TODO: Handle missing optional inputs with defaults\r\n    const inputsConsumedAsValue = new Set<string>();\r\n    const inputsConsumedAsPath = new Set<string>();\r\n    const convertArg = (arg: StringOrPlaceholder): string[] => {\r\n        if (typeof arg == \"string\") {\r\n            return [arg];\r\n        } else if ('inputValue' in arg) {\r\n            const inputName = arg.inputValue;\r\n            inputsConsumedAsValue.add(inputName);\r\n            return [`{{$.inputs.parameters['${inputName}']}}`];\r\n        } else if ('inputPath' in arg) {\r\n            const inputName = arg.inputPath;\r\n            inputsConsumedAsPath.add(inputName);\r\n            return [`{{$.inputs.artifacts['${inputName}'].path}}`];\r\n        } else if ('outputPath' in arg) {\r\n            const outputName = arg.outputPath;\r\n            return [`{{$.outputs.artifacts['${outputName}'].path}}`];\r\n        } else if ('if' in arg) {\r\n            const [ifCond, ifThen, ifElse] = [arg.if.cond, arg.if.then, arg.if.else];\r\n            // TODO: Check false values, not just check for true\r\n            let condEvaluatesToTrue = false;\r\n            if (typeof ifCond === \"string\") {\r\n              condEvaluatesToTrue = ifCond.toLowerCase() === \"true\";\r\n            } else if (typeof ifCond === \"boolean\") {\r\n              condEvaluatesToTrue = ifCond;\r\n            } else if (\"isPresent\" in ifCond) {\r\n              const inputName = ifCond.isPresent;\r\n              condEvaluatesToTrue = inputName in taskArguments;\r\n            } else if (\"inputValue\" in ifCond) {\r\n              const inputName = ifCond.inputValue;\r\n              if (! (inputName in taskArguments)) {\r\n                condEvaluatesToTrue = false;\r\n              } else {\r\n                const taskArgument = taskArguments[inputName];\r\n                if (typeof taskArgument === \"string\") {\r\n                    condEvaluatesToTrue = taskArgument.toLowerCase() === \"true\";\r\n                } else {\r\n                    throw Error(\"Using runtime conditions in component command line placeholders is not supported yet.\")\r\n                }\r\n              }\r\n            } else {\r\n                throw Error(\"Unexpected contition kind: \" + ifCond);\r\n            }\r\n            const unresolvedArgs = condEvaluatesToTrue ? ifThen : ifElse;\r\n            if (unresolvedArgs === undefined) {\r\n                return [];\r\n            }\r\n            return unresolvedArgs.flatMap(convertArg);\r\n        } else if ('concat' in arg) {\r\n            const concatArgs = arg.concat;\r\n            return concatArgs.flatMap(convertArg);\r\n        } else {\r\n            throw Error(`Unknown kind of command-line argument: ${arg}`);\r\n        }\r\n    };\r\n\r\n    const result = {\r\n        command: containerSpec.command?.flatMap(convertArg),\r\n        args: containerSpec.args?.flatMap(convertArg),\r\n        inputsConsumedAsValue: inputsConsumedAsValue,\r\n        inputsConsumedAsPath: inputsConsumedAsPath,\r\n    };\r\n    return result;\r\n}\r\n\r\nfunction isContainerImplementation(implementationType: ImplementationType): implementationType is ContainerImplementation {\r\n    return 'container' in implementationType;\r\n}\r\n\r\nconst typeSpecToVertexPrimitiveTypeEnum = (typeSpec: TypeSpecType | undefined) => {\r\n    if (typeof typeSpec === \"string\") {\r\n        if ([\"integer\"].includes(typeSpec.toLowerCase())) {\r\n            return \"INT\";\r\n        }\r\n        if ([\"float\", \"double\"].includes(typeSpec.toLowerCase())) {\r\n            return \"DOUBLE\";\r\n        }\r\n    }\r\n    return \"STRING\";\r\n}\r\n\r\nconst typeSpecToVertexParameterSpec = (typeSpec: TypeSpecType | undefined) => {\r\n    return {\r\n        type: typeSpecToVertexPrimitiveTypeEnum(typeSpec)\r\n    }\r\n}\r\n\r\nconst typeSpecToVertexArtifactTypeSchema = (typeSpec: TypeSpecType | undefined) => {\r\n    // TODO: Implement better mapping\r\n    const artifactTypeSchema = {\r\n        schemaTitle: \"system.Artifact\"\r\n    }\r\n    return artifactTypeSchema\r\n}\r\n\r\nconst typeSpecToVertexArtifactSpec = (typeSpec: TypeSpecType | undefined) => {\r\n    return {\r\n        artifactType: typeSpecToVertexArtifactTypeSchema(typeSpec)\r\n    }\r\n}\r\n// const typeSpecToVertexArtifactType(typeSpec: TypeSpecType) => {\r\n//     return typeof typeSpec === \"string\" && [\"String\", \"Integer\", \"Float\", \"Double\", \"Boolean\", ]\r\n// }\r\n\r\n\r\nconst taskSpecToVertexTaskSpecComponentSpecAndExecutorSpec = (\r\n    componentSpec: ComponentSpec,\r\n    //passedArgumentNames: string[],\r\n    taskArguments: Record<string, ArgumentType>\r\n) => {\r\n    // TODO: Investigate how to properly narrow the ImplementationTyppe union type\r\n    // Type guard!\r\n\r\n    if (!isContainerImplementation(componentSpec.implementation)) {\r\n        throw Error(\"Nested graph components are not supported yet\");\r\n    }\r\n    // Also works\r\n    // if ('container' in componentSpec.implementation) {\r\n    //     componentSpec.implementation\r\n    // }\r\n\r\n    const containerSpec = componentSpec.implementation.container;\r\n\r\n\r\n    const resolvedCommandLine = resolveCommandLine(componentSpec, {});\r\n\r\n    const vertexExecutorSpec = {\r\n        container: {\r\n            image: containerSpec.image,\r\n            command: resolvedCommandLine.command,\r\n            args: resolvedCommandLine.args,\r\n        }\r\n    };\r\n\r\n    // resolvedCommandLine.inputsConsumedAsPath\r\n\r\n    const inputMap = new Map((componentSpec.inputs ?? []).map(inputSpec => [inputSpec.name, inputSpec]));\r\n    const outputMap = new Map((componentSpec.outputs ?? []).map(outputSpec => [outputSpec.name, outputSpec]));\r\n\r\n    // Array.from(inputMap.keys()).filter(resolvedCommandLine.inputsConsumedAsValue.has)\r\n\r\n    const vertexComponentInputsSpec = {\r\n      parameters: Object.fromEntries(\r\n        Array.from(resolvedCommandLine.inputsConsumedAsValue.values()).map(\r\n          (inputName) => [\r\n            inputName,\r\n            typeSpecToVertexParameterSpec(inputMap.get(inputName)?.type),\r\n          ]\r\n        )\r\n      ),\r\n      artifacts: Object.fromEntries(\r\n        Array.from(resolvedCommandLine.inputsConsumedAsPath.values()).map(\r\n          (inputName) => [\r\n            inputName,\r\n            typeSpecToVertexArtifactSpec(inputMap.get(inputName)?.type)\r\n          ]\r\n        )\r\n      ),\r\n    };\r\n\r\n    const vertexComponentOutputsSpec = {\r\n      parameters: {}, // Parameters will be added later as needed\r\n      artifacts: Object.fromEntries(\r\n        (componentSpec.outputs ?? []).map((outputSpec) => [\r\n          outputSpec.name,\r\n          typeSpecToVertexArtifactSpec(outputSpec.type)\r\n        ])\r\n      ),\r\n    };\r\n\r\n    const vertexComponentSpec = {\r\n        inputDefinitions: vertexComponentInputsSpec,\r\n        outputDefinitions: vertexComponentOutputsSpec,\r\n        // dag\r\n        executorLabel: \"<set later>\",\r\n    };\r\n\r\n    const vertexTaskParameterArguments = Object.fromEntries(Array.from(resolvedCommandLine.inputsConsumedAsValue.values()).map(inputName => [inputName, (inputName => {\r\n        // TODO: Check that this works\r\n        let taskArgument = taskArguments[inputName];\r\n        //if (! (inputName in taskArguments)) {\r\n        if (taskArgument === undefined) {\r\n            // Checking for default value\r\n            const inputSpec = inputMap.get(inputName);\r\n            if (inputSpec === undefined) {\r\n                throw Error(`Cannot happen: vertexTaskParameterArguments - inputMap.get(${inputName}) === undefined`)\r\n            }\r\n            if (inputSpec.default !== undefined) {\r\n                taskArgument = inputSpec.default;\r\n            } else {\r\n                if (inputSpec.optional === true) {\r\n                    // TODO: Decide what the behavior should be\r\n                    // throw Error(`Input \"${inputName}\" is optional, but command-line still uses it when when it's not present.`);\r\n                    console.error(`Input \"${inputName}\" is optional, but command-line still uses it when when it's not present.`);\r\n                    taskArgument = \"\";\r\n                } else {\r\n                    throw Error(`Argument was not provided for required input \"${inputName}\"`);\r\n                }\r\n            }\r\n        }\r\n        if (typeof taskArgument === \"string\" ) {\r\n            return {\r\n                runtimeValue: {\r\n                    constantValue: {\r\n                        // TODO: Fix constant arguments for non-string inputs\r\n                        stringValue: taskArgument,\r\n                    }\r\n                }\r\n            }\r\n        } else if ('graphInput' in taskArgument) {\r\n            return {\r\n                componentInputParameter: taskArgument.graphInput.inputName,\r\n            }\r\n        } else if ('taskOutput' in taskArgument) {\r\n            return {\r\n                taskOutputParameter: {\r\n                    producerTask: taskArgument.taskOutput.taskId,\r\n                    outputParameterKey: taskArgument.taskOutput.outputName,\r\n                }\r\n            };\r\n        } else {\r\n            throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n        }\r\n    })(inputName)]));\r\n\r\n    const vertexTaskArtifactArguments = Object.fromEntries(Array.from(resolvedCommandLine.inputsConsumedAsPath.values()).map(inputName => [inputName, (inputName => {\r\n        // TODO: Check that this works\r\n        let taskArgument = taskArguments[inputName];\r\n        //if (! (inputName in taskArguments)) {\r\n        if (taskArgument === undefined) {\r\n            // Checking for default value\r\n            const inputSpec = inputMap.get(inputName);\r\n            if (inputSpec === undefined) {\r\n                throw Error(`Cannot happen: vertexTaskParameterArguments - inputMap.get(${inputName}) === undefined`)\r\n            }\r\n            if (inputSpec.default !== undefined) {\r\n                taskArgument = inputSpec.default;\r\n            } else {\r\n                if (inputSpec.optional === true) {\r\n                    // TODO: Decide what the behavior should be\r\n                    // throw Error(`Input \"${inputName}\" is optional, but command-line still uses it when when it's not present.`);\r\n                    console.error(`Input \"${inputName}\" is optional, but command-line still uses it when when it's not present.`);\r\n                    taskArgument = \"\";\r\n                } else {\r\n                    throw Error(`Argument was not provided for required input \"${inputName}\"`);\r\n                }\r\n            }\r\n        }\r\n        if (typeof taskArgument === \"string\" ) {\r\n            // TODO: Work around and make this possible\r\n            throw Error(\"Constant arguments for artifact inputs are not supported yet.\");\r\n        } else if ('graphInput' in taskArgument) {\r\n            return {\r\n                componentInputArtifact: taskArgument.graphInput.inputName,\r\n            }\r\n        } else if ('taskOutput' in taskArgument) {\r\n            return {\r\n                taskOutputArtifact: {\r\n                    producerTask: taskArgument.taskOutput.taskId,\r\n                    outputArtifactKey: taskArgument.taskOutput.outputName,\r\n                }\r\n            };\r\n        } else {\r\n            throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n        }\r\n    })(inputName)]));\r\n    \r\n    const vertexTaskSpec = {\r\n        taskInfo: {\r\n            name: \"<set later>\",\r\n        },\r\n        inputs: {\r\n            parameters: vertexTaskParameterArguments,\r\n            artifacts: vertexTaskArtifactArguments,\r\n        },\r\n        // dependent_tasks: [],\r\n        cachingOptions: {\r\n            enableCache: true,\r\n        },\r\n        componentRef: {\r\n          name: \"<set later>\"\r\n        },\r\n        // triggerPolicy: {\r\n        //     condition: \"...\",\r\n        //     strategy: \"ALL_UPSTREAM_TASKS_SUCCEEDED\",\r\n        // },\r\n        // iterator: {\r\n        //     artifactIterator: {...},\r\n        //     parameterIterator: {...},\r\n        // },\r\n    }\r\n    \r\n    return { vertexTaskSpec, vertexComponentSpec, vertexExecutorSpec };\r\n}\r\n\r\nconst graphComponentSpecToVertexPipelineSpec = (componentSpec: ComponentSpec) => {\r\n    if (! ('graph' in componentSpec.implementation)) {\r\n        throw Error(\"Only graph components are supported for now\")\r\n    }\r\n\r\n    // TODO: Fix case when these inputs are passed to tasks as artifacts\r\n    const vertexComponentInputsSpec = {\r\n        parameters: Object.fromEntries(\r\n          (componentSpec.inputs ?? []).map(\r\n            (inputSpec) => [inputSpec.name, typeSpecToVertexParameterSpec(inputSpec.type)]\r\n          )\r\n        ),\r\n        // Pipeline does not support artifact inputs\r\n        // artifacts: {},\r\n    };\r\n\r\n    const graphSpec = componentSpec.implementation.graph;\r\n\r\n    let vertexExecutors: Record<string, any> = {};\r\n    let vertexComponents: Record<string, any> = {};\r\n    let vertexTasks: Record<string, any> = {};\r\n\r\n    for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n        if (taskSpec.componentRef.spec === undefined) {\r\n            throw Error(`Task \"${taskId}\" does not have taskSpec.componentRef.spec.`)\r\n        }\r\n        const {vertexTaskSpec, vertexComponentSpec, vertexExecutorSpec} = taskSpecToVertexTaskSpecComponentSpecAndExecutorSpec(taskSpec.componentRef.spec, taskSpec.arguments ?? {});\r\n        // task IDs are expected to be unique\r\n        // TODO: Fix  this to work for multi-dag pipelines where task IDs are not globally unique\r\n        const vertexExecutorId = taskId + \"_executor\";\r\n        const vertexComponentId = taskId + \"_component\";\r\n        const vertexTaskId = taskId; // + \"_task\";\r\n        vertexExecutors[vertexExecutorId] = vertexExecutorSpec;\r\n        vertexComponentSpec.executorLabel = vertexExecutorId;\r\n        vertexComponents[vertexComponentId] = vertexComponentSpec;\r\n        vertexTaskSpec.componentRef.name = vertexComponentId;\r\n        vertexTaskSpec.taskInfo.name = vertexTaskId;\r\n        vertexTasks[vertexTaskId] = vertexTaskSpec;\r\n    }\r\n\r\n    const pipelineName = componentSpec.name ?? \"pipeline\";\r\n\r\n    const vertexPipelineSpec = {\r\n        pipelineInfo: {\r\n            name: sanitizePipelineInfoName(pipelineName)\r\n        },\r\n        sdkVersion: \"Cloud-Pipelines\",\r\n        schemaVersion: \"2.0.0\",\r\n        deploymentSpec: {\r\n            executors: vertexExecutors,\r\n        },\r\n        components: vertexComponents,\r\n        root: {\r\n          inputDefinitions: vertexComponentInputsSpec,\r\n          dag: {\r\n            tasks: vertexTasks,\r\n          }\r\n        },\r\n    };\r\n    return vertexPipelineSpec;\r\n};\r\n\r\nconst generateVertexPipelineJobFromGraphComponent = (\r\n  componentSpec: ComponentSpec,\r\n  gcsOutputDirectory: string,\r\n  pipelineArguments?: Map<string, string>\r\n) => {\r\n  // TODO: FIX: Do proper conversion of integers\r\n  //let convertedPipelineArguments = new Map<String, object>(Array.from(pipelineArguments.entries()).map((key, value) => [key, value]));\r\n  let convertedPipelineArguments: Record<string, any> = {};\r\n  if (pipelineArguments !== undefined) {\r\n    for (const [key, value] of Array.from(pipelineArguments.entries())) {\r\n      convertedPipelineArguments[key] = {\r\n        stringValue: value,\r\n        //intValue\r\n        //doubleValue\r\n      };\r\n    }\r\n  }\r\n\r\n  const pipelineSpec = graphComponentSpecToVertexPipelineSpec(componentSpec);\r\n\r\n  const pipelineJob = {\r\n    // name: \"<>\",\r\n    // displayName: \"<>\",\r\n    // labels: {},\r\n    runtimeConfig: {\r\n      parameters: convertedPipelineArguments,\r\n      gcsOutputDirectory: gcsOutputDirectory,\r\n    },\r\n    pipelineSpec: pipelineSpec,\r\n    // encryptionSpec: {},\r\n    // serviceAccount: \"<>\",\r\n    // network: {},\r\n  };\r\n  return pipelineJob;\r\n};\r\n\r\nexport { graphComponentSpecToVertexPipelineSpec, generateVertexPipelineJobFromGraphComponent };\r\n","/* global gapi */\r\n\r\nimport { useState } from 'react';\r\n\r\nimport {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\n\r\nimport {createGraphComponentSpecFromFlowElements} from './graphComponentFromFlow'\r\nimport {generateVertexPipelineJobFromGraphComponent} from './vertexAiCompiler'\r\n\r\nvar CLIENT_ID = '640001104961-2m8hs192tmd9f9nssbr5thr5o3uhmita.apps.googleusercontent.com';\r\nvar API_KEY = 'AIzaSyCDPTffgYGXoit-jKsj1_1WWbSxvU7aEdQ';\r\n     \r\nconst VERTEX_AI_PIPELINES_REGIONS = [\r\n  'us-central1',\r\n  'europe-west4',\r\n  'asia-east1',\r\n];\r\n\r\nconst VERTEX_AI_PIPELINES_DEFAULT_REGION = 'us-central1';\r\n\r\nconst authorizeGoogleCloudClient = async (\r\n  scopes: string[],\r\n  immediate = false, // Setting immediate to true prevents auth window showing every time. But it needs to be false the first time (when cookies are not set).\r\n  apiKey: string = API_KEY,\r\n  clientId: string = CLIENT_ID,\r\n) => {\r\n  return new Promise<gapi.auth.GoogleApiOAuth2TokenObject>(\r\n    (resolve, reject) => {\r\n      gapi.client.setApiKey(apiKey);\r\n      gapi.auth.authorize(\r\n        {\r\n          client_id: clientId,\r\n          scope: scopes,\r\n          immediate: immediate,\r\n        },\r\n        (authResult) => {\r\n          // console.debug(\"authorizeGoogleCloudClient: called back\");\r\n          if (authResult === undefined) {\r\n            console.error(\"authorizeGoogleCloudClient failed\");\r\n            reject(\"gapi.auth.authorize result is undefined\");\r\n          } else if (authResult.error) {\r\n            console.error(\r\n              \"authorizeGoogleCloudClient failed\",\r\n              authResult.error\r\n            );\r\n            reject(authResult.error);\r\n          } else {\r\n            resolve(authResult);\r\n            // console.debug(\"authorizeGoogleCloudClient: Success\");\r\n          }\r\n        }\r\n      );\r\n    }\r\n  );\r\n};\r\n\r\nconst ensureGoogleCloudAuthorizesScopes = async (scopes: string[]) => {\r\n  try {\r\n    // console.debug('Before ensureGoogleCloudAuthorizesScopes(immediate=true)');\r\n    await authorizeGoogleCloudClient(scopes, true);\r\n    // console.debug('After ensureGoogleCloudAuthorizesScopes(immediate=true)');\r\n  } catch (err) {\r\n    // console.error('ensureGoogleCloudAuthorizesScopes(immediate=true)', err);\r\n    try {\r\n      await authorizeGoogleCloudClient(scopes, false);\r\n    } catch (err) {\r\n      // console.error('ensureGoogleCloudAuthorizesScopes(immediate=false)', err);\r\n    }\r\n  }\r\n};\r\n\r\nconst cloudresourcemanagerListProjects = async (isAuthenticated = false) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: \"https://cloudresourcemanager.googleapis.com/v1/projects/\",\r\n  });\r\n  return response.result;\r\n}\r\n\r\nconst aiplatformListPipelineJobs = async (projetId: string, region='us-central1', isAuthenticated = false) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: `https://${region}-aiplatform.googleapis.com/v1beta1/projects/${projetId}/locations/${region}/pipelineJobs`,\r\n  });\r\n  return response.result;\r\n}\r\n\r\nconst aiplatformCreatePipelineJob = async (projetId: string, region='us-central1', pipelineJob: Record<string, any>) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: `https://${region}-aiplatform.googleapis.com/v1beta1/projects/${projetId}/locations/${region}/pipelineJobs`,\r\n    method: \"POST\",\r\n    body: JSON.stringify(pipelineJob),\r\n  });\r\n  return response.result;\r\n}\r\n\r\nconst GoogleCloudSubmitter = () => {\r\n  const [projects, setProjects] = useState<string[]>([]);\r\n  const [project, setProject] = useState<string>(\"\"); // undefined causes error: https://reactjs.org/docs/forms.html#controlled-components https://stackoverflow.com/a/47012342\r\n  const [region, setRegion] = useState(VERTEX_AI_PIPELINES_DEFAULT_REGION);\r\n  const [error, setError] = useState(\"\");\r\n  const [gcsOutputDirectory, setGcsOutputDirectory] = useState(\"\");\r\n  const [pipelineJobWebUrl, setPipelineJobWebUrl] = useState(\"\");\r\n\r\n  const nodes = useStoreState((store) => store.nodes);\r\n  const edges = useStoreState((store) => store.edges);\r\n\r\n  return (\r\n    <form\r\n      onSubmit={async (e) => {\r\n        e.preventDefault()\r\n        try {\r\n          const result = await aiplatformListPipelineJobs(project, region);\r\n          console.log(\"aiplatformListPipelineJobs result:\", result);\r\n          setError(\"\");\r\n        } catch (err) {\r\n          setError(err?.result?.error?.message ?? \"Error\");\r\n        }\r\n\r\n        try {\r\n          const pipelineName = \"Pipeline\";\r\n        \r\n          const graphComponent = createGraphComponentSpecFromFlowElements(nodes, edges, pipelineName, undefined, false, true);\r\n          const vertexPipelineJob = generateVertexPipelineJobFromGraphComponent(graphComponent, gcsOutputDirectory);\r\n          const result = await aiplatformCreatePipelineJob(project, region, vertexPipelineJob);\r\n          console.log(result);\r\n          const pipelineJobName: string = result.name;\r\n          const pipelineJobId = pipelineJobName.split('/').slice(-1)[0];\r\n          const pipelineJobWebUrl = `https://console.cloud.google.com/vertex-ai/locations/${region}/pipelines/runs/${pipelineJobId}?project=${project}`;\r\n          setPipelineJobWebUrl(pipelineJobWebUrl);\r\n        } catch (err) {\r\n          setPipelineJobWebUrl(\"\");\r\n          setError(err?.result?.error?.message ?? \"Error\");\r\n        }\r\n    }}\r\n    >\r\n      <div>\r\n        <label htmlFor=\"project\">Project: </label>\r\n        <input\r\n          id=\"project\"\r\n          required\r\n          type=\"text\"\r\n          list=\"projects\"\r\n          placeholder=\"<my-project-id>\"\r\n          value={project}\r\n          onChange={(e) => setProject(e.target.value)}\r\n        />\r\n        <datalist id=\"projects\">\r\n          {projects.map((projectId) => (\r\n            <option key={projectId} value={projectId} />\r\n          ))}\r\n        </datalist>\r\n        <button\r\n          type=\"button\" // The default button type is \"submit\", not \"button\". WTF!?\r\n          onClick={async (e) => {\r\n            try {\r\n              const result = await cloudresourcemanagerListProjects();\r\n              const projectIds = (result.projects as any[]).map<string>(\r\n                (projectInfo) => projectInfo.projectId\r\n              );\r\n              setProjects(projectIds);\r\n              setError(\"\");\r\n            } catch (err) {\r\n              setError(err);\r\n            }\r\n          }}\r\n        >\r\n          {/*        */}\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <label htmlFor=\"region\">Region: </label>\r\n        <input\r\n          id=\"region\"\r\n          required\r\n          type=\"text\"\r\n          list=\"regions\"\r\n          value={region}\r\n          onChange={(e) => setRegion(e.target.value)}\r\n        />\r\n        <datalist id=\"regions\">\r\n          {VERTEX_AI_PIPELINES_REGIONS.map((region) => (\r\n            <option key={region} value={region} />\r\n          ))}\r\n        </datalist>\r\n      </div>\r\n      <div>\r\n        <label htmlFor=\"region\">GCS dir: </label>\r\n        <input\r\n          id=\"gcsOutputDirectory\"\r\n          required\r\n          type=\"text\"\r\n          value={gcsOutputDirectory}\r\n          onChange={(e) => setGcsOutputDirectory(e.target.value)}\r\n        />\r\n      </div>\r\n      <input type=\"submit\" value=\"Submit pipeline job\" />\r\n      {pipelineJobWebUrl !== \"\" && <div><a href={pipelineJobWebUrl}>Job</a></div>}\r\n      {error !== \"\" && <div>Error: {error}</div>}\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default GoogleCloudSubmitter;\r\n","import {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\n\r\nimport {createGraphComponentSpecFromFlowElements} from './graphComponentFromFlow'\r\nimport {graphComponentSpecToVertexPipelineSpec, generateVertexPipelineJobFromGraphComponent} from './vertexAiCompiler'\r\n\r\n// const getVertexPipelineJob = (gcsOutputDirectory: string, pipelineName?: string) => {\r\n//   const nodes = useStoreState((store) => store.nodes);\r\n//   const edges = useStoreState((store) => store.edges);\r\n\r\n//   pipelineName = pipelineName ?? \"Pipeline\";\r\n\r\n//   const graphComponent = createGraphComponentSpecFromFlowElements(nodes, edges, pipelineName, undefined, false, true);\r\n//   const vertexPipelineJob = generateVertexPipelineJobFromGraphComponent(graphComponent, gcsOutputDirectory);\r\n// }\r\n\r\nconst CloudIrExporter = ({pipelineName}: {pipelineName?: string}) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n  const edges = useStoreState((store) => store.edges);\r\n\r\n  pipelineName = pipelineName ?? \"Pipeline\";\r\n\r\n  let vertexPipelineSpecText = \"\";\r\n  try {\r\n    const graphComponent = createGraphComponentSpecFromFlowElements(nodes, edges, pipelineName, undefined, false, true);\r\n    const vertexPipelineSpec = graphComponentSpecToVertexPipelineSpec(graphComponent);\r\n    vertexPipelineSpecText = JSON.stringify(vertexPipelineSpec, undefined, 4);\r\n    console.log(vertexPipelineSpecText);\r\n  } catch(err) {\r\n    vertexPipelineSpecText = String(err);\r\n  }\r\n\r\n  const vertexPipelineSpecTextBlob = new Blob([vertexPipelineSpecText], { type: \"application/json\" }); // Or application/x-yaml (which leads to downloading)\r\n  const downloadLink = <a href={URL.createObjectURL(vertexPipelineSpecTextBlob)} download={\"pipeline.json\"}>pipeline.json</a>\r\n\r\n  return (\r\n    <details open>\r\n      <summary>Cloud IR {downloadLink}</summary>\r\n      <pre style={{overflow: \"auto\"}}>{vertexPipelineSpecText}</pre>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default CloudIrExporter;\r\n","import React, { DragEvent, useEffect, useState } from 'react';\r\n\r\nimport {downloadComponentDataWithCache} from '../github'\r\nimport {ComponentSpec, TaskSpec} from '../componentSpec'\r\nimport ComponentLibrary from './ComponentLibrary'\r\nimport GraphComponentExporter from './GraphComponentExporter'\r\nimport GoogleCloudSubmitter from './GoogleCloud'\r\nimport VertexAiExporter from './VertexAiExporter'\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData('application/reactflow', JSON.stringify(nodeData));\r\n  event.dataTransfer.effectAllowed = 'move';\r\n};\r\n\r\nconst COMPONENT_LIBRARY = [\r\n  {\r\n    category: \"Quick start\",\r\n    componentUrls: [\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/60a2612541ec08c6a85c237d2ec7525b12543a43/components/datasets/Chicago_Taxi_Trips/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/567c04c51ff00a1ee525b3458425b17adbe3df61/components/XGBoost/Train/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/567c04c51ff00a1ee525b3458425b17adbe3df61/components/XGBoost/Predict/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"Datasets\", componentUrls: [\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/60a2612541ec08c6a85c237d2ec7525b12543a43/components/datasets/Chicago_Taxi_Trips/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"Data manipulation\",\r\n    componentUrls: [\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/6162d55998b176b50267d351241100bb0ee715bc/components/pandas/Transform_DataFrame/in_CSV_format/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"Upload/Download\",\r\n    componentUrls: [\r\n    'https://raw.githubusercontent.com/Ark-kun/pipelines/54ac9a6a7173aecbbb30a043b2077e790cac6953/components/web/Download/component.yaml',\r\n    'https://raw.githubusercontent.com/Ark-kun/pipelines/2dac60c400ad8767b452649d08f328dfaf230f96/components/google-cloud/storage/download/component.yaml',\r\n    'https://raw.githubusercontent.com/Ark-kun/pipelines/2dac60c400ad8767b452649d08f328dfaf230f96/components/google-cloud/storage/upload_to_unique_uri/component.yaml',\r\n    'https://raw.githubusercontent.com/Ark-kun/pipelines/2dac60c400ad8767b452649d08f328dfaf230f96/components/google-cloud/storage/upload_to_explicit_uri/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"XGBoost\",\r\n    componentUrls: [\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/567c04c51ff00a1ee525b3458425b17adbe3df61/components/XGBoost/Train/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/567c04c51ff00a1ee525b3458425b17adbe3df61/components/XGBoost/Predict/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"PyTorch\",\r\n    componentUrls: [\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/4e1facea1a270535b515a9e8cc59422d1ad76a9e/components/PyTorch/Create_fully_connected_network/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/603342c4b88fe2d69ff07682f702cd3601e883bb/components/PyTorch/Train_PyTorch_model/from_CSV/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/e011e4affa85542ef2b24d63fdac27f8d939bbee/components/PyTorch/Convert_to_OnnxModel_from_PyTorchScriptModule/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"TFX\",\r\n    componentUrls: [\r\n    ]\r\n  },\r\n];\r\n\r\nconst Sidebar = () => {\r\n  const [componentSpec, setComponentSpec] = useState<ComponentSpec | undefined>(undefined);\r\n\r\n  const componentUrl = \"https://raw.githubusercontent.com/kubeflow/pipelines/603342c4b88fe2d69ff07682f702cd3601e883bb/components/PyTorch/Train_PyTorch_model/from_CSV/component.yaml\";\r\n  useEffect(() => {\r\n    downloadComponentDataWithCache(componentUrl).then(setComponentSpec);\r\n  }, []);\r\n\r\n  return (\r\n    <aside className=\"nodeList\">\r\n      <details open style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"8px\", fontWeight: \"bold\" }}>Submit to Google Cloud</summary>\r\n        <GoogleCloudSubmitter/>\r\n      </details>\r\n      <div className=\"description\">You can drag these nodes to the pane on the right.</div>\r\n      <div className=\"react-flow__node-input\" onDragStart={(event: DragEvent) => onDragStart(event, { input: { label: \"Input Node\" } })} draggable>\r\n        Input Node\r\n      </div>\r\n      <div className=\"react-flow__node-output\" onDragStart={(event: DragEvent) => onDragStart(event, { output: { label: \"Output Node\" } })} draggable>\r\n        Output Node\r\n      </div>\r\n      <ComponentLibrary componentGroups={COMPONENT_LIBRARY}/>\r\n      <GraphComponentExporter/>\r\n      <VertexAiExporter/>\r\n      <details>\r\n        <summary>Legacy nodes</summary>\r\n          <div className=\"react-flow__node-default\" onDragStart={(event: DragEvent) => onDragStart(event, { default: { label: \"Default Node\" } })} draggable>\r\n            Default Node\r\n          </div>\r\n          <div className=\"react-flow__node react-flow__node-multihandle\" draggable\r\n          onDragStart={(event: DragEvent) =>\r\n            onDragStart(event, { multihandle: {\r\n              handles: {\r\n                top: { type: \"target\", ids: [\"top_1\", \"top_2\", \"top_3\"] },\r\n                bottom: { type: \"source\", ids: [\"bottom_1\", \"bottom_2\"] },\r\n                left: { type: \"target\", ids: [\"left_1\"] },\r\n                right: { type: \"source\", ids: [\"right_1\"] },\r\n              },\r\n              label: \"Multi-handle node (3-2-1-1)\",\r\n            }})\r\n          }\r\n        >\r\n          Multi-port Node 3-2-1-1\r\n        </div>\r\n        <div className=\"react-flow__node react-flow__node-multihandle\" draggable\r\n          onDragStart={(event: DragEvent) => {\r\n            // Using await inside onDragStart breaks event.dataTransfer.setData! \r\n            //const componentSpec = await loadComponentFromUrl(\"https://raw.githubusercontent.com/kubeflow/pipelines/603342c4b88fe2d69ff07682f702cd3601e883bb/components/PyTorch/Train_PyTorch_model/from_CSV/component.yaml\");\r\n            if (componentSpec === undefined) {\r\n              return;\r\n            }\r\n            const inputs = componentSpec.inputs ?? []\r\n            const inputNames = inputs.map(inputSpec => inputSpec.name);\r\n            const outputs = componentSpec.outputs ?? []\r\n            const outputNames = outputs.map(outputSpec => outputSpec.name);\r\n            const componentName = componentSpec.name ?? \"Component\"\r\n            return onDragStart(event, { multihandle: {\r\n              handles: {\r\n                top: { type: \"target\", ids: inputNames },\r\n                bottom: { type: \"source\", ids: outputNames },\r\n              },\r\n              label: componentName,\r\n            }});\r\n          }}\r\n        >\r\n          PyTorch/Train_PyTorch_model/from_CSV\r\n        </div>\r\n        {\r\n          componentSpec !== undefined && <div className=\"react-flow__node react-flow__node-multihandle\" draggable\r\n            onDragStart={(event: DragEvent) => {\r\n              const taskSpec: TaskSpec = {\r\n                componentRef: {\r\n                  url: componentUrl,\r\n                  spec: componentSpec,\r\n                },\r\n              };\r\n              return onDragStart(event, { task: taskSpec});\r\n            }}\r\n          >\r\n            {componentSpec.name}\r\n          </div>\r\n        }\r\n      </details>\r\n    </aside>\r\n  );\r\n};\r\n\r\nexport default Sidebar;\r\n","import React, { DragEvent } from \"react\";\r\nimport { useState } from \"react\";\r\nimport { ComponentReference, TaskSpec } from \"../componentSpec\";\r\nimport { searchComponentsByName } from \"../github\";\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData(\"application/reactflow\", JSON.stringify(nodeData));\r\n  event.dataTransfer.effectAllowed = \"move\";\r\n};\r\n\r\nconst COMPONENT_ORGS = [\"kubeflow\", \"Ark-kun\"];\r\n\r\nconst SearchPanel = (props: any) => {\r\n  const [error, setError] = useState<string | undefined>(undefined);\r\n  const [firstTime, setFirstTime] = useState(true);\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const [query, setQuery] = useState(\"\");\r\n  const [items, setItems] = useState<ComponentReference[]>([]);\r\n\r\n  const onQueryChange = (e: any) => {\r\n    setQuery(e.target.value);\r\n  };\r\n\r\n  async function fetchData(query: string) {\r\n    searchComponentsByName(query, COMPONENT_ORGS).then(\r\n      (componentRefs) => {\r\n        setIsLoaded(true);\r\n        setItems(componentRefs);\r\n      },\r\n      (error) => {\r\n        setIsLoaded(true);\r\n        setError(error.message);\r\n      }\r\n    );\r\n  }\r\n\r\n  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {\r\n    e.preventDefault();\r\n    if (query !== \"\") {\r\n      setFirstTime(false);\r\n      fetchData(query);\r\n    }\r\n  };\r\n\r\n  let results = <span></span>;\r\n  if (firstTime) {\r\n    results = <div>Enter search query</div>;\r\n  } else if (error !== undefined) {\r\n    results = <div>Error: {error}</div>;\r\n  } else if (!firstTime && !isLoaded) {\r\n    results = <div>Searching...</div>;\r\n  } else if (items !== undefined) {\r\n    const componentElements = items.map((item) => (\r\n      <div\r\n        key={item.url}\r\n        title={item.url}\r\n        className=\"react-flow__node react-flow__node-multihandle\"\r\n        draggable\r\n        onDragStart={(event: DragEvent) => {\r\n          const taskSpec: TaskSpec = {\r\n            componentRef: item,\r\n          };\r\n          return onDragStart(event, { task: taskSpec });\r\n        }}\r\n      >\r\n        {item.spec?.name}\r\n      </div>\r\n    ));\r\n    results = <>{componentElements}</>;\r\n  }\r\n  return (\r\n    <div className=\"nodeList\">\r\n      <form onSubmit={onSubmit}>\r\n        <input type=\"search\" placeholder=\"XGBoost\" onChange={onQueryChange} />\r\n        <input type=\"submit\" />\r\n      </form>\r\n      <div>{results}</div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SearchPanel;\r\n","import React, { memo, FC } from 'react';\r\n\r\nimport { Handle, Position, NodeProps, HandleType } from 'react-flow-renderer';\r\n\r\ntype NodeData = {\r\n  label: string\r\n  handles: NodeHandles\r\n}\r\n\r\ntype NodeHandles = {\r\n  [key: string]: SideHandles // key is Position\r\n}\r\n\r\ntype SideHandles = {\r\n  type: HandleType\r\n  ids: string[]\r\n}\r\n\r\nconst MultiHandleNode: FC<NodeProps<NodeData>> = ({data}) => {\r\n  let handleComponents = [];\r\n  for (const position in data.handles) {\r\n    const sideHandles = data.handles[position];\r\n    const numHandles = sideHandles.ids.length;\r\n    for (let i = 0; i < numHandles; i++) {\r\n      const id = sideHandles.ids[i];\r\n      const relativePosition = (i + 1) / (numHandles + 1);\r\n      const positionPercentString = String(100 * relativePosition) + \"%\";\r\n      const style =\r\n        (position === Position.Top || position === Position.Bottom)\r\n          ? { left: positionPercentString }\r\n          : { top: positionPercentString };\r\n      handleComponents.push(\r\n        <Handle\r\n          key={id}\r\n          type={sideHandles.type}\r\n          position={position as Position}\r\n          id={id}\r\n          style={style}\r\n          isConnectable={true}\r\n        />\r\n      );\r\n    }\r\n  }\r\n\r\n  return (\r\n    <>\r\n      {data.label}\r\n      {handleComponents}\r\n    </>\r\n  );\r\n};\r\n\r\nexport default memo(MultiHandleNode);\r\n","import { memo } from 'react';\r\nimport {TaskSpec, InputSpec, OutputSpec} from '../componentSpec';\r\n\r\nimport { Handle, Position, NodeProps, HandleType } from 'react-flow-renderer';\r\n\r\nconst inputHandlePosition = Position.Top;\r\nconst outputHandlePosition = Position.Bottom;\r\n\r\ntype InputOrOutputSpec = InputSpec | OutputSpec;\r\n\r\nfunction generateHandles(\r\n  ioSpecs: InputOrOutputSpec[],\r\n  handleType: HandleType,\r\n  position: Position,\r\n  idPrefix: string,\r\n): JSX.Element[] {\r\n  let handleComponents = [];\r\n  const numHandles = ioSpecs.length;\r\n  for (let i = 0; i < numHandles; i++) {\r\n    const ioSpec = ioSpecs[i];\r\n    const id = idPrefix + ioSpec.name;\r\n    const relativePosition = (i + 1) / (numHandles + 1);\r\n    const positionPercentString = String(100 * relativePosition) + \"%\";\r\n    const style =\r\n      position === Position.Top || position === Position.Bottom\r\n        ? { left: positionPercentString }\r\n        : { top: positionPercentString };\r\n    const ioTypeName = ioSpec.type?.toString() ?? \"Any\";\r\n    const className = ioTypeName; // Need to be sanitized\r\n    handleComponents.push(\r\n      <Handle\r\n        key={id}\r\n        type={handleType}\r\n        position={position}\r\n        id={id}\r\n        style={style}\r\n        isConnectable={true}\r\n        title={ioSpec.name + \" : \" + ioTypeName}\r\n        className={\"handle_\" + className}\r\n      />\r\n    );\r\n  }\r\n  return handleComponents;\r\n}\r\n\r\nfunction generateInputHandles(inputSpecs: InputSpec[]): JSX.Element[] {\r\n  return generateHandles(inputSpecs, \"target\", inputHandlePosition, \"input_\");\r\n}\r\n\r\nfunction generateOutputHandles(outputSpecs: OutputSpec[]): JSX.Element[] {\r\n  return generateHandles(outputSpecs, \"source\", outputHandlePosition, \"output_\");\r\n}\r\n\r\nconst ComponentTaskNode = ({data}: NodeProps<TaskSpec>) => {\r\n  const taskSpec = data;\r\n  const componentSpec = taskSpec.componentRef.spec;\r\n  if (componentSpec === undefined) {\r\n    return (<></>);\r\n  }\r\n\r\n  const label = componentSpec.name ?? \"<component>\";\r\n  const inputHandles = generateInputHandles(componentSpec.inputs ?? []);\r\n  const outputHandles = generateOutputHandles(componentSpec.outputs ?? []);\r\n  const handleComponents = inputHandles.concat(outputHandles);\r\n\r\n  return (\r\n    <>\r\n      {label}\r\n      {handleComponents}\r\n    </>\r\n  );\r\n};\r\n\r\nexport default memo(ComponentTaskNode);\r\n","import React, { useState, DragEvent } from 'react';\r\nimport ReactFlow, {\r\n  ReactFlowProvider,\r\n  addEdge,\r\n  updateEdge,\r\n  removeElements,\r\n  Controls,\r\n  OnLoadParams,\r\n  Elements,\r\n  Connection,\r\n  Edge,\r\n  ElementId,\r\n  Node,\r\n  Background,\r\n  MiniMap,\r\n} from 'react-flow-renderer';\r\n\r\nimport Sidebar from './Sidebar';\r\nimport ComponentSearch from './ComponentSearch'\r\n\r\nimport MultiHandleNode from './MultiHandleNode';\r\nimport ComponentTaskNode from './ComponentTaskNode';\r\n\r\nimport './dnd.css';\r\n\r\nconst GRID_SIZE = 10;\r\n\r\nconst nodeTypes = {\r\n  multihandle: MultiHandleNode,\r\n  task: ComponentTaskNode,\r\n};\r\n\r\nconst initialElements = [{ id: '1', type: 'input', data: { label: 'input node' }, position: { x: 250, y: 10 } }];\r\n\r\nconst onDragOver = (event: DragEvent) => {\r\n  event.preventDefault();\r\n  event.dataTransfer.dropEffect = 'move';\r\n};\r\n\r\nlet id = 0;\r\nconst getId = (): ElementId => `task_${id++}`;\r\n\r\nconst DnDFlow = () => {\r\n  const [reactFlowInstance, setReactFlowInstance] = useState<OnLoadParams>();\r\n  const [elements, setElements] = useState<Elements>(initialElements);\r\n\r\n  // gets called after end of edge gets dragged to another source or target\r\n  const onEdgeUpdate = (oldEdge: Edge, newConnection: Connection) =>\r\n    setElements((els) => updateEdge(oldEdge, newConnection, els));\r\n  const onConnect = (params: Connection | Edge) => setElements((els) => addEdge(params, els));\r\n  const onElementsRemove = (elementsToRemove: Elements) => setElements((els) => removeElements(elementsToRemove, els));\r\n  const onLoad = (_reactFlowInstance: OnLoadParams) => setReactFlowInstance(_reactFlowInstance);\r\n\r\n  const onEdgeUpdateStart = (_: React.MouseEvent, edge: Edge) => console.log('start update', edge);\r\n  const onEdgeUpdateEnd = (_: MouseEvent, edge: Edge) => console.log('end update', edge);\r\n\r\n  const onDrop = (event: DragEvent) => {\r\n    event.preventDefault();\r\n\r\n    if (reactFlowInstance) {\r\n      const droppedData = event.dataTransfer.getData('application/reactflow');\r\n      if (droppedData === \"\") {\r\n        return;\r\n      }\r\n      const droppedDataObject = JSON.parse(droppedData);\r\n      const nodeType = Object.keys(droppedDataObject)[0];\r\n      const nodeData = droppedDataObject[nodeType];\r\n      const position = reactFlowInstance.project({ x: event.clientX, y: event.clientY - 40 });\r\n      const newNode: Node = {\r\n        //id: (nodeData?.componentRef?.spec?.name ?? \"task\") + \"_\" + getId(),\r\n        id: (nodeData?.componentRef?.spec?.name ?? \"task\") + \"_\" + `${id++}`,\r\n        type: nodeType,\r\n        position,\r\n        data: nodeData,\r\n      };\r\n\r\n      setElements((es) => es.concat(newNode));\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"dndflow\">\r\n      <ReactFlowProvider>\r\n        <div className=\"reactflow-wrapper\">\r\n          <ReactFlow\r\n            elements={elements}\r\n            onConnect={onConnect}\r\n            onElementsRemove={onElementsRemove}\r\n            onEdgeUpdateStart={onEdgeUpdateStart}\r\n            onEdgeUpdateEnd={onEdgeUpdateEnd}\r\n            onEdgeUpdate={onEdgeUpdate}\r\n            onLoad={onLoad}\r\n            onDrop={onDrop}\r\n            onDragOver={onDragOver}\r\n            nodeTypes={nodeTypes}\r\n            deleteKeyCode='Delete'\r\n            multiSelectionKeyCode='Control'\r\n            snapToGrid={true}\r\n            snapGrid={[GRID_SIZE, GRID_SIZE]}\r\n          >\r\n            <MiniMap/>\r\n            <Controls />\r\n            <Background gap={GRID_SIZE}/>\r\n          </ReactFlow>\r\n        </div>\r\n        <Sidebar />\r\n        <ComponentSearch />\r\n      </ReactFlowProvider>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DnDFlow;\r\n","import './App.css';\r\nimport DnDFlow from './DragNDrop/index';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\" style={{width: \"100%\", height: \"100%\"}}>\r\n      <DnDFlow/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://cra.link/PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://cra.link/PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then((registration) => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://cra.link/PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then((response) => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then((registration) => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log('No internet connection found. App is running in offline mode.');\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then((registration) => {\r\n        registration.unregister();\r\n      })\r\n      .catch((error) => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.register();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}