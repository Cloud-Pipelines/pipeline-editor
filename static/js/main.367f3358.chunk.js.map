{"version":3,"sources":["DragNDrop/samplePipelines.ts","DragNDrop/ArgumentsEditor.tsx","DragNDrop/ComponentTaskNode.tsx","DragNDrop/GraphComponentSpecFlow.tsx","github.ts","DragNDrop/vertexPipelineSpec.ts","DragNDrop/vertexAiCompiler.ts","componentStore.ts","componentSpec.ts","DragNDrop/UserComponentLibrary.tsx","DragNDrop/Sidebar.tsx","DragNDrop/ComponentLibrary.tsx","DragNDrop/ComponentSearch.tsx","DragNDrop/GraphComponentExporter.tsx","DragNDrop/GoogleCloud.tsx","DragNDrop/VertexAiExporter.tsx","DragNDrop/GraphComponentLink.tsx","DragNDrop/KubeflowPipelines.tsx","DragNDrop/index.tsx","App.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","index.tsx"],"names":["TFX_PIPELINE_URL","XGBOOST_PIPELINE_URL","PYTORCH_PIPELINE_URL","DATA_PASSING_PIPELINE_URL","preloadComponentReferences","componentSpec","componentMap","a","undefined","Map","implementation","Object","values","graph","tasks","taskSpec","componentUrl","componentRef","url","spec","taskComponentSpec","get","downloadComponentDataWithCache","set","loadComponentFromUrl","preloadChildComponentSpecs","ArgumentsEditor","closeEditor","setArguments","useState","arguments","currentArguments","setCurrentArguments","console","error","inputSpecs","inputs","onSubmit","e","preventDefault","style","position","display","borderSpacing","background","border","borderRadius","padding","name","map","inputSpec","inputName","value","placeholder","argument","default","taskOutput","taskId","outputName","graphInput","typeSpec","argumentIsRequiredButMissing","optional","typeSpecString","type","JSON","stringify","textAlign","whiteSpace","textOverflow","overflow","maxWidth","verticalAlign","title","required","pattern","onChange","target","onClick","disabled","inputHandlePosition","Position","Top","outputHandlePosition","Bottom","isComponentTaskNode","node","data","generateHandles","ioSpecs","handleType","idPrefix","inputsWithMissingArguments","handleComponents","numHandles","length","i","ioSpec","id","positionPercentString","String","left","top","ioTypeName","toString","classNames","replace","includes","push","className","generateLabelStyle","labelClasses","labelStyle","isConnectable","join","maxLabelWidthPx","ComponentTaskNode","isArgumentsEditorOpen","setIsArgumentsEditorOpen","label","inputsWithInvalidArguments","filter","inputHandles","generateInputHandles","outputHandles","outputs","concat","onDoubleClick","SDK_ANNOTATION_VALUE","augmentComponentSpec","nodes","includeSpecs","includePositions","getNodePositionAnnotation","x","__rf","y","width","height","nodeXPositionComparer","n1","n2","deltaX","deltaY","nodeYPositionComparer","inputNodes","sort","outputNodes","taskNodes","inputPositionMap","inputOrderMap","index","inputOrderComparer","b","Infinity","outputPositionMap","outputOrderMap","outputOrderComparer","taskPositionMap","taskOrderMap","taskOrderComparer","pairA","pairB","has","Error","newAnnotations","annotations","NODE_LAYOUT_ANNOTATION_KEY","newInputSpec","keys","outputSpec","newOutputSpec","graphSpec","newTasks","fromEntries","entries","newTaskSpec","rebuildComponentSpec","description","metadata","rest","nodeTypes","task","memo","GraphComponentSpecFlow","children","setComponentSpec","reactFlowInstance","setReactFlowInstance","layoutAnnotation","decodedPosition","parse","err","args","setTaskArguments","edges","flatMap","source","sourceHandle","targetHandle","arrowHeadType","ArrowHeadType","ArrowClosed","outputEdges","outputValues","elements","replaceComponentSpec","newComponentSpec","replaceGraphSpec","newGraphSpec","taskArguments","setTaskArgument","oldTaskSpecArguments","newTaskSpecArguments","removeTaskArgument","setGraphOutputValue","outputValue","newGraphOutputValues","removeGraphOutputValue","addConnection","connection","targetTaskInputName","sourceTaskOutputName","taskOutputArgument","graphInputArgument","removeEdge","edge","removeNode","newInputs","removeComponentInput","newOutputs","removeComponentOutput","removeTask","log","makeNameUniqueByAddingIndex","existingNames","finalName","onConnect","params","onDragOver","event","dataTransfer","dropEffect","onDrop","droppedData","getData","droppedDataObject","nodeType","nodeData","dragOffsetX","dragOffsetY","dragStartOffsetData","dragStartOffset","offsetX","offsetY","project","clientX","clientY","nodePosition","positionAnnotations","mergedAnnotations","taskSpecWithAnnotation","Set","getUniqueTaskName","getUniqueInputName","getUniqueOutputName","onEdgeUpdate","oldEdge","newConnection","onElementsRemove","elementsToRemove","element","isEdge","isNode","onLoad","_reactFlowInstance","SEARCH_CACHE_NAME","BLOB_CACHE_NAME","DB_NAME","HASH_TO_CONTENT_DB_TABLE_NAME","HASH_TO_COMPONENT_NAME_DB_TABLE_NAME","URL_TO_HASH_DB_TABLE_NAME","HASH_TO_URL_DB_TABLE_NAME","URL_PROCESSING_VERSION_TABLE_NAME","BAD_HASHES_TABLE_NAME","httpGetWithCache","urlOrRequest","cacheName","updateIfInCache","caches","open","cache","match","response","add","response2","Promise","reject","searchGitHubCodeWithCache","query","page","order","encodedQuery","encodeURIComponent","encodedSort","encodedOrder","searchUrl","json","githubHtmlUrlToDownloadUrl","htmlUrl","getComponentUrlsAndHashes","users","urlsAndHashes","user","searchResults","items","item","html_url","hash","sha","resolve","setTimeout","blob","text","componentText","yaml","load","cacheAllComponents","debug","urlsAndHashesIterator","urlToHashDb","localForage","createInstance","storeName","hashToUrlDb","hashToContentDb","hashToComponentNameDb","urlProcessingVersionDb","badHashesDb","toLowerCase","getItem","badHashReason","downloadUrl","endsWith","cachedHash","urlVersion","Number","parseInt","setItem","message","getAllComponentsAsRefs","hashToComponentRef","cachePromise","iterate","iterationNumber","componentRefs","forEach","searchComponentsByName","ref","PrimitiveTypeEnum","TriggerStrategy","sanitizePipelineInfoName","pipelineContextName","resolveCommandLine","containerSpec","container","inputsConsumedAsValue","inputsConsumedAsPath","convertArg","arg","inputValue","inputPath","outputPath","if","cond","then","else","ifCond","ifThen","ifElse","condEvaluatesToTrue","isPresent","taskArgument","unresolvedArgs","command","isContainerImplementation","implementationType","typeSpecToVertexPrimitiveTypeEnum","vertex","INT","DOUBLE","STRING","typeSpecToVertexParameterSpec","MAKE_ARTIFACT_COMPONENT_ID","MAKE_ARTIFACT_EXECUTOR_ID","MAKE_ARTIFACT_INPUT_NAME","MAKE_ARTIFACT_OUTPUT_NAME","makeArtifactTaskSpecTemplate","taskInfo","parameters","cachingOptions","enableCache","makeArtifactComponentSpec","executorLabel","inputDefinitions","outputDefinitions","artifacts","artifactType","schemaTitle","makeArtifactExecutorSpec","image","taskSpecToVertexTaskSpecComponentSpecAndExecutorSpec","generateTaskID","isRoot","resolvedCommandLine","vertexExecutorSpec","inputMap","vertexComponentInputsSpec","Array","from","vertexComponentOutputsSpec","vertexComponentSpec","vertexTaskParameterArguments","runtimeValue","constantValue","stringValue","componentInputParameter","taskOutputParameter","producerTask","outputParameterKey","vertexMakeArtifactTaskSpecs","vertexTaskArtifactArguments","result","makeArtifactTaskId","makeArtifactTaskSpec","taskOutputArtifact","outputArtifactKey","componentInputArtifact","vertexTaskSpec","graphComponentSpecToVertexPipelineSpec","vertexExecutors","vertexComponents","vertexTasks","usedTaskIds","generateTaskId","prefix","vertexExecutorId","vertexComponentId","vertexTaskId","additionalTaskId","additionalTaskSpec","vertexPipelineSpec","pipelineInfo","sdkVersion","schemaVersion","deploymentSpec","executors","components","root","dag","generateVertexPipelineJobFromGraphComponent","gcsOutputDirectory","pipelineArguments","convertedPipelineArguments","key","pipelineSpec","pipelineJob","displayName","runtimeConfig","DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME","DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME","calculateHashDigestHex","dataBytes","TextEncoder","encode","crypto","subtle","digest","hashBuffer","hashArray","Uint8Array","hashHex","padStart","storeComponentSpec","digestToComponentSpecDb","digestToComponentNameDb","storeComponentText","componentString","TextDecoder","decode","componentBytes","loadedObj","digestToComponentTextDb","digestToCanonicalUrlDb","digestToComponentRef","UserComponentLibrary","errorMessage","setErrorMessage","setComponentRefs","useEffect","useCallback","acceptedFiles","file","reader","FileReader","onabort","onerror","onload","binaryStr","allComponentRefs","readAsArrayBuffer","useDropzone","getRootProps","getInputProps","isDragActive","minHeight","draggable","onDragStart","setData","nativeEvent","effectAllowed","COMPONENT_LIBRARY","category","componentUrls","Sidebar","borderWidth","fontWeight","input","output","componentGroups","process","NODE_ENV","DraggableComponentRow","ComponentGroupList","ComponentLibrary","paddingLeft","COMPONENT_ORGS","SearchPanel","props","setError","firstTime","setFirstTime","isLoaded","setIsLoaded","setQuery","setItems","results","componentElements","fetchData","GraphComponentExporter","useStoreState","store","graphComponent","dump","lineWidth","componentTextBlob","Blob","downloadLink","href","URL","createObjectURL","download","LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY","LOCAL_STORAGE_PROJECT_ID_KEY","LOCAL_STORAGE_REGION_KEY","LOCAL_STORAGE_PROJECT_IDS_KEY","CLIENT_ID","API_KEY","VERTEX_AI_PIPELINES_REGIONS","authorizeGoogleCloudClient","scopes","immediate","apiKey","clientId","gapi","client","setApiKey","auth","authorize","client_id","scope","authResult","receivedScopesString","receivedScopes","split","every","ensureGoogleCloudAuthorizesScopes","cloudresourcemanagerListProjects","request","path","aiplatformCreatePipelineJob","projetId","region","method","body","GoogleCloudSubmitter","window","localStorage","projects","setProjects","setProject","setRegion","setGcsOutputDirectory","pipelineJobWebUrl","setPipelineJobWebUrl","compilationError","setCompilationError","vertexPipelineJobJson","vertexPipelineJob","defaultInputValues","vertexPipelineJobUrl","readyToSubmit","pipelineJobName","pipelineJobId","slice","htmlFor","list","projectId","projectIds","projectInfo","rel","VertexAiExporter","vertexPipelineSpecText","vertexPipelineSpecTextBlob","vertexPipelineSpecTextBlobUrl","GraphComponentLink","downloadFileName","linkText","KubeflowPipelinesSubmitter","setMessage","fetch","headers","Headers","responseText","SAVED_COMPONENT_SPEC_KEY","ComponentSpecAutoSaver","warn","sessionStorage","saveComponentSpec","DnDFlow","restoredComponentSpec","loadedYaml","loadComponentSpec","deleteKeyCode","multiSelectionKeyCode","snapToGrid","snapGrid","gap","App","isLocalhost","Boolean","location","hostname","registerValidSW","swUrl","config","navigator","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","onUpdate","onSuccess","catch","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","origin","addEventListener","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker","serviceWorkerRegistration"],"mappings":"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","file":"static/js/main.367f3358.chunk.js","sourcesContent":["import { ComponentSpec } from \"../componentSpec\";\r\nimport { downloadComponentDataWithCache } from \"../github\";\r\n\r\nconst TFX_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipelines/2765b13699ac28de523f499eeaa9eb2ed9b8798a/components/deprecated/tfx/_samples/TFX.pipeline.component.yaml\"\r\nconst XGBOOST_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipelines/77df9c97191a181fcd3cded83f147799d46eca20/components/XGBoost/_samples/sample_pipeline.pipeline.component.yaml\"\r\nconst PYTORCH_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipelines/322c0c75f32d87acfd5da9c390dee0b5799bfdaf/components/PyTorch/_samples/Train_fully-connected_network.pipeline.component.yaml\"\r\nexport const DATA_PASSING_PIPELINE_URL = \"https://raw.githubusercontent.com/Ark-kun/pipelines/b45c82e42588ee0a86b8875d1908d972275bfd2f/samples/test/data_passing.pipeline.component.yaml\"\r\n\r\nconst preloadComponentReferences = async (\r\n  componentSpec: ComponentSpec,\r\n  componentMap?: Map<string, ComponentSpec>\r\n) => {\r\n  // This map is needed to improve efficiency and handle recursive components.\r\n  if (componentMap === undefined) {\r\n    componentMap = new Map<string, ComponentSpec>();\r\n  }\r\n  if (\"graph\" in componentSpec.implementation) {\r\n    for (const taskSpec of Object.values(\r\n      componentSpec.implementation.graph.tasks\r\n    )) {\r\n      const componentUrl = taskSpec.componentRef.url;\r\n      if (\r\n        taskSpec.componentRef.spec === undefined &&\r\n        componentUrl !== undefined\r\n      ) {\r\n        let taskComponentSpec = componentMap.get(componentUrl);\r\n        if (taskComponentSpec === undefined) {\r\n          taskComponentSpec = await downloadComponentDataWithCache(\r\n            componentUrl\r\n          );\r\n          componentMap.set(componentUrl, taskComponentSpec);\r\n        }\r\n        taskSpec.componentRef.spec = taskComponentSpec;\r\n        await preloadComponentReferences(taskComponentSpec, componentMap);\r\n      }\r\n    }\r\n  }\r\n  return componentSpec;\r\n};\r\n\r\nconst loadComponentFromUrl = async (\r\n  url: string,\r\n  preloadChildComponentSpecs = true\r\n) => {\r\n  let componentSpec = await downloadComponentDataWithCache(url);\r\n  if (preloadChildComponentSpecs) {\r\n    componentSpec = await preloadComponentReferences(componentSpec);\r\n  }\r\n  return componentSpec;\r\n};\r\n\r\nexport { loadComponentFromUrl, preloadComponentReferences, XGBOOST_PIPELINE_URL, PYTORCH_PIPELINE_URL, TFX_PIPELINE_URL };\r\n","import { useState } from \"react\";\r\nimport { ArgumentType, TaskSpec, TypeSpecType } from \"../componentSpec\";\r\n\r\ninterface ArgumentsEditorProps {\r\n  taskSpec: TaskSpec;\r\n  closeEditor?: () => void;\r\n  setArguments?: (args: Record<string, ArgumentType>) => void;\r\n}\r\n\r\nconst getPatternForTypeSpec = (typeSpec?: TypeSpecType) => {\r\n  // TODO: Implement\r\n  return undefined;\r\n};\r\n\r\nconst typeSpecToString = (typeSpec?: TypeSpecType): string => {\r\n  if (typeSpec === undefined) {\r\n    return \"Any\";\r\n  }\r\n  if (typeof typeSpec === \"string\") {\r\n    return typeSpec\r\n  }\r\n  return JSON.stringify(typeSpec);\r\n};\r\n\r\nconst ArgumentsEditor = ({\r\n  taskSpec,\r\n  closeEditor,\r\n  setArguments,\r\n}: ArgumentsEditorProps) => {\r\n  const [currentArguments, setCurrentArguments] = useState<\r\n    Record<string, ArgumentType>\r\n  >({ ...taskSpec.arguments });\r\n\r\n  const componentSpec = taskSpec.componentRef.spec;\r\n  if (componentSpec === undefined) {\r\n    console.error(\r\n      \"ArgumentsEditor called with missing taskSpec.componentRef.spec\",\r\n      taskSpec\r\n    );\r\n    return <></>;\r\n  }\r\n\r\n  const inputSpecs = componentSpec.inputs ?? [];\r\n\r\n  return (\r\n    <form\r\n      onSubmit={async (e) => {\r\n        e.preventDefault();\r\n      }}\r\n      // Does not work\r\n      // draggable={false}\r\n      style={{\r\n        position: \"fixed\",\r\n        display: \"table\",\r\n        borderSpacing: \"5px\",\r\n        background: \"white\",\r\n        border: \"1px solid black\",\r\n        borderRadius: \"4px\",\r\n        padding: \"15px\",\r\n        // Does not work\r\n        // zIndex: 11,\r\n      }}\r\n    >\r\n      <legend>Input arguments for {componentSpec.name}</legend>\r\n      <div>\r\n        {inputSpecs.map((inputSpec) => {\r\n          const inputName = inputSpec.name;\r\n          let value: string | undefined = undefined;\r\n          let placeholder: string | undefined = undefined;\r\n          const argument = currentArguments[inputName];\r\n          if (argument === undefined) {\r\n            value = inputSpec.default;\r\n          } else {\r\n            if (typeof argument === \"string\") {\r\n              value = argument;\r\n            } else if (\"taskOutput\" in argument) {\r\n              placeholder = `<from task ${argument.taskOutput.taskId} / ${argument.taskOutput.outputName}>`;\r\n            } else if (\"graphInput\" in argument) {\r\n              placeholder = `<from graph input ${argument.graphInput.inputName}>`;\r\n            } else {\r\n              placeholder = \"<reference>\";\r\n            }\r\n          }\r\n\r\n          const argumentIsRequiredButMissing =\r\n            !(inputName in currentArguments) &&\r\n            inputSpec.optional !== true &&\r\n            inputSpec.default === undefined;\r\n          \r\n          const typeSpecString = typeSpecToString(inputSpec.type);\r\n\r\n          return (\r\n            <div\r\n              key={inputName}\r\n              style={{\r\n                display: \"table-row\",\r\n              }}\r\n            >\r\n              <label\r\n                style={{\r\n                  textAlign: \"right\",\r\n                  display: \"table-cell\",\r\n                  whiteSpace: \"nowrap\",\r\n                }}\r\n              >\r\n                <span>\r\n                  {inputName} (\r\n                  <span\r\n                    style={{\r\n                      textOverflow: \"ellipsis\",\r\n                      overflow: \"hidden\",\r\n                      maxWidth: \"90px\",\r\n                      display: \"inline-block\",\r\n                      verticalAlign: \"bottom\",\r\n                    }}\r\n                    title={typeSpecString}\r\n                  >\r\n                    {typeSpecString}\r\n                  </span>\r\n                  )\r\n                </span>\r\n              </label>\r\n              <input\r\n                style={{\r\n                  display: \"table-cell\",\r\n                }}\r\n                placeholder={placeholder}\r\n                required={argumentIsRequiredButMissing}\r\n                value={value ?? \"\"}\r\n                pattern={getPatternForTypeSpec(inputSpec.type)}\r\n                onChange={(e) => {\r\n                  currentArguments[inputName] = e.target.value;\r\n                  setCurrentArguments({ ...currentArguments });\r\n                }}\r\n              />\r\n              <div\r\n                style={{\r\n                  display: \"table-cell\",\r\n                }}\r\n              >\r\n                <button\r\n                  type=\"button\"\r\n                  title=\"Reset to default\"\r\n                  onClick={(e) => {\r\n                    delete currentArguments[inputName];\r\n                    setCurrentArguments({ ...currentArguments });\r\n                  }}\r\n                  disabled={!(inputName in currentArguments)}\r\n                >\r\n                  \r\n                </button>\r\n              </div>\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n      <button type=\"button\" onClick={closeEditor}>\r\n        Close\r\n      </button>\r\n      <button\r\n        type=\"button\"\r\n        onClick={(e) => {\r\n          setArguments?.(currentArguments);\r\n          closeEditor?.();\r\n        }}\r\n      >\r\n        Apply\r\n      </button>\r\n    </form>\r\n  );\r\n};\r\n\r\n//export default memo(ArgumentsEditor);\r\nexport default ArgumentsEditor;\r\n","import { CSSProperties, memo, useState } from 'react';\r\nimport {\r\n  ArgumentType,\r\n  InputSpec,\r\n  OutputSpec,\r\n  TaskSpec,\r\n} from '../componentSpec';\r\n\r\nimport { Handle, Position, Node, NodeProps, HandleType } from 'react-flow-renderer';\r\n\r\nimport ArgumentsEditor from './ArgumentsEditor';\r\n\r\nconst inputHandlePosition = Position.Top;\r\nconst outputHandlePosition = Position.Bottom;\r\n\r\ntype InputOrOutputSpec = InputSpec | OutputSpec;\r\n\r\nconst MISSING_ARGUMENT_CLASS_NAME = \"missing-argument\";\r\n\r\nconst NODE_WIDTH_IN_PX = 180;\r\n\r\nexport const isComponentTaskNode = (node: Node): node is Node<ComponentTaskNodeProps> =>\r\n  node.type === \"task\" && node.data !== undefined && \"taskSpec\" in node.data;\r\n\r\nfunction generateHandles(\r\n  ioSpecs: InputOrOutputSpec[],\r\n  handleType: HandleType,\r\n  position: Position,\r\n  idPrefix: string,\r\n  inputsWithMissingArguments?: string[],\r\n): JSX.Element[] {\r\n  let handleComponents = [];\r\n  const numHandles = ioSpecs.length;\r\n  for (let i = 0; i < numHandles; i++) {\r\n    const ioSpec = ioSpecs[i];\r\n    const id = idPrefix + ioSpec.name;\r\n    const relativePosition = (i + 1) / (numHandles + 1);\r\n    const positionPercentString = String(100 * relativePosition) + \"%\";\r\n    const style =\r\n      position === Position.Top || position === Position.Bottom\r\n        ? { left: positionPercentString }\r\n        : { top: positionPercentString };\r\n    // TODO: Handle complex type specs\r\n    const ioTypeName = ioSpec.type?.toString() ?? \"Any\";\r\n    let classNames = [`handle_${idPrefix}${ioTypeName}`.replace(\" \", \"_\")];\r\n    const isInvalid = (inputsWithMissingArguments ?? []).includes(ioSpec.name);\r\n    if (isInvalid) {\r\n      classNames.push(MISSING_ARGUMENT_CLASS_NAME);\r\n    }\r\n    classNames = classNames.map((className) => className.replace(\" \", \"_\"));\r\n\r\n    const [labelClasses, labelStyle] = generateLabelStyle(position, numHandles);\r\n    handleComponents.push(\r\n      <Handle\r\n        key={id}\r\n        type={handleType}\r\n        position={position}\r\n        id={id}\r\n        style={style}\r\n        isConnectable={true}\r\n        title={ioSpec.name + \" : \" + ioTypeName}\r\n        className={classNames.join(\" \")}\r\n      >\r\n        <div className={labelClasses} style={labelStyle}>\r\n          {ioSpec.name}\r\n        </div>\r\n      </Handle>\r\n    );\r\n  }\r\n  return handleComponents;\r\n}\r\n\r\n\r\nfunction generateLabelStyle(\r\n  position: Position,\r\n  numHandles: number\r\n): [string, CSSProperties] {\r\n  let maxLabelWidthPx = NODE_WIDTH_IN_PX;\r\n  // By default, we want to place the label on the same side of the handle as the handle is on the side of the node.\r\n  let labelClasses = \"label\";\r\n  // When there are too many inputs/outputs, we need to move the label so it starts from the handle.\r\n  // Based on my tests, we always want this for >4 handles (top/bottom), so the rotated default placement is never used at all.\r\n\r\n  if (position === Position.Top || position === Position.Bottom) {\r\n    if (numHandles > 1) {\r\n      // For single handle max width is the node width, while the formula would give half of that\r\n      maxLabelWidthPx = NODE_WIDTH_IN_PX / (numHandles + 1);\r\n    }\r\n    //if (numHandles > 4) {\r\n    if (maxLabelWidthPx < 35) {\r\n      maxLabelWidthPx = 50;\r\n      labelClasses += \" label-angled\";\r\n    }\r\n  } else {\r\n    maxLabelWidthPx = 60;\r\n  }\r\n\r\n  const labelStyle: CSSProperties = { maxWidth: `${maxLabelWidthPx}px` };\r\n  return [labelClasses, labelStyle];\r\n}\r\n\r\nfunction generateInputHandles(inputSpecs: InputSpec[], inputsWithInvalidArguments?: string[]): JSX.Element[] {\r\n  return generateHandles(inputSpecs, \"target\", inputHandlePosition, \"input_\", inputsWithInvalidArguments);\r\n}\r\n\r\nfunction generateOutputHandles(outputSpecs: OutputSpec[]): JSX.Element[] {\r\n  return generateHandles(outputSpecs, \"source\", outputHandlePosition, \"output_\");\r\n}\r\n\r\nexport interface ComponentTaskNodeProps {\r\n  taskSpec: TaskSpec,\r\n  taskId?: string,\r\n  setArguments?: (args: Record<string, ArgumentType>) => void;\r\n};\r\n\r\nconst ComponentTaskNode = ({ data }: NodeProps<ComponentTaskNodeProps>) => {\r\n  const [isArgumentsEditorOpen, setIsArgumentsEditorOpen] = useState(false);\r\n\r\n  const taskSpec = data.taskSpec;\r\n  const componentSpec = taskSpec.componentRef.spec;\r\n  if (componentSpec === undefined) {\r\n    return (<></>);\r\n  }\r\n\r\n  const label = componentSpec.name ?? \"<component>\";\r\n  const inputsWithInvalidArguments = (componentSpec.inputs ?? [])\r\n    .filter(\r\n      (inputSpec) =>\r\n        inputSpec.optional !== true &&\r\n        inputSpec.default === undefined &&\r\n        !(inputSpec.name in (taskSpec.arguments ?? {}))\r\n    )\r\n    .map((inputSpec) => inputSpec.name);\r\n  const inputHandles = generateInputHandles(componentSpec.inputs ?? [], inputsWithInvalidArguments);\r\n  const outputHandles = generateOutputHandles(componentSpec.outputs ?? []);\r\n  const handleComponents = inputHandles.concat(outputHandles);\r\n\r\n  const closeArgumentsEditor = () => {\r\n    setIsArgumentsEditorOpen(false);\r\n  }\r\n\r\n  return (\r\n    <div\r\n      onDoubleClick={() => {\r\n        setIsArgumentsEditorOpen(!isArgumentsEditorOpen);\r\n      }}\r\n      title={data.taskId}\r\n    >\r\n      {label}\r\n      {handleComponents}\r\n      {isArgumentsEditorOpen && (\r\n        <ArgumentsEditor\r\n          taskSpec={taskSpec}\r\n          closeEditor={closeArgumentsEditor}\r\n          setArguments={data.setArguments}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default memo(ComponentTaskNode);\r\n","import React, { DragEvent, useState } from \"react\";\r\nimport ReactFlow, {\r\n  ArrowHeadType,\r\n  Connection,\r\n  Edge,\r\n  ElementId,\r\n  Elements,\r\n  isEdge,\r\n  isNode,\r\n  Node,\r\n  OnLoadParams,\r\n  ReactFlowProps,\r\n  XYPosition,\r\n} from \"react-flow-renderer\";\r\n\r\nimport {\r\n  ArgumentType,\r\n  ComponentSpec,\r\n  GraphInputArgument,\r\n  GraphSpec,\r\n  InputSpec,\r\n  OutputSpec,\r\n  TaskOutputArgument,\r\n  TaskSpec,\r\n} from \"../componentSpec\";\r\nimport ComponentTaskNode, { ComponentTaskNodeProps, isComponentTaskNode } from \"./ComponentTaskNode\";\r\n\r\n\r\nconst NODE_LAYOUT_ANNOTATION_KEY = \"editor.position\";\r\nconst SDK_ANNOTATION_KEY = \"sdk\";\r\nconst SDK_ANNOTATION_VALUE = \"https://cloud-pipelines.github.io/pipeline-editor/\";\r\n\r\nexport const augmentComponentSpec = (\r\n  componentSpec: ComponentSpec,\r\n  nodes: Node[],\r\n  includeSpecs = false,\r\n  includePositions = true\r\n) => {\r\n  componentSpec = { ...componentSpec };\r\n\r\n  const getNodePositionAnnotation = (node: Node) =>\r\n    JSON.stringify({\r\n      // node.position cannot be used since set at 1st drop and never updated\r\n      x: node.__rf.position.x,\r\n      y: node.__rf.position.y,\r\n      width: node.__rf.width,\r\n      height: node.__rf.height,\r\n    });\r\n\r\n  const nodeXPositionComparer = (n1: Node, n2: Node) => {\r\n    const deltaX = n1.__rf.position.x - n2.__rf.position.x;\r\n    const deltaY = n1.__rf.position.y - n2.__rf.position.y;\r\n    return deltaX !== 0 ? deltaX : deltaY;\r\n  };\r\n  const nodeYPositionComparer = (n1: Node, n2: Node) => {\r\n    const deltaX = n1.__rf.position.x - n2.__rf.position.x;\r\n    const deltaY = n1.__rf.position.y - n2.__rf.position.y;\r\n    return deltaY !== 0 ? deltaY : deltaX;\r\n  };\r\n\r\n  // Input and output nodes\r\n  // Sorting them by horisontal position to make reordering inputs and outputs easy.\r\n  const inputNodes = nodes\r\n    .filter((node) => node.type === \"input\")\r\n    .sort(nodeXPositionComparer);\r\n  const outputNodes = nodes\r\n    .filter((node) => node.type === \"output\")\r\n    .sort(nodeXPositionComparer);\r\n  const taskNodes = nodes\r\n    .filter(isComponentTaskNode)\r\n    .sort(nodeYPositionComparer);\r\n\r\n  // TODO: Remove \"input_\" prefixes\r\n  const inputPositionMap = new Map<string, string>(\r\n    inputNodes.map((node) => [node.id, getNodePositionAnnotation(node)])\r\n  );\r\n  const inputOrderMap = new Map<string, number>(\r\n    inputNodes.map((node, index) => [node.id, index])\r\n  );\r\n  const inputOrderComparer = (a: InputSpec, b: InputSpec) =>\r\n    (inputOrderMap.get(a.name) ?? Infinity) -\r\n    (inputOrderMap.get(b.name) ?? Infinity);\r\n  // TODO: Remove \"output_\" prefixes\r\n  const outputPositionMap = new Map<string, string>(\r\n    outputNodes.map((node) => [node.id, getNodePositionAnnotation(node)])\r\n  );\r\n  const outputOrderMap = new Map<string, number>(\r\n    outputNodes.map((node, index) => [node.id, index])\r\n  );\r\n  const outputOrderComparer = (a: OutputSpec, b: OutputSpec) =>\r\n    (outputOrderMap.get(a.name) ?? Infinity) -\r\n    (outputOrderMap.get(b.name) ?? Infinity);\r\n  // TODO: Remove \"task_\" prefixes\r\n  const taskPositionMap = new Map<string, string>(\r\n    taskNodes.map((node) => [node.id, getNodePositionAnnotation(node)])\r\n  );\r\n  const taskOrderMap = new Map<string, number>(\r\n    taskNodes.map((node, index) => [node.id, index])\r\n  );\r\n  const taskOrderComparer = (\r\n    pairA: [string, TaskSpec],\r\n    pairB: [string, TaskSpec]\r\n  ) =>\r\n    (taskOrderMap.get(pairA[0]) ?? Infinity) -\r\n    (taskOrderMap.get(pairB[0]) ?? Infinity);\r\n\r\n  componentSpec.inputs = componentSpec.inputs\r\n    ?.map((inputSpec) => {\r\n      if (!inputPositionMap.has(inputSpec.name) || !inputOrderMap.has(inputSpec.name)) {\r\n        throw Error(`The nodes array does not have input node ${inputSpec.name}`);\r\n      }\r\n      let newAnnotations = { ...inputSpec.annotations };\r\n      if (includePositions) {\r\n        newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] = inputPositionMap.get(\r\n          inputSpec.name\r\n        );\r\n      } else {\r\n        delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n      }\r\n      let newInputSpec: InputSpec = {\r\n        ...inputSpec,\r\n        annotations: newAnnotations,\r\n      };\r\n      if (Object.keys(newAnnotations).length === 0) {\r\n        delete newInputSpec.annotations;\r\n      }\r\n      return newInputSpec;\r\n    })\r\n    .sort(inputOrderComparer);\r\n\r\n  componentSpec.outputs = componentSpec.outputs\r\n    ?.map((outputSpec) => {\r\n      if (!outputPositionMap.has(outputSpec.name) || !outputOrderMap.has(outputSpec.name)) {\r\n        throw Error(`The nodes array does not have output node ${outputSpec.name}`);\r\n      }\r\n      let newAnnotations = { ...outputSpec.annotations };\r\n      if (includePositions) {\r\n        newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] = outputPositionMap.get(\r\n          outputSpec.name\r\n        );\r\n      } else {\r\n        delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n      }\r\n      let newOutputSpec: OutputSpec = {\r\n        ...outputSpec,\r\n        annotations: newAnnotations,\r\n      };\r\n      if (\r\n        newAnnotations === undefined ||\r\n        Object.keys(newAnnotations).length === 0\r\n      ) {\r\n        delete newOutputSpec.annotations;\r\n      }\r\n      return newOutputSpec;\r\n    })\r\n    .sort(outputOrderComparer);\r\n\r\n  if (!(\"graph\" in componentSpec.implementation)) {\r\n    return componentSpec;\r\n  }\r\n\r\n  let graphSpec: GraphSpec = { ...componentSpec.implementation.graph };\r\n  const newTasks = Object.fromEntries(\r\n    Object.entries(graphSpec.tasks || {})\r\n      .map(([taskId, taskSpec]) => {\r\n        if (!taskPositionMap.has(taskId) || !taskOrderMap.has(taskId)) {\r\n          throw Error(`The nodes array does not have task node ${taskId}`);\r\n        }\r\n        let newAnnotations = { ...taskSpec.annotations };\r\n        if (includePositions) {\r\n          newAnnotations[NODE_LAYOUT_ANNOTATION_KEY] =\r\n            taskPositionMap.get(taskId);\r\n        } else {\r\n          delete newAnnotations[NODE_LAYOUT_ANNOTATION_KEY];\r\n        }\r\n        let newTaskSpec: TaskSpec = {\r\n          ...taskSpec,\r\n          annotations: newAnnotations,\r\n        };\r\n        if (\r\n          newAnnotations === undefined ||\r\n          Object.keys(newAnnotations).length === 0\r\n        ) {\r\n          delete newTaskSpec.annotations;\r\n        }\r\n        // TODO: Sort the arguments based on the ordering of the component inputs.\r\n        if (\r\n          !includeSpecs &&\r\n          newTaskSpec.componentRef.spec !== undefined &&\r\n          newTaskSpec.componentRef.url !== undefined\r\n        ) {\r\n          newTaskSpec.componentRef = { ...newTaskSpec.componentRef };\r\n          delete newTaskSpec.componentRef.spec;\r\n        }\r\n        return [taskId, newTaskSpec] as [string, TaskSpec];\r\n      })\r\n      .sort(taskOrderComparer)\r\n  );\r\n  if (newTasks !== undefined) {\r\n    graphSpec.tasks = newTasks;\r\n  }\r\n  componentSpec = {\r\n    ...componentSpec,\r\n    implementation: { ...componentSpec.implementation, graph: graphSpec },\r\n  };\r\n\r\n  componentSpec = {\r\n    ...componentSpec,\r\n    metadata: {\r\n      ...componentSpec.metadata,\r\n      annotations: {\r\n        ...componentSpec.metadata?.annotations,\r\n        [SDK_ANNOTATION_KEY]: SDK_ANNOTATION_VALUE\r\n      }\r\n    }\r\n  }\r\n\r\n  // Reordering the attributes and removing the undefined ones\r\n  const rebuildComponentSpec = ({\r\n    name,\r\n    description,\r\n    metadata,\r\n    inputs,\r\n    outputs,\r\n    implementation,\r\n    ...rest\r\n  }: ComponentSpec): ComponentSpec => ({\r\n    ...(name && { name: name }),\r\n    ...(description && { description: description }),\r\n    ...(metadata && { metadata: metadata }),\r\n    ...(inputs && { inputs: inputs }),\r\n    ...(outputs && { outputs: outputs }),\r\n    implementation: implementation,\r\n    ...rest,\r\n  });\r\n  componentSpec = rebuildComponentSpec(componentSpec);\r\n\r\n  return componentSpec;\r\n};\r\n\r\nexport interface GraphComponentSpecFlowProps\r\n  extends Omit<ReactFlowProps, \"elements\"> {\r\n  componentSpec: ComponentSpec,\r\n  setComponentSpec: (componentSpec: ComponentSpec) => void,\r\n}\r\n\r\nconst nodeTypes = {\r\n  task: ComponentTaskNode,\r\n};\r\n\r\nconst GraphComponentSpecFlow = ({\r\n  children,\r\n  componentSpec = { implementation: { graph: { tasks: {} } } },\r\n  setComponentSpec,\r\n  ...rest\r\n}: GraphComponentSpecFlowProps) => {\r\n  const [reactFlowInstance, setReactFlowInstance] = useState<OnLoadParams>();\r\n\r\n  if (! ('graph' in componentSpec.implementation)) {\r\n    // Only graph components are supported\r\n    return <></>;\r\n  }\r\n  let graphSpec = componentSpec.implementation.graph;\r\n\r\n  const nodes = Object.entries(graphSpec.tasks).map<Node<ComponentTaskNodeProps>>(\r\n    ([taskId, taskSpec]) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (taskSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = taskSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n\r\n      return {\r\n        id: taskId,\r\n        data: {\r\n          taskSpec: taskSpec,\r\n          taskId: taskId,\r\n          setArguments: (args) => setTaskArguments(taskId, args),\r\n        },\r\n        position: position,\r\n        type: \"task\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const inputNodes = (componentSpec.inputs ?? []).map<Node>(\r\n    (inputSpec) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (inputSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = inputSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n      return {\r\n        id: inputSpec.name,\r\n        data: { label: inputSpec.name },\r\n        position: position,\r\n        type: \"input\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const outputNodes = (componentSpec.outputs ?? []).map<Node>(\r\n    (outputSpec) => {\r\n      let position: XYPosition = { x: 0, y: 0 };\r\n      if (outputSpec.annotations !== undefined) {\r\n        try {\r\n          const layoutAnnotation = outputSpec.annotations[\r\n            \"editor.position\"\r\n          ] as string;\r\n          const decodedPosition = JSON.parse(layoutAnnotation);\r\n          position = { x: decodedPosition[\"x\"], y: decodedPosition[\"y\"] };\r\n        } catch (err) {}\r\n      }\r\n      return {\r\n        id: outputSpec.name,\r\n        data: { label: outputSpec.name },\r\n        position: position,\r\n        type: \"output\",\r\n      };\r\n    }\r\n  );\r\n\r\n  const edges: Edge[] = Object.entries(graphSpec.tasks).flatMap(\r\n    ([taskId, taskSpec]) => {\r\n      return Object.entries(taskSpec.arguments ?? {}).flatMap(\r\n        ([inputName, argument]) => {\r\n          if (typeof argument === \"string\") {\r\n            return [];\r\n          }\r\n          if (\"taskOutput\" in argument) {\r\n            const taskOutput = argument.taskOutput;\r\n            const edge: Edge = {\r\n              id: `${taskOutput.taskId}_${taskOutput.outputName}-${taskId}_${inputName}`,\r\n              source: taskOutput.taskId,\r\n              sourceHandle: `output_${taskOutput.outputName}`,\r\n              target: taskId,\r\n              targetHandle: `input_${inputName}`,\r\n              arrowHeadType: ArrowHeadType.ArrowClosed,\r\n            };\r\n            return [edge];\r\n          } else if (\"graphInput\" in argument) {\r\n            const graphInput = argument.graphInput;\r\n            const edge: Edge = {\r\n              id: `Input_${graphInput.inputName}-${taskId}_${inputName}`,\r\n              source: graphInput.inputName,\r\n              //sourceHandle: undefined,\r\n              //sourceHandle: \"Input\",\r\n              sourceHandle: null,\r\n              target: taskId,\r\n              targetHandle: `input_${inputName}`,\r\n              arrowHeadType: ArrowHeadType.ArrowClosed,\r\n            };\r\n            return [edge];\r\n          } else {\r\n            console.error(\"Impossible task input argument kind: \", argument);\r\n            return [];\r\n          }\r\n        }\r\n      );\r\n    }\r\n  );\r\n\r\n  const outputEdges: Edge[] = Object.entries(graphSpec.outputValues ?? {}).map(\r\n    ([outputName, argument]) => {\r\n      const taskOutput = argument.taskOutput;\r\n      const edge: Edge = {\r\n        id: `${taskOutput.taskId}_${taskOutput.outputName}-Output_${outputName}`,\r\n        source: taskOutput.taskId,\r\n        sourceHandle: `output_${taskOutput.outputName}`,\r\n        target: outputName,\r\n        //targetHandle: undefined,\r\n        //targetHandle: \"Output\",\r\n        targetHandle: null,\r\n        arrowHeadType: ArrowHeadType.ArrowClosed,\r\n      };\r\n      return edge;\r\n    }\r\n  );\r\n\r\n  const elements = (nodes as Elements).concat(inputNodes).concat(outputNodes).concat(edges).concat(outputEdges);\r\n  \r\n  const replaceComponentSpec = (newComponentSpec: ComponentSpec) => {\r\n    componentSpec = newComponentSpec;\r\n    setComponentSpec(newComponentSpec);\r\n  };\r\n\r\n  const replaceGraphSpec = (newGraphSpec: GraphSpec) => {\r\n    graphSpec = newGraphSpec;\r\n    replaceComponentSpec({ ...componentSpec, implementation: { graph: graphSpec } });\r\n  };\r\n\r\n  const setTaskArguments = (\r\n    taskId: string,\r\n    taskArguments?: Record<string, ArgumentType>,\r\n  ) => {\r\n    let newGraphSpec: GraphSpec = {\r\n      ...graphSpec,\r\n      tasks: { ...graphSpec.tasks },\r\n    };\r\n    newGraphSpec.tasks[taskId] = {\r\n      ...graphSpec.tasks[taskId],\r\n      arguments: taskArguments,\r\n    };\r\n    replaceGraphSpec(newGraphSpec);\r\n  };\r\n\r\n  const setTaskArgument = (\r\n    taskId: string,\r\n    inputName: string,\r\n    argument?: ArgumentType\r\n  ) => {\r\n    const oldTaskSpec = graphSpec.tasks[taskId];\r\n    const oldTaskSpecArguments = oldTaskSpec.arguments;\r\n    let newTaskSpecArguments: Record<string, ArgumentType> = {\r\n      ...oldTaskSpecArguments,\r\n    };\r\n    if (argument === undefined) {\r\n      delete newTaskSpecArguments[inputName];\r\n    } else {\r\n      newTaskSpecArguments[inputName] = argument;\r\n    }\r\n    setTaskArguments(taskId, newTaskSpecArguments);\r\n  };\r\n\r\n  const removeTaskArgument = (taskId: string, inputName: string) =>\r\n    setTaskArgument(taskId, inputName, undefined);\r\n\r\n  const setGraphOutputValue = (\r\n    outputName: string,\r\n    outputValue?: TaskOutputArgument\r\n  ) => {\r\n    let newGraphOutputValues = { ...graphSpec.outputValues };\r\n    if (outputValue === undefined) {\r\n      delete newGraphOutputValues[outputName];\r\n    } else {\r\n      newGraphOutputValues[outputName] = outputValue;\r\n    }\r\n    graphSpec = { ...graphSpec, outputValues: newGraphOutputValues };\r\n    replaceGraphSpec(graphSpec);\r\n  };\r\n\r\n  const removeGraphOutputValue = (outputName: string) =>\r\n    setGraphOutputValue(outputName);\r\n\r\n  const addConnection = (connection: Connection | Edge) => {\r\n    if (connection.source === null || connection.target === null) {\r\n      console.error(\r\n        \"addConnection called with missing source or target: \",\r\n        connection\r\n      );\r\n      return;\r\n    }\r\n\r\n    const targetTaskInputName = connection.targetHandle?.replace(/^input_/, \"\");\r\n    const sourceTaskOutputName = connection.sourceHandle?.replace(/^output_/, \"\");\r\n\r\n    if (sourceTaskOutputName !== undefined) {\r\n      // Source is task output\r\n      const taskOutputArgument: TaskOutputArgument = {\r\n        taskOutput: {\r\n          taskId: connection.source,\r\n          outputName: sourceTaskOutputName,\r\n        },\r\n      };\r\n\r\n      if (targetTaskInputName !== undefined) {\r\n        // Target is task input\r\n        setTaskArgument(\r\n          connection.target,\r\n          targetTaskInputName,\r\n          taskOutputArgument\r\n        );\r\n      } else {\r\n        // Target is graph output\r\n        setGraphOutputValue(connection.target, taskOutputArgument);\r\n        // TODO: Perhaps propagate type information\r\n      }\r\n    } else {\r\n      // Source is graph input\r\n      const graphInputName = connection.source;\r\n      const graphInputArgument: GraphInputArgument = {\r\n        graphInput: {\r\n          inputName: graphInputName,\r\n        },\r\n      };\r\n      if (targetTaskInputName !== undefined) {\r\n        // Target is task input\r\n        setTaskArgument(\r\n          connection.target,\r\n          targetTaskInputName,\r\n          graphInputArgument\r\n        );\r\n        // TODO: Perhaps propagate type information\r\n      } else {\r\n        // Target is graph output\r\n        console.error(\r\n          \"addConnection: Cannot directly connect graph input to graph output: \",\r\n          connection\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  const onConnect = (params: Connection | Edge) => {\r\n    addConnection(params);\r\n  };\r\n\r\n  const removeEdge = (edge: Edge) => {\r\n    const inputName = edge.targetHandle?.replace(/^input_/, \"\");\r\n\r\n    if (inputName !== undefined) {\r\n      removeTaskArgument(edge.target, inputName);\r\n    } else {\r\n      removeGraphOutputValue(edge.target);\r\n    }\r\n  };\r\n\r\n  const removeComponentInput = (inputName: string) => {\r\n    // Removing the outcoming edges\r\n    for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n      for (const [inputName, argument] of Object.entries(\r\n        taskSpec.arguments ?? {}\r\n      )) {\r\n        if (typeof argument !== \"string\" && \"graphInput\" in argument) {\r\n          if (argument.graphInput.inputName === inputName) {\r\n            removeTaskArgument(taskId, inputName);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Not checking the sources of graph outputs, since they cannot be directly connected to the graph inputs\r\n\r\n    // Removing the input itself\r\n    const newInputs = (componentSpec.inputs ?? []).filter(\r\n      (inputSpec) => inputSpec.name !== inputName\r\n    );\r\n    componentSpec = { ...componentSpec, inputs: newInputs };\r\n    replaceComponentSpec(componentSpec);\r\n  };\r\n\r\n  const removeComponentOutput = (outputName: string) => {\r\n    removeGraphOutputValue(outputName);\r\n    // Removing the output itself\r\n    const newOutputs = (componentSpec.outputs ?? []).filter(\r\n      (outputSpec) => outputSpec.name !== outputName\r\n    );\r\n    componentSpec = { ...componentSpec, outputs: newOutputs };\r\n    replaceComponentSpec(componentSpec);\r\n  };\r\n\r\n  const removeTask = (taskId: string) => {\r\n    // Removing the outcoming edges\r\n    for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n      for (const [inputName, argument] of Object.entries(\r\n        taskSpec.arguments ?? {}\r\n      )) {\r\n        if (typeof argument !== \"string\" && \"taskOutput\" in argument) {\r\n          if (argument.taskOutput.taskId === taskId) {\r\n            removeTaskArgument(taskId, inputName);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Removing outcoming edges that go to graph outputs.\r\n    // ? Should we delete the outputs themselves\r\n    const newGraphOutputValues = Object.fromEntries(\r\n      Object.entries(graphSpec.outputValues ?? {}).filter(\r\n        ([_, argument]) => argument.taskOutput.taskId !== taskId\r\n      )\r\n    );\r\n    graphSpec = { ...graphSpec, outputValues: newGraphOutputValues };\r\n\r\n    // Removing the task\r\n    let newGraphSpec: GraphSpec = {\r\n      ...graphSpec,\r\n      tasks: { ...graphSpec.tasks },\r\n    };\r\n    delete newGraphSpec.tasks[taskId];\r\n    replaceGraphSpec(newGraphSpec);\r\n  };\r\n\r\n  const removeNode = (node: Node) => {\r\n    // TODO: Use global constants for node types\r\n    if (node.type === \"input\") {\r\n      const inputName = node.id;\r\n      removeComponentInput(inputName);\r\n    } else if (node.type === \"output\") {\r\n      const outputName = node.id;\r\n      removeComponentOutput(outputName);\r\n    } else if (node.type === \"task\") {\r\n      const taskId = node.id;\r\n      removeTask(taskId);\r\n    } else {\r\n      console.log(\"removeNode: Unexpected note type: \", node);\r\n    }\r\n  };\r\n\r\n  const onElementsRemove = (elementsToRemove: Elements) => {\r\n    for (const element of elementsToRemove) {\r\n      if (isEdge(element)) {\r\n        removeEdge(element);\r\n      }\r\n    }\r\n    for (const element of elementsToRemove) {\r\n      if (isNode(element)) {\r\n        removeNode(element);\r\n      }\r\n    }\r\n  };\r\n\r\n  const onEdgeUpdate = (oldEdge: Edge, newConnection: Connection) => {\r\n    removeEdge(oldEdge);\r\n    addConnection(newConnection);\r\n  };\r\n\r\n  const onLoad = (_reactFlowInstance: OnLoadParams) =>\r\n    setReactFlowInstance(_reactFlowInstance);\r\n\r\n  const onDragOver = (event: DragEvent) => {\r\n    event.preventDefault();\r\n    event.dataTransfer.dropEffect = \"move\";\r\n  };\r\n\r\n  const makeNameUniqueByAddingIndex = (name: string, existingNames: Set<string>): ElementId => {\r\n    let finalName = name;\r\n    let index = 1;\r\n    while (existingNames.has(finalName)) {\r\n      index++;\r\n      finalName = name + \" \" + index.toString();\r\n    }\r\n    return finalName;\r\n  };\r\n\r\n  const getUniqueInputName = (name: string = \"Input\") => {\r\n    return makeNameUniqueByAddingIndex(\r\n      name,\r\n      new Set(componentSpec.inputs?.map((inputSpec) => inputSpec.name))\r\n    );\r\n  };\r\n\r\n  const getUniqueOutputName = (name: string = \"Output\") => {\r\n    return makeNameUniqueByAddingIndex(\r\n      name,\r\n      new Set(componentSpec.outputs?.map((outputSpec) => outputSpec.name))\r\n    );\r\n  };\r\n\r\n  const getUniqueTaskName = (name: string = \"Task\") => {\r\n    return makeNameUniqueByAddingIndex(\r\n      name,\r\n      new Set(Object.keys(graphSpec.tasks))\r\n    );\r\n  };\r\n\r\n  const onDrop = (event: DragEvent) => {\r\n    event.preventDefault();\r\n\r\n    if (reactFlowInstance) {\r\n      const droppedData = event.dataTransfer.getData(\"application/reactflow\");\r\n      if (droppedData === \"\") {\r\n        return;\r\n      }\r\n      const droppedDataObject = JSON.parse(droppedData);\r\n      const nodeType = Object.keys(droppedDataObject)[0];\r\n      const nodeData = droppedDataObject[nodeType];\r\n      \r\n      // Correcting the position using the drag point location information\r\n      let dragOffsetX = 0;\r\n      let dragOffsetY = 0;\r\n      const dragStartOffsetData = event.dataTransfer.getData(\"DragStart.offset\");\r\n      if (dragStartOffsetData !== \"\") {\r\n        const dragStartOffset = JSON.parse(dragStartOffsetData);\r\n        // Hack to work around Chrome's draggable anchor bug. TODO: Remove once Chrome is fixed\r\n        dragOffsetX = dragStartOffset.offsetX * 0.68 ?? 0;\r\n        dragOffsetY = dragStartOffset.offsetY * 0.64 ?? 0;\r\n      }\r\n\r\n      // Node position. Offsets should be included in projection, so that they snap to the grid.\r\n      // Otherwise the dropped nodes will be out of phase with the rest of the nodes even when snapping.\r\n      let position = reactFlowInstance.project({\r\n        x: event.clientX - dragOffsetX,\r\n        y: event.clientY - dragOffsetY,\r\n      });\r\n\r\n      const nodePosition = { x: position.x, y: position.y };\r\n      const positionAnnotations = {\r\n        \"editor.position\": JSON.stringify(nodePosition),\r\n      }\r\n      if (nodeType === \"task\") {\r\n        const taskSpec = nodeData as TaskSpec;\r\n        const mergedAnnotations = {\r\n          ...taskSpec.annotations,\r\n          ...positionAnnotations,\r\n        };\r\n        taskSpec.annotations = mergedAnnotations;\r\n        const taskSpecWithAnnotation: TaskSpec = {\r\n          ...taskSpec,\r\n          annotations: mergedAnnotations,\r\n        };\r\n        const taskId = getUniqueTaskName(taskSpec.componentRef.spec?.name ?? \"Task\");\r\n        graphSpec = { ...graphSpec, tasks: { ...graphSpec.tasks } };\r\n        graphSpec.tasks[taskId] = taskSpecWithAnnotation;\r\n        replaceGraphSpec(graphSpec);\r\n      } else if (nodeType === \"input\") {\r\n        const inputId = getUniqueInputName();\r\n        const inputSpec: InputSpec = {\r\n          name: inputId,\r\n          annotations: positionAnnotations,\r\n        };\r\n        const inputs = (componentSpec.inputs ?? []).concat([inputSpec]);\r\n        componentSpec = { ...componentSpec, inputs: inputs };\r\n        replaceComponentSpec(componentSpec);\r\n      } else if (nodeType === \"output\") {\r\n        const outputId = getUniqueOutputName();\r\n        const outputSpec: OutputSpec = {\r\n          name: outputId,\r\n          annotations: positionAnnotations,\r\n        };\r\n        const outputs = (componentSpec.outputs ?? []).concat([outputSpec]);\r\n        componentSpec = { ...componentSpec, outputs: outputs };\r\n        replaceComponentSpec(componentSpec);\r\n      }\r\n    }\r\n  };\r\n\r\n  return (\r\n    <ReactFlow\r\n      {...rest}\r\n      elements={elements}\r\n      nodeTypes={nodeTypes}\r\n      onConnect={onConnect}\r\n      onDragOver={onDragOver}\r\n      onDrop={onDrop}\r\n      onEdgeUpdate={onEdgeUpdate}\r\n      onElementsRemove={onElementsRemove}\r\n      onLoad={onLoad}\r\n    >\r\n      {children}\r\n    </ReactFlow>\r\n  );\r\n};\r\n\r\nexport default GraphComponentSpecFlow;\r\n","import yaml from \"js-yaml\";\r\nimport localForage from \"localforage\";\r\nimport { ComponentSpec, ComponentReference } from \"./componentSpec\";\r\n\r\n// const COMPONENT_FILE_NAME_SUFFIX = \"component.yaml\";\r\n// const COMPONENT_FILE_MAX_SIZE = 100000;\r\nconst SEARCH_CACHE_NAME = \"https://api.github.com/search\";\r\nconst BLOB_CACHE_NAME = \"raw.githubusercontent.com/.../component.yaml\";\r\n\r\n// IndexedDB: DB and table names\r\nconst DB_NAME = \"components\";\r\nconst HASH_TO_CONTENT_DB_TABLE_NAME = \"hash_to_data\";\r\nconst HASH_TO_COMPONENT_NAME_DB_TABLE_NAME = \"hash_to_component_name\";\r\nconst URL_TO_HASH_DB_TABLE_NAME = \"url_to_hash\";\r\nconst HASH_TO_URL_DB_TABLE_NAME = \"hash_to_url\";\r\nconst URL_PROCESSING_VERSION_TABLE_NAME = \"url_version\";\r\nconst CURRENT_URL_PROCESSING_VERSION = 1;\r\nconst BAD_HASHES_TABLE_NAME = \"bad_hashes\";\r\n\r\n\r\nexport const httpGetWithCache = async (\r\n  urlOrRequest: string | RequestInfo,\r\n  cacheName: string,\r\n  updateIfInCache: boolean = false\r\n): Promise<Response> => {\r\n  const cache = await caches.open(cacheName);\r\n  const response = await cache.match(urlOrRequest);\r\n  if (response !== undefined) {\r\n    if (updateIfInCache) {\r\n      cache.add(urlOrRequest);\r\n    }\r\n    return response;\r\n  }\r\n  await cache.add(urlOrRequest);\r\n  const response2 = await cache.match(urlOrRequest);\r\n  if (response2 === undefined) {\r\n    return Promise.reject(\"Added object to cache, but could not find it\");\r\n  }\r\n  return response2;\r\n};\r\n\r\n\r\nexport const searchGitHubCodeWithCache = async (\r\n  query: string,\r\n  page = 1,\r\n  sort = \"indexed\",\r\n  order = \"desc\",\r\n): Promise<any> => {\r\n  // TODO: Paging\r\n  const encodedQuery = encodeURIComponent(query);\r\n  const encodedSort = encodeURIComponent(sort);\r\n  const encodedOrder = encodeURIComponent(order);\r\n  const searchUrl = `https://api.github.com/search/code?q=${encodedQuery}&sort=${encodedSort}&order=${encodedOrder}&per_page=100&page=${page}`;\r\n  const response = await httpGetWithCache(searchUrl, SEARCH_CACHE_NAME, true);\r\n  return response.json();\r\n};\r\n\r\n\r\nconst githubHtmlUrlToDownloadUrl = (htmlUrl: string): string => {\r\n  // https://github.com/               kubeflow/pipelines/blob/24bc9162a56c2fe3c50947d655ef280f71ba058f/components/gcp/dataflow/launch_flex_template/component.yaml\r\n  // https://raw.githubusercontent.com/kubeflow/pipelines     /24bc9162a56c2fe3c50947d655ef280f71ba058f/components/gcp/dataflow/launch_flex_template/component.yaml\r\n  return htmlUrl\r\n    .replace(\"https://github.com/\", \"https://raw.githubusercontent.com/\")\r\n    .replace(\"/blob/\", \"/\");\r\n};\r\n\r\n\r\ntype UrlAndHash = {\r\n  url: string;\r\n  hash: string;\r\n};\r\n\r\n\r\nexport async function * getComponentUrlsAndHashes(\r\n  users = [\"kubeflow\", \"Ark-kun\"]\r\n) {\r\n  let urlsAndHashes: UrlAndHash[] = [];\r\n  const query =\r\n    \"filename:component.yaml \" + users.map((user) => \"user:\" + user).join(\" \");\r\n  for (let page = 1; page < 100; page++) {\r\n    const searchResults = await searchGitHubCodeWithCache(query, page);\r\n    // \"total_count\": 512,\r\n    // \"incomplete_results\": false,\r\n    // \"items\": [\r\n    const items: any[] = searchResults.items;\r\n    if (items.length === 0) {\r\n      break;\r\n    }\r\n    for (let item of items) {\r\n      yield { url: githubHtmlUrlToDownloadUrl(item.html_url), hash: item.sha as string };\r\n    }\r\n    await new Promise( resolve => setTimeout(resolve, (60 * 1000 / 10) * (1 + 0.1)));\r\n  }\r\n  return urlsAndHashes;\r\n};\r\n\r\n\r\nexport const cacheComponentCandidateBlobs = async (\r\n  users = [\"kubeflow\", \"Ark-kun\"]\r\n): Promise<any[]> => {\r\n  let urlsAndHashes: UrlAndHash[] = [];\r\n  let urls = [];\r\n  for await (const urlAndHash of getComponentUrlsAndHashes(users)) {\r\n    urlsAndHashes.push(urlAndHash);\r\n    urls.push(urlAndHash.url);\r\n  }\r\n  const cache = await caches.open(BLOB_CACHE_NAME);\r\n  await cache.addAll(urls);\r\n  return urlsAndHashes;\r\n};\r\n\r\nexport const downloadComponentDataWithCache = async (url: string) => {\r\n  const response = await httpGetWithCache(url, BLOB_CACHE_NAME)\r\n  const data = await response.blob();\r\n  const componentText = await data.text();\r\n  // TODO: Validate the data\r\n  const componentSpec = yaml.load(componentText) as ComponentSpec;\r\n  return componentSpec;\r\n}\r\n\r\nexport const cacheAllComponents = async (users = [\"kubeflow\", \"Ark-kun\"]) => {\r\n  console.debug(\"Starting cacheAllComponents\");\r\n  const urlsAndHashesIterator = getComponentUrlsAndHashes(users);\r\n\r\n  // const cache = await caches.open(BLOB_CACHE_NAME);\r\n  const urlToHashDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_TO_HASH_DB_TABLE_NAME,\r\n  });\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  const hashToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  const urlProcessingVersionDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: URL_PROCESSING_VERSION_TABLE_NAME,\r\n  });\r\n  const badHashesDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: BAD_HASHES_TABLE_NAME,\r\n  });\r\n  for await (const item of urlsAndHashesIterator) {\r\n    const hash = item.hash.toLowerCase();\r\n    const htmlUrl = item.url;\r\n    const badHashReason = await badHashesDb.getItem<string>(hash);\r\n    if (badHashReason !== null) {\r\n      console.debug(`Skipping url ${htmlUrl} with hash ${hash} due to error: \"${badHashReason}\"`);\r\n      continue;\r\n    }\r\n    try {\r\n      const downloadUrl: string = githubHtmlUrlToDownloadUrl(htmlUrl);\r\n      if (!downloadUrl.endsWith(\"component.yaml\")) {\r\n        console.debug(`Skipping url ${downloadUrl} since it does not end with \"component.yaml\"`);\r\n        continue;\r\n      }\r\n      // Sanity check\r\n      const cachedHash = await urlToHashDb.getItem<string>(downloadUrl);\r\n      if (cachedHash !== null && cachedHash !== hash) {\r\n        console.error(\r\n          `Component cache is broken. Stored hash for ${downloadUrl}: ${cachedHash} != ${hash}.`\r\n        );\r\n      }\r\n      // Check whether the processing is complete\r\n      const urlVersion = await urlProcessingVersionDb.getItem<string>(\r\n        downloadUrl\r\n      );\r\n\r\n      if (\r\n        cachedHash !== null && // Not sure we should check this, but it improves the sanity\r\n        urlVersion !== null &&\r\n        Number.parseInt(urlVersion) >= CURRENT_URL_PROCESSING_VERSION\r\n      ) {\r\n        continue;\r\n      }\r\n\r\n      console.debug(`Processing new component candidate: ${downloadUrl}.`);\r\n      const response = await httpGetWithCache(downloadUrl, BLOB_CACHE_NAME);\r\n      let componentSpec: ComponentSpec;\r\n      let componentText: string;\r\n      try {\r\n        const data = await response.blob();\r\n        componentText = await data.text();\r\n        // TODO: Validate the data\r\n        componentSpec = yaml.load(componentText) as ComponentSpec;\r\n      } catch(err) {\r\n        badHashesDb.setItem(hash, err.name + \": \" + err.message);\r\n        continue;\r\n      }\r\n      if (componentSpec.implementation === undefined) {\r\n        badHashesDb.setItem(hash, 'Component lacks the \"impelmentation\" section.');\r\n        continue;\r\n      }\r\n\r\n      // Blobs are cumbersome (need await to get text) - store text instead\r\n      // await hashToContentDb.setItem(hash, data);\r\n      await hashToContentDb.setItem(hash, componentText);\r\n\r\n      // Only adding hash -> URL once\r\n      const urlForHash = await hashToUrlDb.getItem<string>(hash);\r\n      if (urlForHash === null) {\r\n        await hashToUrlDb.setItem(hash, downloadUrl);\r\n      }\r\n\r\n      // Only storing names when they exist\r\n      if (componentSpec.name) {\r\n        await hashToComponentNameDb.setItem(hash, componentSpec.name);\r\n      }\r\n\r\n      await urlToHashDb.setItem(downloadUrl, hash);\r\n\r\n      // Marking the processing as completed\r\n      await urlProcessingVersionDb.setItem(\r\n        downloadUrl,\r\n        CURRENT_URL_PROCESSING_VERSION\r\n      );\r\n    } catch (err) {\r\n      console.error(\r\n        `Error when processing component candidate ${htmlUrl} Error: ${err}.`\r\n      );\r\n    }\r\n  }\r\n  console.debug(\"Finished cacheAllComponents\");\r\n};\r\n\r\n\r\nexport const getAllComponentsAsRefs = async (users = [\"kubeflow\", \"Ark-kun\"]) => {\r\n  // Perhaps use urlProcessingVersionDb as source of truth. Hmm. It is URL-based\r\n  const hashToUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_URL_DB_TABLE_NAME,\r\n  });\r\n  const hashToContentDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: HASH_TO_CONTENT_DB_TABLE_NAME,\r\n  });\r\n  let hashToComponentRef = new Map<string, ComponentReference>();\r\n\r\n  const cachePromise = cacheAllComponents(users);\r\n  if ((await hashToContentDb.length()) === 0) {\r\n    await cachePromise;\r\n  }\r\n\r\n  // !!! Iterating using hashToContentDb.iterate<string, void> causes all values to be `[object Blob]`\r\n  //await hashToContentDb.iterate<Blob, void>(\r\n  await hashToContentDb.iterate<string, void>(\r\n    // !!! async processor causes only 1 item to be processed since it returns Promise instead of undefined.\r\n    //async (componentData, hash, iterationNumber) => {\r\n    (componentText, hash, iterationNumber) => {\r\n      //const componentText = await componentData.text();\r\n      try {\r\n        const componentSpec = yaml.load(componentText) as ComponentSpec;\r\n        hashToComponentRef.set(hash, {\r\n          spec: componentSpec,\r\n        });\r\n      } catch (err) {\r\n        console.error(\r\n          `Error when parsing cached component. Hash: ${hash}. Error: ${err}. Component text: ${componentText}`\r\n        );\r\n      }\r\n    }\r\n  );\r\n  await hashToUrlDb.iterate<string, void>((url, hash, iterationNumber) => {\r\n    let componentRef = hashToComponentRef.get(hash);\r\n    if (componentRef === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with url ${url} and hash ${hash} has no content in the DB.`\r\n      );\r\n    } else {\r\n      componentRef.url = url;\r\n    }\r\n  });\r\n  let componentRefs: ComponentReference[] = [];\r\n  // TODO: Improve the iteration onve TypeScript propertly supports it\r\n  hashToComponentRef.forEach((componentRef, hash) => {\r\n    if (componentRef.url === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with hash ${hash} has content, but no URL in the DB.`\r\n      );\r\n    } else {\r\n      componentRefs.push(componentRef);\r\n    }\r\n  });\r\n  return componentRefs;\r\n};\r\n\r\n\r\nexport const searchComponentsByName = async (name: string, users = [\"kubeflow\", \"Ark-kun\"]) => {\r\n  const componentRefs = await getAllComponentsAsRefs(users);\r\n  return componentRefs.filter((ref) => ref.spec?.name?.toLowerCase().includes(name.toLowerCase()) ?? false);\r\n};\r\n","// Manually converted from https://github.com/kubeflow/pipelines/blob/master/api/v2alpha1/pipeline_spec.proto\r\n\r\n// The spec of a pipeline job.\r\nexport interface PipelineJob {\r\n  // Name of the job.\r\n  name?: string;\r\n\r\n  // User friendly display name\r\n  displayName?: string;\r\n  // Definition of the pipeline that is being executed.\r\n  pipelineSpec: PipelineSpec;\r\n\r\n  // The labels with user-defined metadata to organize PipelineJob.\r\n  labels?: { [k: string]: string };\r\n\r\n  // Runtime config of the pipeline.\r\n  runtimeConfig: RuntimeConfig;\r\n}\r\n\r\n// The runtime config of a PipelineJob.\r\nexport interface RuntimeConfig {\r\n  // The runtime parameters of the PipelineJob. The parameters will be\r\n  // passed into [PipelineJob.pipeline_spec][] to replace the placeholders\r\n  // at runtime.\r\n  parameters?: { [k: string]: MlmdValue };\r\n\r\n  // A path in a Cloud Storage bucket which will be treated as the root\r\n  // output directory of the pipeline. It is used by the system to\r\n  // generate the paths of output artifacts.\r\n  // This is a GCP-specific optimization.\r\n  gcsOutputDirectory: string;\r\n}\r\n\r\n// The spec of a pipeline.\r\nexport interface PipelineSpec {\r\n  // The metadata of the pipeline.\r\n  pipelineInfo?: PipelineInfo;\r\n\r\n  // The deployment config of the pipeline.\r\n  // The deployment config can be extended to provide platform specific configs.\r\n  deploymentSpec: PipelineDeploymentConfig;\r\n\r\n  // The version of the sdk, which compiles the spec.\r\n  sdkVersion?: string;\r\n\r\n  // The version of the schema.\r\n  schemaVersion?: string;\r\n\r\n  // The map of name to definition of all components used in this pipeline.\r\n  components: { [k: string]: ComponentSpec };\r\n\r\n  // The definition of the main pipeline.  Execution of the pipeline is\r\n  // completed upon the completion of this component.\r\n  root: ComponentSpec;\r\n}\r\n\r\n// Definition of a component.\r\nexport interface ComponentSpec {\r\n  // Definition of the input parameters and artifacts of the component.\r\n  inputDefinitions?: ComponentInputsSpec;\r\n\r\n  // Definition of the output parameters and artifacts of the component.\r\n  outputDefinitions?: ComponentOutputsSpec;\r\n\r\n  // Either a DAG or a single execution.\r\n  //oneof implementation {\r\n  dag?: DagSpec;\r\n  executorLabel?: string;\r\n  //}\r\n}\r\n\r\n// A DAG contains multiple tasks.\r\nexport interface DagSpec {\r\n  // The tasks inside the dag.\r\n  tasks: { [k: string]: PipelineTaskSpec };\r\n\r\n  // Defines how the outputs of the dag are linked to the sub tasks.\r\n  outputs?: DagOutputsSpec;\r\n}\r\n\r\n// Definition of the output artifacts and parameters of the DAG component.\r\nexport interface DagOutputsSpec {\r\n  // Name to the output artifact channel of the DAG.\r\n  artifacts?: { [k: string]: DagOutputArtifactSpec };\r\n\r\n  // The name to the output parameter.\r\n  parameters?: { [k: string]: DagOutputParameterSpec };\r\n}\r\n\r\n// Selects a defined output artifact from a sub task of the DAG.\r\nexport interface ArtifactSelectorSpec {\r\n  // The name of the sub task which produces the output that matches with\r\n  // the `output_artifact_key`.\r\n  producerSubtask: string;\r\n\r\n  // The key of [ComponentOutputsSpec.artifacts][] map of the producer task.\r\n  outputArtifactKey: string;\r\n}\r\n\r\n// Selects a list of output artifacts that will be aggregated to the single\r\n// output artifact channel of the DAG.\r\nexport interface DagOutputArtifactSpec {\r\n  // The selected artifacts will be aggregated as output as a single\r\n  // output channel of the DAG.\r\n  artifactSelectors: ArtifactSelectorSpec[];\r\n}\r\n\r\n// Selects a defined output parameter from a sub task of the DAG.\r\nexport interface ParameterSelectorSpec {\r\n  // The name of the sub task which produces the output that matches with\r\n  // the `output_parameter_key`.\r\n  producerSubtask: string;\r\n\r\n  // The key of [ComponentOutputsSpec.parameters][] map of the producer task.\r\n  outputParameterKey: string;\r\n}\r\n\r\n// Aggregate output parameters from sub tasks into a list object.\r\nexport interface ParameterSelectorsSpec {\r\n  parameterSelectors: ParameterSelectorSpec[];\r\n}\r\n\r\n// Aggregates output parameters from sub tasks into a map object.\r\nexport interface MapParameterSelectorsSpec {\r\n  mappedParameters: { [k: string]: ParameterSelectorSpec };\r\n}\r\n\r\n// We support four ways to fan-in output parameters from sub tasks to the DAG\r\n// parent task.\r\n// 1. Directly expose a single output parameter from a sub task,\r\n// 2. (Conditional flow) Expose a list of output from multiple tasks\r\n// (some might be skipped) but allows only one of the output being generated.\r\n// 3. Expose a list of outputs from multiple tasks (e.g. iterator flow).\r\n// 4. Expose the aggregation of output parameters as a name-value map.\r\nexport type DagOutputParameterSpec =\r\n  // Returns the sub-task parameter as a DAG parameter.  The selected\r\n  // parameter must have the same type as the DAG parameter type.\r\n  | { valueFromParameter: ParameterSelectorSpec }\r\n  // Returns one of the sub-task parameters as a DAG parameter. If there are\r\n  // multiple values are available to select, the DAG will fail. All the\r\n  // selected parameters must have the same type as the DAG parameter type.\r\n  | { valueFromOneof: ParameterSelectorsSpec };\r\n\r\n// Definition specification of the component input parameters and artifacts.\r\nexport interface ComponentInputsSpec {\r\n  // Name to artifact input.\r\n  artifacts?: { [k: string]: InputArtifactSpec };\r\n\r\n  // Name to parameter input.\r\n  parameters?: { [k: string]: InputParameterSpec };\r\n}\r\n\r\n// Definition of an artifact input.\r\nexport interface InputArtifactSpec {\r\n  artifactType: ArtifactTypeSchema;\r\n}\r\n\r\n// Definition of a parameter input.\r\nexport interface InputParameterSpec {\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// Definition specification of the component output parameters and artifacts.\r\nexport interface ComponentOutputsSpec {\r\n  // Name to artifact output.\r\n  artifacts?: { [k: string]: OutputArtifactSpec };\r\n\r\n  // Name to parameter output.\r\n  parameters?: { [k: string]: OutputParameterSpec };\r\n}\r\n\r\n// Definition of an artifact output.\r\nexport interface OutputArtifactSpec {\r\n  artifactType: ArtifactTypeSchema;\r\n\r\n  // Properties of the Artifact.\r\n  metadata?: { [k: string]: any };\r\n}\r\n\r\n// Definition of a parameter output.\r\nexport interface OutputParameterSpec {\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// The spec of task inputs.\r\n//export interface TaskInputsSpec {\r\nexport interface TaskArgumentsSpec {\r\n  // A map of input parameters which are small values, stored by the system and\r\n  // can be queriable.\r\n  parameters?: { [k: string]: ParameterArgumentSpec };\r\n  // A map of input artifacts.\r\n  artifacts?: { [k: string]: ArtifactArgumentSpec };\r\n}\r\n\r\n// The specification of a task input artifact.\r\n//export type InputArtifactSpec =\r\nexport type ArtifactArgumentSpec =\r\n  // Pass the input artifact from another task within the same parent\r\n  // component.\r\n  | { taskOutputArtifact: TaskOutputArtifactSpec }\r\n  // Pass the input artifact from parent component input artifact.\r\n  | { componentInputArtifact: string };\r\n\r\nexport interface TaskOutputArtifactSpec {\r\n  // The name of the upstream task which produces the output that matches\r\n  // with the `output_artifact_key`.\r\n  producerTask: string;\r\n\r\n  // The key of [TaskOutputsSpec.artifacts][] map of the producer task.\r\n  outputArtifactKey: string;\r\n}\r\n\r\n// Represents an input parameter. The value can be taken from an upstream\r\n// task's output parameter (if specifying `producer_task` and\r\n// `output_parameter_key`, or it can be a runtime value, which can either be\r\n// determined at compile-time, or from a pipeline parameter.\r\n//export interface InputParameterSpec {\r\nexport interface ParameterArgumentSpec {\r\n  //oneof kind {\r\n  // Output parameter from an upstream task.\r\n  taskOutputParameter?: TaskOutputParameterSpec;\r\n  // A constant value or runtime parameter.\r\n  runtimeValue?: ValueOrRuntimeParameter;\r\n  // Pass the input parameter from parent component input parameter.\r\n  componentInputParameter?: string;\r\n  // The final status of an uptream task.\r\n  taskFinalStatus?: TaskFinalStatus;\r\n  //}\r\n\r\n  // Selector expression of Common Expression Language (CEL)\r\n  // that applies to the parameter found from above kind.\r\n  //\r\n  // The expression is applied to the Value type\r\n  // [Value][].  For example,\r\n  // 'size(string_value)' will return the size of the Value.string_value.\r\n  //\r\n  // After applying the selection, the parameter will be returned as a\r\n  // [Value][].  The type of the Value is either deferred from the input\r\n  // definition in the corresponding\r\n  // [ComponentSpec.input_definitions.parameters][], or if not found,\r\n  // automatically deferred as either string value or double value.\r\n  //\r\n  // In addition to the builtin functions in CEL, The value.string_value can\r\n  // be treated as a json string and parsed to the [google.protobuf.Value][]\r\n  // proto message. Then, the CEL expression provided in this field will be\r\n  // used to get the requested field. For examples,\r\n  //  - if Value.string_value is a json array of \"[1.1, 2.2, 3.3]\",\r\n  //  'parseJson(string_value)[i]' will pass the ith parameter from the list\r\n  //  to the current task, or\r\n  //  - if the Value.string_value is a json map of \"{\"a\": 1.1, \"b\": 2.2,\r\n  //  \"c\": 3.3}, 'parseJson(string_value)[key]' will pass the map value from\r\n  //  the struct map to the current task.\r\n  //\r\n  // If unset, the value will be passed directly to the current task.\r\n  parameterExpressionSelector?: string;\r\n}\r\n\r\n// Represents an upstream task's output parameter.\r\nexport interface TaskOutputParameterSpec {\r\n  // The name of the upstream task which produces the output parameter that\r\n  // matches with the `output_parameter_key`.\r\n  producerTask: string;\r\n\r\n  // The key of [TaskOutputsSpec.parameters][] map of the producer task.\r\n  outputParameterKey: string;\r\n}\r\n\r\n// Represents an upstream task's final status. The field can only be set if\r\n// the schema version is `2.0.0`. The resolved input parameter will be a\r\n// json payload in string type.\r\nexport interface TaskFinalStatus {\r\n  // The name of the upsteram task where the final status is coming from.\r\n  producerTask: string;\r\n}\r\n\r\n// The spec of task outputs.\r\nexport interface TaskOutputsSpec {\r\n  // A map of output parameters which are small values, stored by the system and\r\n  // can be queriable. The output key is used\r\n  // by [TaskInputsSpec.InputParameterSpec][] of the downstream task to specify\r\n  // the data dependency. The same key will also be used by\r\n  // [ExecutorInput.Inputs][] to reference the output parameter.\r\n  parameters?: { [k: string]: OutputParameterSpec };\r\n  // A map of output artifacts. Keyed by output key. The output key is used\r\n  // by [TaskInputsSpec.InputArtifactSpec][] of the downstream task to specify\r\n  // the data dependency. The same key will also be used by\r\n  // [ExecutorInput.Inputs][] to reference the output artifact.\r\n  artifacts?: { [k: string]: OutputArtifactSpec };\r\n}\r\n\r\n// The specification of a task output artifact.\r\nexport interface OutputArtifactSpec {\r\n  // The type of the artifact.\r\n  artifactType: ArtifactTypeSchema;\r\n\r\n  // The properties of the artifact, which are determined either at\r\n  // compile-time, or at pipeline submission time through runtime parameters\r\n  properties?: { [k: string]: ValueOrRuntimeParameter };\r\n\r\n  // The custom properties of the artifact, which are determined either at\r\n  // compile-time, or at pipeline submission time through runtime parameters\r\n  customProperties?: { [k: string]: ValueOrRuntimeParameter };\r\n}\r\n\r\n// Specification for output parameters produced by the task.\r\nexport interface OutputParameterSpec {\r\n  // Required field. The type of the output parameter.\r\n  type: PrimitiveTypeEnum;\r\n}\r\n\r\n// Represent primitive types.\r\nexport enum PrimitiveTypeEnum {\r\n  PRIMITIVE_TYPE_UNSPECIFIED = \"PRIMITIVE_TYPE_UNSPECIFIED\",\r\n  INT = \"INT\",\r\n  DOUBLE = \"DOUBLE\",\r\n  STRING = \"STRING\",\r\n}\r\n\r\n// The spec of a pipeline task.\r\nexport interface PipelineTaskSpec {\r\n  // Basic info of a pipeline task.\r\n  taskInfo?: PipelineTaskInfo;\r\n\r\n  // Specification for task inputs which contains parameters and artifacts.\r\n  // <Alexey Volkov>: This should have been named: `arguments: TaskArguments`\r\n  inputs?: TaskArgumentsSpec;\r\n\r\n  // A list of names of upstream tasks that do not provide input\r\n  // artifacts for this task, but nonetheless whose completion this task depends\r\n  // on.\r\n  dependentTasks?: string[];\r\n\r\n  cachingOptions?: CachingOptions;\r\n\r\n  // Reference to a component.  Use this field to define either a DAG or an\r\n  // executor.\r\n  componentRef: ComponentRef;\r\n\r\n  // Trigger policy of the task.\r\n  triggerPolicy?: TriggerPolicy;\r\n\r\n  // Iterator supports fanning out the task into multiple sub-tasks based on the\r\n  // values of input artifact or parameter. The current task will become the\r\n  // parent of all the fan-out tasks. The output of the current task follows\r\n  // the following conventions:\r\n  // * Output artifacts with the same name of each iteration will be merged\r\n  //   into one output artifact channel of the parent iterator task.\r\n  // * Output parameters with the same name of each iteration will be merged\r\n  //   into a string output parameter with the same name with content being a\r\n  //   JSON array.\r\n  //\r\n  // For example, if an iterator starts two sub-tasks (t1 and t2) with the\r\n  // following outputs.\r\n  //\r\n  // t1.outputs.parameters = { 'p': 'v1' }\r\n  // t1.outputs.artifacts = { 'a': [a1] }\r\n  // t2.outputs.parameters = { 'p': 'v2' }\r\n  // t2.outputs.artifacts = { 'a': [a2] }\r\n  // parent_task.outputs.parameters = { 'p': '[\"v1\", \"v2\"]' }\r\n  // parent_task.outputs.aritfacts = { 'a': [a1, a2] }\r\n  //oneof iterator {\r\n  // Iterator to iterate over an artifact input.\r\n  artifactIterator?: ArtifactIteratorSpec;\r\n  // Iterator to iterate over a parameter input.\r\n  parameterIterator?: ParameterIteratorSpec;\r\n  //}\r\n}\r\n\r\nexport interface CachingOptions {\r\n  // Whether or not to enable cache for this task. Defaults to false.\r\n  enableCache: boolean;\r\n}\r\n\r\n// Trigger policy defines how the task gets triggered. If a task is not\r\n// triggered, it will run into SKIPPED state.\r\nexport interface TriggerPolicy {\r\n  // An expression which will be evaluated into a boolean value. True to\r\n  // trigger the task to run. The expression follows the language of\r\n  // [CEL Spec][https://github.com/google/cel-spec]. It can access the data\r\n  // from [ExecutorInput][] message of the task.\r\n  // For example:\r\n  // - `inputs.artifacts['model'][0].properties['accuracy']*100 > 90`\r\n  // - `inputs.parameters['type'] == 'foo' && inputs.parameters['num'] == 1`\r\n  condition: string;\r\n\r\n  // The trigger strategy of this task.  The `strategy` and `condition` are\r\n  // in logic \"AND\", as a task will only be tested for the `condition` when\r\n  // the `strategy` is meet.\r\n  // Unset or set to default value of TRIGGER_STATEGY_UNDEFINED behaves the\r\n  // same as ALL_UPSTREAM_TASKS_SUCCEEDED.\r\n  strategy: TriggerStrategy;\r\n}\r\n\r\n// An enum defines the trigger strategy of when the task will be ready to be\r\n// triggered.\r\n// ALL_UPSTREAM_TASKS_SUCCEEDED - all upstream tasks in succeeded state.\r\n// ALL_UPSTREAM_TASKS_COMPLETED - all upstream tasks in any final state.\r\n// (Note that CANCELLED is also a final state but job will not trigger new\r\n// tasks when job is in CANCELLING state, so that the task with the trigger\r\n// policy at ALL_UPSTREAM_TASKS_COMPLETED will not start when job\r\n// cancellation is in progress.)\r\nenum TriggerStrategy {\r\n  // Unspecified.  Behave the same as ALL_UPSTREAM_TASKS_SUCCEEDED.\r\n  TRIGGER_STRATEGY_UNSPECIFIED = \"TRIGGER_STRATEGY_UNSPECIFIED\",\r\n  // Specifies that all upstream tasks are in succeeded state.\r\n  ALL_UPSTREAM_TASKS_SUCCEEDED = \"ALL_UPSTREAM_TASKS_SUCCEEDED\",\r\n  // Specifies that all upstream tasks are in any final state.\r\n  ALL_UPSTREAM_TASKS_COMPLETED = \"ALL_UPSTREAM_TASKS_COMPLETED\",\r\n}\r\n\r\n// The spec of an artifact iterator. It supports fan-out a workflow from a list\r\n// of artifacts.\r\nexport interface ArtifactIteratorSpec {\r\n  // The items to iterate.\r\n  items: ArtifactItemsSpec;\r\n  // The name of the input artifact channel which has the artifact item from the\r\n  // [items][] collection.\r\n  itemInput: string;\r\n}\r\n// Specifies the name of the artifact channel which contains the collection of\r\n// items to iterate. The iterator will create a sub-task for each item of\r\n// the collection and pass the item as a new input artifact channel as\r\n// specified by [item_input][].\r\nexport interface ArtifactItemsSpec {\r\n  // The name of the input artifact.\r\n  inputArtifact: string;\r\n}\r\n\r\n// The spec of a parameter iterator. It supports fan-out a workflow from a\r\n// string parameter which contains a JSON array.\r\nexport interface ParameterIteratorSpec {\r\n  // The items to iterate.\r\n  items: ParameterItemsSpec;\r\n  // The name of the input parameter which has the item value from the\r\n  // [items][] collection.\r\n  itemInput: string;\r\n}\r\n\r\n// Specifies the spec to decribe the parameter items to iterate.\r\nexport type ParameterItemsSpec =\r\n  // Specifies where to get the collection of items to iterate. The iterator\r\n  // will create a sub-task for each item of the collection and pass the item\r\n  // as a new input parameter as specified by [item_input][].\r\n  // The raw JSON array.\r\n  | { raw: string }\r\n  // The name of the input parameter whose value has the items collection.\r\n  // The parameter must be in STRING type and its content can be parsed\r\n  // as a JSON array.\r\n  | { input_parameter: string };\r\n\r\nexport interface ComponentRef {\r\n  // The name of a component. Refer to the key of the\r\n  // [PipelineSpec.components][] map.\r\n  name: string;\r\n}\r\n\r\n// Basic info of a pipeline.\r\nexport interface PipelineInfo {\r\n  // Required field. The name of the pipeline.\r\n  // The name will be used to create or find pipeline context in MLMD.\r\n  name: string;\r\n}\r\n\r\n// The definition of a artifact type in MLMD.\r\nexport type ArtifactTypeSchema =\r\n  // The name of the type. The format of the title must be:\r\n  // `<namespace>.<title>.<version>`.\r\n  // Examples:\r\n  //  - `aiplatform.Model.v1`\r\n  //  - `acme.CustomModel.v2`\r\n  // When this field is set, the export type must be pre-registered in the MLMD\r\n  // store.\r\n  | { schemaTitle: string }\r\n\r\n  // Points to a YAML file stored on Google Cloud Storage describing the\r\n  // format.\r\n  | { schemaUri: string }\r\n\r\n  // Contains a raw YAML string, describing the format of\r\n  // the properties of the type.\r\n  | { instanceSchema: string };\r\n\r\n// The basic info of a task.\r\nexport interface PipelineTaskInfo {\r\n  // The unique name of the task within the pipeline definition. This name\r\n  // will be used in downstream tasks to indicate task and data dependencies.\r\n  // <Alexey Volkov>: This ^^^ does not seem to be true. This name seems to be used only as display name.\r\n  name: string;\r\n}\r\n\r\n// Definition for a value or reference to a runtime parameter. A\r\n// ValueOrRuntimeParameter instance can be either a field value that is\r\n// determined during compilation time, or a runtime parameter which will be\r\n// determined during runtime.\r\nexport type ValueOrRuntimeParameter =\r\n  // Constant value which is determined in compile time.\r\n  | { constantValue: MlmdValue }\r\n  // The runtime parameter refers to the parent component input parameter.\r\n  | { runtimeParameter: string };\r\n\r\nexport type MlmdValue =\r\n  | {\r\n      stringValue: string;\r\n    }\r\n  | {\r\n      intValue: number;\r\n    }\r\n  | {\r\n      doubleValue: number;\r\n    };\r\n\r\n// The definition of the deployment config of the pipeline. It contains the\r\n// the platform specific executor configs for KFP OSS.\r\nexport interface PipelineDeploymentConfig {\r\n  // Map from executor label to executor spec.\r\n  executors: { [k: string]: ExecutorSpec };\r\n}\r\n\r\n// The specification on a container invocation.\r\n// The string fields of the message support string based placeholder contract\r\n// defined in [ExecutorInput](). The output of the container follows the\r\n// contract of [ExecutorOutput]().\r\nexport interface PipelineContainerSpec {\r\n  // The image uri of the container.\r\n  image: string;\r\n  // The main entrypoint commands of the container to run. If not provided,\r\n  // fallback to use the entry point command defined in the container image.\r\n  command?: string[];\r\n  // The arguments to pass into the main entrypoint of the container.\r\n  args?: string[];\r\n\r\n  // The lifecycle hooks of the container executor.\r\n  // lifecycle: Lifecycle;\r\n\r\n  resources?: ResourceSpec;\r\n}\r\n\r\n// The specification on the resource requirements of a container execution.\r\n// This can include specification of vCPU, memory requirements, as well as\r\n// accelerator types and counts.\r\nexport interface ResourceSpec {\r\n  // The limit of the number of vCPU cores. This container execution needs\r\n  // at most cpu_limit vCPU to run.\r\n  cpuLimit: number;\r\n\r\n  // The memory limit in GB. This container execution needs at most\r\n  // memory_limit RAM to run.\r\n  memoryLimit: number;\r\n\r\n  accelerator: AcceleratorConfig;\r\n}\r\n\r\n// The specification of the executor.\r\nexport type ExecutorSpec =\r\n  // Starts a container.\r\n  { container: PipelineContainerSpec };\r\n// Import an artifact.\r\n//| { importer: ImporterSpec }\r\n// Resolves an existing artifact.\r\n//| { resolver: ResolverSpec }\r\n// Starts a Google Cloud AI Platform CustomJob.\r\n//| { custom_job: AIPlatformCustomJobSpec };\r\n\r\n// The specification on the accelerators being attached to this container.\r\nexport interface AcceleratorConfig {\r\n  // The type of accelerators.\r\n  type: string;\r\n  // The number of accelerators.\r\n  count: number;\r\n}\r\n\r\n// Missing: Lifecycle\r\n// Missing: ImporterSpec\r\n// Missing: ResolverSpec\r\n// Missing: RuntimeArtifact\r\n// Missing: ArtifactList\r\n// Missing: ExecutorInput\r\n// Missing: ExecutorOutput\r\n","import { ComponentSpec, ContainerImplementation, ImplementationType, StringOrPlaceholder, ArgumentType, TypeSpecType } from \"../componentSpec\";\r\n\r\nimport * as vertex from \"./vertexPipelineSpec\";\r\n\r\n// # How to handle I/O:\r\n// Rules (might have exceptions)\r\n// output = output artifact\r\n// inputValue => input parameter\r\n// inputPath => input artifact\r\n// # Fixing conflicts:\r\n// 1) Artifact (may only come from task output) is consumed as value.\r\n//   Solution 1) (implemented): Change input from parameter to artifact and use the input.artifact.value placeholder.\r\n//      Cons: The downstream component input definitions depend on arguments. (Some inputs are changed from parameter to artifact.)\r\n//   Solution 2): Add parameter output (with the same name as the artifact output) to the upstream component. The paths should be the same, so a single file will be treated as both parameter and output.\r\n//      Cons: The upstream component output definitions depend on downstream consumption style. (Although parameter outputs are added, not changed.)\r\n//   Solution 3): Insert a \"Downloader\" task between upstream and downstream.\r\n//      Cons: Extra container task\r\n// 2) Parameter (pipeline input or constant value) is consumed as artifact (as file).\r\n//   Solution 1): Insert a \"Uploader\" task to convert parameter to artifact.\r\n//      Cons: Extra container task\r\n\r\nconst sanitizePipelineInfoName = (pipelineContextName: string) => {\r\n    return pipelineContextName.toLowerCase().replace(/\\W/, '-')\r\n}\r\n\r\ntype ResolvedCommandLineAndArgs = {\r\n    command?: string[],\r\n    args?: string[],\r\n    inputsConsumedAsValue: Set<string>,\r\n    inputsConsumedAsPath: Set<string>,\r\n};\r\n\r\nconst resolveCommandLine = (componentSpec: ComponentSpec, taskArguments: Record<string, ArgumentType>): ResolvedCommandLineAndArgs => {\r\n    if (! ('container' in componentSpec.implementation)) {\r\n      throw Error(\"resolveCommandLine only supports container components\");\r\n    }\r\n    const containerSpec = componentSpec.implementation.container;\r\n\r\n    const inputsConsumedAsValue = new Set<string>();\r\n    const inputsConsumedAsPath = new Set<string>();\r\n    const convertArg = (arg: StringOrPlaceholder): string[] => {\r\n        if (typeof arg == \"string\") {\r\n            return [arg];\r\n        } else if ('inputValue' in arg) {\r\n            const inputName = arg.inputValue;\r\n            const argument = taskArguments[inputName];\r\n            if (argument !== undefined && typeof argument != \"string\" && \"taskOutput\" in argument) {\r\n                // ! Important details:\r\n                // In this branch, the argument comes from task output.\r\n                // All outputs are artifacts by default, so this argument is an artifact argument.\r\n                // We can either try to change the argument to parameter or make the input to be an artifact to solve the conflict.\r\n                // I choose to make the input to be artifact.\r\n                // Adding input name to inputsConsumedAsPath to make the input rendered as an artifact input.\r\n                inputsConsumedAsPath.add(inputName);\r\n                return [`{{$.inputs.artifacts['${inputName}'].value}}`];\r\n            } else {\r\n                inputsConsumedAsValue.add(inputName);\r\n                return [`{{$.inputs.parameters['${inputName}']}}`];\r\n            }\r\n        } else if ('inputPath' in arg) {\r\n            const inputName = arg.inputPath;\r\n            inputsConsumedAsPath.add(inputName);\r\n            return [`{{$.inputs.artifacts['${inputName}'].path}}`];\r\n        } else if ('outputPath' in arg) {\r\n            const outputName = arg.outputPath;\r\n            return [`{{$.outputs.artifacts['${outputName}'].path}}`];\r\n        } else if ('if' in arg) {\r\n            const [ifCond, ifThen, ifElse] = [arg.if.cond, arg.if.then, arg.if.else];\r\n            // TODO: Check false values, not just check for true\r\n            let condEvaluatesToTrue = false;\r\n            if (typeof ifCond === \"string\") {\r\n              condEvaluatesToTrue = ifCond.toLowerCase() === \"true\";\r\n            } else if (typeof ifCond === \"boolean\") {\r\n              condEvaluatesToTrue = ifCond;\r\n            } else if (\"isPresent\" in ifCond) {\r\n              const inputName = ifCond.isPresent;\r\n              condEvaluatesToTrue = inputName in taskArguments;\r\n            } else if (\"inputValue\" in ifCond) {\r\n              const inputName = ifCond.inputValue;\r\n              if (! (inputName in taskArguments)) {\r\n                condEvaluatesToTrue = false;\r\n              } else {\r\n                const taskArgument = taskArguments[inputName];\r\n                if (typeof taskArgument === \"string\") {\r\n                    condEvaluatesToTrue = taskArgument.toLowerCase() === \"true\";\r\n                } else {\r\n                    throw Error(\"Using runtime conditions in component command line placeholders is not supported yet.\")\r\n                }\r\n              }\r\n            } else {\r\n                throw Error(\"Unexpected contition kind: \" + ifCond);\r\n            }\r\n            const unresolvedArgs = condEvaluatesToTrue ? ifThen : ifElse;\r\n            if (unresolvedArgs === undefined) {\r\n                return [];\r\n            }\r\n            return unresolvedArgs.flatMap(convertArg);\r\n        } else if ('concat' in arg) {\r\n            const concatArgs = arg.concat;\r\n            return concatArgs.flatMap(convertArg);\r\n        } else {\r\n            throw Error(`Unknown kind of command-line argument: ${arg}`);\r\n        }\r\n    };\r\n\r\n    const result = {\r\n        command: containerSpec.command?.flatMap(convertArg),\r\n        args: containerSpec.args?.flatMap(convertArg),\r\n        inputsConsumedAsValue: inputsConsumedAsValue,\r\n        inputsConsumedAsPath: inputsConsumedAsPath,\r\n    };\r\n    return result;\r\n}\r\n\r\nfunction isContainerImplementation(implementationType: ImplementationType): implementationType is ContainerImplementation {\r\n    return 'container' in implementationType;\r\n}\r\n\r\nconst typeSpecToVertexPrimitiveTypeEnum = (typeSpec: TypeSpecType | undefined): vertex.PrimitiveTypeEnum => {\r\n    if (typeof typeSpec === \"string\") {\r\n        if ([\"integer\"].includes(typeSpec.toLowerCase())) {\r\n            return vertex.PrimitiveTypeEnum.INT;\r\n        }\r\n        if ([\"float\", \"double\"].includes(typeSpec.toLowerCase())) {\r\n            return vertex.PrimitiveTypeEnum.DOUBLE;\r\n        }\r\n    }\r\n    return vertex.PrimitiveTypeEnum.STRING;\r\n}\r\n\r\nconst typeSpecToVertexParameterSpec = (typeSpec: TypeSpecType | undefined): vertex.InputParameterSpec => {\r\n    return {\r\n        type: typeSpecToVertexPrimitiveTypeEnum(typeSpec)\r\n    }\r\n}\r\n\r\nconst typeSpecToVertexArtifactTypeSchema = (typeSpec: TypeSpecType | undefined): vertex.ArtifactTypeSchema => {\r\n    // TODO: Implement better mapping\r\n    const artifactTypeSchema = {\r\n        schemaTitle: \"system.Artifact\"\r\n    }\r\n    return artifactTypeSchema\r\n}\r\n\r\nconst typeSpecToVertexArtifactSpec = (typeSpec: TypeSpecType | undefined): vertex.InputArtifactSpec => {\r\n    return {\r\n        artifactType: typeSpecToVertexArtifactTypeSchema(typeSpec)\r\n    }\r\n}\r\n// const typeSpecToVertexArtifactType(typeSpec: TypeSpecType) => {\r\n//     return typeof typeSpec === \"string\" && [\"String\", \"Integer\", \"Float\", \"Double\", \"Boolean\", ]\r\n// }\r\n\r\nconst MAKE_ARTIFACT_COMPONENT_ID = \"_make_artifact\";\r\nconst MAKE_ARTIFACT_EXECUTOR_ID = \"_make_artifact\";\r\nconst MAKE_ARTIFACT_INPUT_NAME = \"parameter\";\r\nconst MAKE_ARTIFACT_OUTPUT_NAME = \"artifact\";\r\n\r\nconst makeArtifactTaskSpecTemplate: vertex.PipelineTaskSpec = {\r\n    componentRef: {\r\n        name: MAKE_ARTIFACT_COMPONENT_ID\r\n    },\r\n    taskInfo: {\r\n        name: \"Make artifact\"\r\n    },\r\n    inputs: {\r\n        parameters: {}\r\n    },\r\n    cachingOptions: {\r\n        enableCache: true\r\n    }\r\n};\r\n\r\nconst makeArtifactComponentSpec: vertex.ComponentSpec = {\r\n    executorLabel: MAKE_ARTIFACT_EXECUTOR_ID,\r\n    inputDefinitions: {\r\n        parameters: {\r\n            [MAKE_ARTIFACT_INPUT_NAME]: {\r\n                type: vertex.PrimitiveTypeEnum.STRING\r\n            }\r\n        }\r\n    },\r\n    outputDefinitions: {\r\n        artifacts: {\r\n            [MAKE_ARTIFACT_OUTPUT_NAME]: {\r\n                artifactType: {\r\n                    schemaTitle: \"system.Artifact\"\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nconst makeArtifactExecutorSpec: vertex.ExecutorSpec = {\r\n    container: {\r\n        image: \"alpine\",\r\n        command: [\r\n            \"sh\", \"-ec\", 'mkdir -p \"$(dirname \"$1\")\"; printf \"%s\" \"$0\" > \"$1\"',\r\n            `{{$.inputs.parameters['${MAKE_ARTIFACT_INPUT_NAME}']}}`,\r\n            `{{$.outputs.artifacts['${MAKE_ARTIFACT_OUTPUT_NAME}'].path}}`\r\n        ]\r\n    }\r\n}\r\n\r\nconst taskSpecToVertexTaskSpecComponentSpecAndExecutorSpec = (\r\n    componentSpec: ComponentSpec,\r\n    //passedArgumentNames: string[],\r\n    taskArguments: Record<string, ArgumentType>,\r\n    generateTaskID: (prefix: string) => string,\r\n    isRoot = false,\r\n) => {\r\n    // TODO: Investigate how to properly narrow the ImplementationTyppe union type\r\n    // Type guard!\r\n\r\n    if (!isContainerImplementation(componentSpec.implementation)) {\r\n        throw Error(\"Nested graph components are not supported yet\");\r\n    }\r\n    // Also works\r\n    // if ('container' in componentSpec.implementation) {\r\n    //     componentSpec.implementation\r\n    // }\r\n\r\n    const containerSpec = componentSpec.implementation.container;\r\n\r\n\r\n    const resolvedCommandLine = resolveCommandLine(componentSpec, taskArguments);\r\n\r\n    const vertexExecutorSpec: vertex.ExecutorSpec = {\r\n        container: {\r\n            image: containerSpec.image,\r\n            command: resolvedCommandLine.command,\r\n            args: resolvedCommandLine.args,\r\n        }\r\n    };\r\n\r\n    // resolvedCommandLine.inputsConsumedAsPath\r\n\r\n    const inputMap = new Map((componentSpec.inputs ?? []).map(inputSpec => [inputSpec.name, inputSpec]));\r\n\r\n    // Array.from(inputMap.keys()).filter(resolvedCommandLine.inputsConsumedAsValue.has)\r\n\r\n    const vertexComponentInputsSpec: vertex.ComponentInputsSpec = {\r\n      parameters: Object.fromEntries(\r\n        Array.from(resolvedCommandLine.inputsConsumedAsValue.values()).map(\r\n          (inputName) => [\r\n            inputName,\r\n            typeSpecToVertexParameterSpec(inputMap.get(inputName)?.type),\r\n          ]\r\n        )\r\n      ),\r\n      artifacts: Object.fromEntries(\r\n        Array.from(resolvedCommandLine.inputsConsumedAsPath.values()).map(\r\n          (inputName) => [\r\n            inputName,\r\n            typeSpecToVertexArtifactSpec(inputMap.get(inputName)?.type)\r\n          ]\r\n        )\r\n      ),\r\n    };\r\n\r\n    const vertexComponentOutputsSpec: vertex.ComponentOutputsSpec = {\r\n      parameters: {}, // Parameters will be added later as needed\r\n      artifacts: Object.fromEntries(\r\n        (componentSpec.outputs ?? []).map((outputSpec) => [\r\n          outputSpec.name,\r\n          typeSpecToVertexArtifactSpec(outputSpec.type)\r\n        ])\r\n      ),\r\n    };\r\n\r\n    const vertexComponentSpec: vertex.ComponentSpec = {\r\n        inputDefinitions: vertexComponentInputsSpec,\r\n        outputDefinitions: vertexComponentOutputsSpec,\r\n        // dag\r\n        executorLabel: \"<set later>\",\r\n    };\r\n\r\n    const vertexTaskParameterArguments: Record<string, vertex.ParameterArgumentSpec> = Object.fromEntries(Array.from(resolvedCommandLine.inputsConsumedAsValue.values()).map(inputName => [inputName, (inputName => {\r\n        // TODO: Check that this works\r\n        let taskArgument = taskArguments[inputName];\r\n        //if (! (inputName in taskArguments)) {\r\n        if (taskArgument === undefined) {\r\n            // Checking for default value\r\n            const inputSpec = inputMap.get(inputName);\r\n            if (inputSpec === undefined) {\r\n                throw Error(`Cannot happen: vertexTaskParameterArguments - inputMap.get(${inputName}) === undefined`)\r\n            }\r\n            if (inputSpec.default !== undefined) {\r\n                taskArgument = inputSpec.default;\r\n            } else {\r\n                if (inputSpec.optional === true) {\r\n                    // TODO: Decide what the behavior should be\r\n                    // throw Error(`Input \"${inputName}\" is optional, but command-line still uses it when when it's not present.`);\r\n                    console.error(`Input \"${inputName}\" is optional, but command-line still uses it when when it's not present.`);\r\n                    taskArgument = \"\";\r\n                } else {\r\n                    throw Error(`Argument was not provided for required input \"${inputName}\"`);\r\n                }\r\n            }\r\n        }\r\n        let result: vertex.ParameterArgumentSpec;\r\n        if (typeof taskArgument === \"string\" ) {\r\n            result = {\r\n                runtimeValue: {\r\n                    constantValue: {\r\n                        // TODO: Fix constant arguments for non-string inputs\r\n                        stringValue: taskArgument,\r\n                    }\r\n                }\r\n            };\r\n            return result;\r\n        } else if ('graphInput' in taskArgument) {\r\n            result = {\r\n                componentInputParameter: taskArgument.graphInput.inputName,\r\n            };\r\n            return result;\r\n        } else if ('taskOutput' in taskArgument) {\r\n            result = {\r\n                taskOutputParameter: {\r\n                    producerTask: taskArgument.taskOutput.taskId,\r\n                    outputParameterKey: taskArgument.taskOutput.outputName,\r\n                }\r\n            };\r\n            return result;\r\n        } else {\r\n            throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n        }\r\n    })(inputName)]));\r\n\r\n    let vertexMakeArtifactTaskSpecs: Record<string, vertex.PipelineTaskSpec> = {};\r\n\r\n    const vertexTaskArtifactArguments: Record<string, vertex.ArtifactArgumentSpec> = Object.fromEntries(Array.from(resolvedCommandLine.inputsConsumedAsPath.values()).map(inputName => [inputName, (inputName => {\r\n        // TODO: Check that this works\r\n        let taskArgument = taskArguments[inputName];\r\n        //if (! (inputName in taskArguments)) {\r\n        if (taskArgument === undefined) {\r\n            // Checking for default value\r\n            const inputSpec = inputMap.get(inputName);\r\n            if (inputSpec === undefined) {\r\n                throw Error(`Cannot happen: vertexTaskParameterArguments - inputMap.get(${inputName}) === undefined`)\r\n            }\r\n            if (inputSpec.default !== undefined) {\r\n                taskArgument = inputSpec.default;\r\n            } else {\r\n                if (inputSpec.optional === true) {\r\n                    // TODO: Decide what the behavior should be\r\n                    // throw Error(`Input \"${inputName}\" is optional, but command-line still uses it when when it's not present.`);\r\n                    console.error(`Input \"${inputName}\" is optional, but command-line still uses it when when it's not present.`);\r\n                    taskArgument = \"\";\r\n                } else {\r\n                    throw Error(`Argument was not provided for required input \"${inputName}\"`);\r\n                }\r\n            }\r\n        }\r\n        let result: vertex.ArtifactArgumentSpec;\r\n        if (typeof taskArgument === \"string\" ) {\r\n            const makeArtifactTaskId = generateTaskID(\"Make artifact\");\r\n            const makeArtifactTaskSpec: vertex.PipelineTaskSpec = {\r\n                ...makeArtifactTaskSpecTemplate,\r\n                inputs: {\r\n                    parameters: {\r\n                        [MAKE_ARTIFACT_INPUT_NAME]: {\r\n                            runtimeValue: {\r\n                                constantValue: {\r\n                                    stringValue: taskArgument\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            vertexMakeArtifactTaskSpecs[makeArtifactTaskId] = makeArtifactTaskSpec;\r\n            result = {\r\n                taskOutputArtifact: {\r\n                    producerTask: makeArtifactTaskId,\r\n                    outputArtifactKey: MAKE_ARTIFACT_OUTPUT_NAME\r\n                }\r\n            };\r\n            return result;\r\n        } else if ('graphInput' in taskArgument) {\r\n            // Workaround for root DAG where all inputs must be parameters\r\n            if (isRoot) {\r\n                // We only need one task for each pipeline input parameter\r\n                //const makeArtifactTaskId = generateTaskID(\"Make artifact\");\r\n                const makeArtifactTaskId = \"Make artifact for \" + taskArgument.graphInput.inputName;\r\n                const makeArtifactTaskSpec: vertex.PipelineTaskSpec = {\r\n                    ...makeArtifactTaskSpecTemplate,\r\n                    inputs: {\r\n                        parameters: {\r\n                            [MAKE_ARTIFACT_INPUT_NAME]: {\r\n                                componentInputParameter: taskArgument.graphInput.inputName\r\n                            }\r\n                        }\r\n                    }\r\n                };\r\n                vertexMakeArtifactTaskSpecs[makeArtifactTaskId] = makeArtifactTaskSpec;\r\n                result = {\r\n                    taskOutputArtifact: {\r\n                        producerTask: makeArtifactTaskId,\r\n                        outputArtifactKey: MAKE_ARTIFACT_OUTPUT_NAME\r\n                    }\r\n                };\r\n            } else {\r\n                result = {\r\n                    componentInputArtifact: taskArgument.graphInput.inputName,\r\n                };\r\n            }\r\n            return result;\r\n        } else if ('taskOutput' in taskArgument) {\r\n            result = {\r\n                taskOutputArtifact: {\r\n                    producerTask: taskArgument.taskOutput.taskId,\r\n                    outputArtifactKey: taskArgument.taskOutput.outputName,\r\n                }\r\n            };\r\n            return result;\r\n        } else {\r\n            throw Error(`Unknown kind of task argument: \"${taskArgument}\"`);\r\n        }\r\n    })(inputName)]));\r\n    \r\n    const vertexTaskSpec: vertex.PipelineTaskSpec = {\r\n        taskInfo: {\r\n            // This is the task display name, not an ID\r\n            name: componentSpec.name ?? \"Component\",\r\n        },\r\n        inputs: {\r\n            parameters: vertexTaskParameterArguments,\r\n            artifacts: vertexTaskArtifactArguments,\r\n        },\r\n        // dependent_tasks: [],\r\n        cachingOptions: {\r\n            enableCache: true,\r\n        },\r\n        componentRef: {\r\n          name: \"<set later>\"\r\n        },\r\n        // triggerPolicy: {\r\n        //     condition: \"...\",\r\n        //     strategy: \"ALL_UPSTREAM_TASKS_SUCCEEDED\",\r\n        // },\r\n        // iterator: {\r\n        //     artifactIterator: {...},\r\n        //     parameterIterator: {...},\r\n        // },\r\n    }\r\n    \r\n    return { vertexTaskSpec, vertexComponentSpec, vertexExecutorSpec, vertexMakeArtifactTaskSpecs };\r\n}\r\n\r\nconst makeNameUniqueByAddingIndex = (name: string, existingNames: Set<string>): string => {\r\n    let finalName = name;\r\n    let index = 1;\r\n    while (existingNames.has(finalName)) {\r\n      index++;\r\n      finalName = name + \" \" + index.toString();\r\n    }\r\n    return finalName;\r\n  };\r\n\r\nconst graphComponentSpecToVertexPipelineSpec = (componentSpec: ComponentSpec, pipelineContextName = \"pipeline\") => {\r\n    if (! ('graph' in componentSpec.implementation)) {\r\n        throw Error(\"Only graph components are supported for now\")\r\n    }\r\n\r\n    // TODO: Fix case when these inputs are passed to tasks as artifacts\r\n    const vertexComponentInputsSpec = {\r\n        parameters: Object.fromEntries(\r\n          (componentSpec.inputs ?? []).map(\r\n            (inputSpec) => [inputSpec.name, typeSpecToVertexParameterSpec(inputSpec.type)]\r\n          )\r\n        ),\r\n        // Pipeline does not support artifact inputs\r\n        // artifacts: {},\r\n    };\r\n\r\n    const graphSpec = componentSpec.implementation.graph;\r\n\r\n    let vertexExecutors: Record<string, vertex.ExecutorSpec> = {};\r\n    let vertexComponents: Record<string, vertex.ComponentSpec> = {};\r\n    let vertexTasks: Record<string, vertex.PipelineTaskSpec> = {};\r\n\r\n    let usedTaskIds = new Set<string>(Object.keys(graphSpec.tasks));\r\n    const generateTaskId = (prefix: string) => {\r\n        const taskId = makeNameUniqueByAddingIndex(prefix, usedTaskIds);\r\n        usedTaskIds.add(taskId);\r\n        return taskId;\r\n    };\r\n\r\n    for (const [taskId, taskSpec] of Object.entries(graphSpec.tasks)) {\r\n        if (taskSpec.componentRef.spec === undefined) {\r\n            throw Error(`Task \"${taskId}\" does not have taskSpec.componentRef.spec.`)\r\n        }\r\n        try {\r\n            const { vertexTaskSpec, vertexComponentSpec, vertexExecutorSpec, vertexMakeArtifactTaskSpecs } = taskSpecToVertexTaskSpecComponentSpecAndExecutorSpec(taskSpec.componentRef.spec, taskSpec.arguments ?? {}, generateTaskId, true);\r\n            // task IDs are expected to be unique\r\n            // TODO: Fix  this to work for multi-dag pipelines where task IDs are not globally unique\r\n            const vertexExecutorId = taskId + \"_executor\";\r\n            const vertexComponentId = taskId + \"_component\";\r\n            const vertexTaskId = taskId; // + \"_task\";\r\n            usedTaskIds.add(vertexTaskId);\r\n            vertexExecutors[vertexExecutorId] = vertexExecutorSpec;\r\n            vertexComponentSpec.executorLabel = vertexExecutorId;\r\n            vertexComponents[vertexComponentId] = vertexComponentSpec;\r\n            vertexTaskSpec.componentRef.name = vertexComponentId;\r\n            // This is the task display name, not an ID. It's already set to the component name\r\n            //vertexTaskSpec.taskInfo.name = vertexTaskId;\r\n            vertexTasks[vertexTaskId] = vertexTaskSpec;\r\n            // Processing the additional MakeArtifact tasks\r\n            for (const [additionalTaskId, additionalTaskSpec] of Object.entries(vertexMakeArtifactTaskSpecs)) {\r\n                usedTaskIds.add(additionalTaskId);\r\n                vertexExecutors[MAKE_ARTIFACT_EXECUTOR_ID] = makeArtifactExecutorSpec;\r\n                vertexComponents[MAKE_ARTIFACT_COMPONENT_ID] = makeArtifactComponentSpec;\r\n                vertexTasks[additionalTaskId] = additionalTaskSpec;\r\n            }\r\n        } catch(err) {\r\n            throw Error(`Error compiling task ${taskId}: ` + err.toString());\r\n        }\r\n    }\r\n\r\n    const vertexPipelineSpec: vertex.PipelineSpec = {\r\n        pipelineInfo: {\r\n            name: sanitizePipelineInfoName(pipelineContextName)\r\n        },\r\n        sdkVersion: \"Cloud-Pipelines\",\r\n        schemaVersion: \"2.0.0\",\r\n        deploymentSpec: {\r\n            executors: vertexExecutors,\r\n        },\r\n        components: vertexComponents,\r\n        root: {\r\n          inputDefinitions: vertexComponentInputsSpec,\r\n          dag: {\r\n            tasks: vertexTasks,\r\n          }\r\n        },\r\n    };\r\n    return vertexPipelineSpec;\r\n};\r\n\r\nconst generateVertexPipelineJobFromGraphComponent = (\r\n  componentSpec: ComponentSpec,\r\n  gcsOutputDirectory: string,\r\n  pipelineArguments?: Map<string, string>,\r\n  pipelineContextName = \"pipeline\",\r\n) => {\r\n  // The pipelineContextName affects caching\r\n\r\n  // TODO: FIX: Do proper conversion of integers\r\n  //let convertedPipelineArguments = new Map<String, object>(Array.from(pipelineArguments.entries()).map((key, value) => [key, value]));\r\n  let convertedPipelineArguments: Record<string, any> = {};\r\n  if (pipelineArguments !== undefined) {\r\n    for (const [key, value] of Array.from(pipelineArguments.entries())) {\r\n      convertedPipelineArguments[key] = {\r\n        stringValue: value,\r\n        //intValue\r\n        //doubleValue\r\n      };\r\n    }\r\n  }\r\n\r\n  const pipelineSpec = graphComponentSpecToVertexPipelineSpec(componentSpec, pipelineContextName);\r\n\r\n  const pipelineJob: vertex.PipelineJob = {\r\n    // name: \"<>\",\r\n    // Does not show up in the UX\r\n    displayName: componentSpec.name ?? \"Pipeline\",\r\n    // labels: {},\r\n    runtimeConfig: {\r\n      parameters: convertedPipelineArguments,\r\n      gcsOutputDirectory: gcsOutputDirectory,\r\n    },\r\n    pipelineSpec: pipelineSpec,\r\n    // encryptionSpec: {},\r\n    // serviceAccount: \"<>\",\r\n    // network: {},\r\n  };\r\n  return pipelineJob;\r\n};\r\n\r\nexport { graphComponentSpecToVertexPipelineSpec, generateVertexPipelineJobFromGraphComponent };\r\n","import yaml from \"js-yaml\";\r\nimport localForage from \"localforage\";\r\n\r\nimport {\r\n  ComponentSpec,\r\n  ComponentReference,\r\n  isValidComponentSpec,\r\n} from \"./componentSpec\";\r\n\r\n// IndexedDB: DB and table names\r\nconst DB_NAME = \"components\";\r\nconst DIGEST_TO_DATA_DB_TABLE_NAME = \"digest_to_component_data\";\r\nconst DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME = \"digest_to_component_spec\";\r\nconst DIGEST_TO_COMPONENT_NAME_DB_TABLE_NAME = \"digest_to_component_name\";\r\nconst URL_TO_DIGEST_DB_TABLE_NAME = \"url_to_digest\";\r\nconst DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME = \"digest_to_canonical_url\";\r\n\r\nexport async function loadComponentFromUrl(\r\n  url: string\r\n): Promise<ComponentSpec> {\r\n  return fetch(url)\r\n    .then((response) => response.text())\r\n    .then((response) => yaml.load(response) as ComponentSpec);\r\n}\r\n\r\nconst calculateHashDigestHex = async (data: string | ArrayBuffer) => {\r\n  const dataBytes =\r\n    typeof data === \"string\" ? new TextEncoder().encode(data) : data;\r\n  const hashBuffer = await crypto.subtle.digest(\"SHA-256\", dataBytes);\r\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\r\n  const hashHex = hashArray\r\n    .map((b) => b.toString(16).padStart(2, \"0\"))\r\n    .join(\"\");\r\n  return hashHex;\r\n};\r\n\r\nconst storeComponentSpec = async (\r\n  digest: string,\r\n  componentSpec: ComponentSpec\r\n) => {\r\n  const digestToComponentSpecDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME,\r\n  });\r\n  const digestToComponentNameDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_NAME_DB_TABLE_NAME,\r\n  });\r\n  await digestToComponentSpecDb.setItem(digest, componentSpec);\r\n  if (componentSpec.name !== undefined) {\r\n    await digestToComponentNameDb.setItem(digest, componentSpec.name);\r\n  }\r\n};\r\n\r\nexport const storeComponentText = async (\r\n  componentText: string | ArrayBuffer\r\n) => {\r\n  const componentString =\r\n    typeof componentText === \"string\"\r\n      ? componentText\r\n      : new TextDecoder().decode(componentText);\r\n  const componentBytes =\r\n    typeof componentText === \"string\"\r\n      ? new TextEncoder().encode(componentText)\r\n      : componentText;\r\n\r\n  const loadedObj = yaml.load(componentString);\r\n  if (typeof loadedObj !== \"object\" || loadedObj === null) {\r\n    throw Error(`componentText is not a YAML-encoded object: ${loadedObj}`);\r\n  }\r\n  if (!isValidComponentSpec(loadedObj)) {\r\n    throw Error(\r\n      `componentText does not encode a valid pipeline component: ${loadedObj}`\r\n    );\r\n  }\r\n  const componentSpec: ComponentSpec = loadedObj;\r\n\r\n  const digest = await calculateHashDigestHex(componentBytes);\r\n  const digestToComponentTextDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_DATA_DB_TABLE_NAME,\r\n  });\r\n  await digestToComponentTextDb.setItem(digest, componentBytes);\r\n  await storeComponentSpec(digest, componentSpec);\r\n  const componentRef: ComponentReference = {\r\n    spec: componentSpec,\r\n    digest: digest,\r\n  };\r\n  return componentRef;\r\n};\r\n\r\nexport const downloadAndStoreComponent = async (url: string) => {\r\n  const response = await fetch(url);\r\n  const componentData = await response.arrayBuffer();\r\n  // TODO: Perhaps do not store the data again every time.\r\n  let componentRef = await storeComponentText(componentData);\r\n  componentRef.url = url;\r\n  const digest = componentRef.digest;\r\n  if (digest !== undefined) {\r\n    const urlToDigestDb = localForage.createInstance({\r\n      name: DB_NAME,\r\n      storeName: URL_TO_DIGEST_DB_TABLE_NAME,\r\n    });\r\n    const digestToCanonicalUrlDb = localForage.createInstance({\r\n      name: DB_NAME,\r\n      storeName: DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME,\r\n    });\r\n    // TODO: Perhaps do not store the data again every time.\r\n    await urlToDigestDb.setItem(url, digest);\r\n    const existingCanonicalUrl = await digestToCanonicalUrlDb.getItem<string>(digest);\r\n    if (existingCanonicalUrl === null) {\r\n      await digestToCanonicalUrlDb.setItem(digest, url);\r\n    } else {\r\n      if (url !== existingCanonicalUrl) {\r\n        console.debug(`The component with digest \"${digest}\" is being loaded from \"${url}\", but was already loaded from \"${existingCanonicalUrl}\" before.`);\r\n      }\r\n    }\r\n  }\r\n  return componentRef;\r\n};\r\n\r\nexport const getAllComponentsAsRefs = async () => {\r\n  const digestToComponentSpecDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_COMPONENT_SPEC_DB_TABLE_NAME,\r\n  });\r\n  const digestToCanonicalUrlDb = localForage.createInstance({\r\n    name: DB_NAME,\r\n    storeName: DIGEST_TO_CANONICAL_URL_DB_TABLE_NAME,\r\n  });\r\n\r\n  // TODO: Rewrite as async generator\r\n  let digestToComponentRef = new Map<string, ComponentReference>();\r\n  await digestToComponentSpecDb.iterate<ComponentSpec, void>(\r\n    (componentSpec, digest, iterationNumber) => {\r\n      const componentRef: ComponentReference = {\r\n        spec: componentSpec,\r\n        digest: digest,\r\n      }\r\n      digestToComponentRef.set(digest, componentRef);\r\n    }\r\n  );\r\n  await digestToCanonicalUrlDb.iterate<string, void>((url, digest, iterationNumber) => {\r\n    let componentRef = digestToComponentRef.get(digest);\r\n    if (componentRef === undefined) {\r\n      console.error(\r\n        `Component db corrupted: Component with url ${url} and digest ${digest} has no content in the DB.`\r\n      );\r\n    } else {\r\n      componentRef.url = url;\r\n    }\r\n  });\r\n\r\n  const componentRefs = Array.from(digestToComponentRef.values());\r\n  return componentRefs;\r\n};\r\n\r\nexport const searchComponentsByName = async (name: string) => {\r\n  const componentRefs = await getAllComponentsAsRefs();\r\n  return componentRefs.filter((ref) => ref.spec?.name?.toLowerCase().includes(name.toLowerCase()) ?? false);\r\n};\r\n","export type MySchema = ComponentSpec;\r\nexport type TypeSpecType =\r\n  | string\r\n  | {\r\n      [k: string]: TypeSpecType;\r\n    };\r\nexport interface InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the component input specification\r\n */\r\nexport interface InputSpec extends InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  default?: string;\r\n  optional?: boolean;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the component output specification\r\n */\r\nexport interface OutputSpec extends InputOutputSpec {\r\n  name: string;\r\n  type?: TypeSpecType;\r\n  description?: string;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by the input argument value.\r\n */\r\nexport interface InputValuePlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  inputValue: string;\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a local file path pointing to a file containing the input argument value.\r\n */\r\nexport interface InputPathPlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  inputPath: string;\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a local file path pointing to a file where the program should write its output data.\r\n */\r\nexport interface OutputPathPlaceholder {\r\n  /**\r\n   * Name of the output.\r\n   */\r\n  outputPath: string;\r\n}\r\nexport type StringOrPlaceholder =\r\n  | string\r\n  | InputValuePlaceholder\r\n  | InputPathPlaceholder\r\n  | OutputPathPlaceholder\r\n  | ConcatPlaceholder\r\n  | IfPlaceholder;\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by the concatenated values of its items.\r\n */\r\nexport interface ConcatPlaceholder {\r\n  /**\r\n   * Items to concatenate\r\n   */\r\n  concat: StringOrPlaceholder[];\r\n}\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a boolean value specifying whether the caller has passed an argument for the specified optional input.\r\n */\r\nexport interface IsPresentPlaceholder {\r\n  /**\r\n   * Name of the input.\r\n   */\r\n  isPresent: string;\r\n}\r\nexport type IfConditionArgumentType =\r\n  | IsPresentPlaceholder\r\n  | boolean\r\n  | string\r\n  | InputValuePlaceholder;\r\nexport type ListOfStringsOrPlaceholders = StringOrPlaceholder[];\r\n/**\r\n * Represents the command-line argument placeholder that will be replaced at run-time by a boolean value specifying whether the caller has passed an argument for the specified optional input.\r\n */\r\nexport interface IfPlaceholder {\r\n  if: {\r\n    cond: IfConditionArgumentType;\r\n    then: ListOfStringsOrPlaceholders;\r\n    else?: ListOfStringsOrPlaceholders;\r\n  };\r\n}\r\nexport interface ContainerSpec {\r\n  /**\r\n   * Docker image name.\r\n   */\r\n  image: string;\r\n  /**\r\n   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided.\r\n   */\r\n  command?: StringOrPlaceholder[];\r\n  /**\r\n   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided.\r\n   */\r\n  args?: StringOrPlaceholder[];\r\n  /**\r\n   * List of environment variables to set in the container.\r\n   */\r\n  env?: {\r\n    [k: string]: StringOrPlaceholder;\r\n  };\r\n}\r\n/**\r\n * Represents the container component implementation.\r\n */\r\nexport interface ContainerImplementation {\r\n  container: ContainerSpec;\r\n}\r\nexport type ImplementationType = ContainerImplementation | GraphImplementation;\r\nexport interface MetadataSpec {\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Component specification. Describes the metadata (name, description, source), the interface (inputs and outputs) and the implementation of the component.\r\n */\r\nexport interface ComponentSpec {\r\n  name?: string;\r\n  description?: string;\r\n  inputs?: InputSpec[];\r\n  outputs?: OutputSpec[];\r\n  implementation: ImplementationType;\r\n  metadata?: MetadataSpec;\r\n}\r\n/**\r\n * Component reference. Contains information that can be used to locate and load a component by name, digest or URL\r\n */\r\nexport interface ComponentReference {\r\n  name?: string;\r\n  digest?: string;\r\n  tag?: string;\r\n  url?: string;\r\n  spec?: ComponentSpec;\r\n}\r\n/**\r\n * Represents the component argument value that comes from the graph component input.\r\n */\r\nexport interface GraphInputArgument {\r\n  /**\r\n   * References the input of the graph/pipeline.\r\n   */\r\n  graphInput: {\r\n    inputName: string;\r\n    type?: TypeSpecType;\r\n  };\r\n}\r\n/**\r\n * Represents the component argument value that comes from the output of a sibling task.\r\n */\r\nexport interface TaskOutputArgument {\r\n  /**\r\n   * References the output of a sibling task.\r\n   */\r\n  taskOutput: {\r\n    taskId: string;\r\n    outputName: string;\r\n    type?: TypeSpecType;\r\n  };\r\n}\r\nexport type ArgumentType = string | GraphInputArgument | TaskOutputArgument;\r\n/**\r\n * Pair of operands for a binary operation.\r\n */\r\nexport interface TwoArgumentOperands {\r\n  op1: ArgumentType;\r\n  op2: ArgumentType;\r\n}\r\n/**\r\n * Pair of operands for a binary logical operation.\r\n */\r\nexport interface TwoLogicalOperands {\r\n  op1: PredicateType;\r\n  op2: PredicateType;\r\n}\r\n/**\r\n * Optional configuration that specifies how the task should be executed. Can be used to set some platform-specific options.\r\n */\r\nexport type PredicateType =\r\n  | {\r\n      \"==\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"!=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \">\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \">=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"<\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      \"<=\": TwoArgumentOperands;\r\n    }\r\n  | {\r\n      and: TwoLogicalOperands;\r\n    }\r\n  | {\r\n      or: TwoLogicalOperands;\r\n    }\r\n  | {\r\n      not: PredicateType;\r\n    };\r\n\r\n/**\r\n * Optional configuration that specifies how the task should be retried if it fails.\r\n */\r\nexport interface RetryStrategySpec {\r\n  maxRetries?: number;\r\n}\r\n/**\r\n * Optional configuration that specifies how the task execution may be skipped if the output data exist in cache.\r\n */\r\nexport interface CachingStrategySpec {\r\n  maxCacheStaleness?: string;\r\n}\r\n\r\nexport interface ExecutionOptionsSpec {\r\n  retryStrategy?: RetryStrategySpec;\r\n  cachingStrategy?: CachingStrategySpec;\r\n}\r\n/**\r\n * 'Task specification. Task is a configured component - a component supplied with arguments and other applied configuration changes.\r\n */\r\nexport interface TaskSpec {\r\n  componentRef: ComponentReference;\r\n  arguments?: {\r\n    [k: string]: ArgumentType;\r\n  };\r\n  isEnabled?: PredicateType;\r\n  executionOptions?: ExecutionOptionsSpec;\r\n  annotations?: {\r\n    [k: string]: unknown;\r\n  };\r\n}\r\n/**\r\n * Describes the graph component implementation. It represents a graph of component tasks connected to the upstream sources of data using the argument specifications. It also describes the sources of graph output values.\r\n */\r\nexport interface GraphSpec {\r\n  tasks: {\r\n    [k: string]: TaskSpec;\r\n  };\r\n  outputValues?: {\r\n    [k: string]: TaskOutputArgument;\r\n  };\r\n}\r\n/**\r\n * Represents the graph component implementation.\r\n */\r\nexport interface GraphImplementation {\r\n  graph: GraphSpec;\r\n}\r\n\r\n// Type guards\r\nexport const isValidComponentSpec = (obj: object): obj is ComponentSpec =>\r\n  \"implementation\" in obj;\r\n\r\nexport const isContainerImplementation = (implementation: ImplementationType): implementation is ContainerImplementation =>\r\n  \"container\" in implementation;\r\n\r\nexport const isGraphImplementation = (implementation: ImplementationType): implementation is GraphImplementation =>\r\n  \"graph\" in implementation;\r\n","import { useCallback, useState, DragEvent, useEffect } from \"react\";\r\nimport { useDropzone } from \"react-dropzone\";\r\nimport { getAllComponentsAsRefs, storeComponentText } from \"../componentStore\";\r\nimport { ComponentReference, TaskSpec } from \"../componentSpec\";\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData(\"application/reactflow\", JSON.stringify(nodeData));\r\n  event.dataTransfer.setData(\r\n    \"DragStart.offset\",\r\n    JSON.stringify({\r\n      offsetX: event.nativeEvent.offsetX,\r\n      offsetY: event.nativeEvent.offsetY,\r\n    })\r\n  );\r\n  event.dataTransfer.effectAllowed = \"move\";\r\n};\r\n\r\nconst UserComponentLibrary = () => {\r\n  const [errorMessage, setErrorMessage] = useState(\"\");\r\n  const [componentRefs, setComponentRefs] = useState<ComponentReference[]>([]);\r\n\r\n  useEffect(() => {\r\n    getAllComponentsAsRefs().then(setComponentRefs);\r\n  }, []);\r\n\r\n  const onDrop = useCallback((acceptedFiles: File[]) => {\r\n    console.debug(\"Dropped files: \", acceptedFiles);\r\n    acceptedFiles.forEach((file) => {\r\n      const reader = new FileReader();\r\n      reader.onabort = () => console.log(\"file reading was aborted\");\r\n      reader.onerror = () => console.log(\"file reading has failed\");\r\n      reader.onload = async () => {\r\n        console.log(\"Before1\");\r\n        const binaryStr = reader.result;\r\n        if (binaryStr === null || binaryStr === undefined) {\r\n          console.error(`Dropped file reader result was ${binaryStr}`);\r\n          return;\r\n        }\r\n        try {\r\n          const componentRef = await storeComponentText(binaryStr);\r\n          console.debug(\"storeComponentText succeeded\", componentRef);\r\n          setErrorMessage(\"\");\r\n          const allComponentRefs = await getAllComponentsAsRefs();\r\n          console.debug(allComponentRefs);\r\n          setComponentRefs(allComponentRefs);\r\n        } catch (err) {\r\n          setErrorMessage(\r\n            `Error parsing the dropped file as component: ${err.toString()}.`\r\n          );\r\n          console.error(\"Error parsing the dropped file as component\", err);\r\n        }\r\n      };\r\n      reader.readAsArrayBuffer(file);\r\n    });\r\n  }, []);\r\n  const { getRootProps, getInputProps, isDragActive } = useDropzone({ onDrop });\r\n\r\n  return (\r\n    <div>\r\n      <div {...getRootProps()}>\r\n        <input {...getInputProps()} />\r\n        <div\r\n          style={{ border: \"1px solid black\", padding: \"4px\", minHeight: \"3em\" }}\r\n        >\r\n          {isDragActive\r\n            ? \"Drop the files here ...\"\r\n            : errorMessage ||\r\n              \"Drag and drop component.yaml files or click to select files\"}\r\n        {componentRefs.map((componentRef) => (\r\n          <div\r\n            key={componentRef.digest}\r\n            title={componentRef.digest}\r\n            className=\"react-flow__node react-flow__node-task\"\r\n            draggable\r\n            onDragStart={(event: DragEvent) => {\r\n              const taskSpec: TaskSpec = {\r\n                componentRef: componentRef,\r\n              };\r\n              return onDragStart(event, { task: taskSpec });\r\n            }}\r\n          >\r\n            {componentRef.spec?.name ?? \"Component\"}\r\n          </div>\r\n        ))}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default UserComponentLibrary;\r\n","import { DragEvent } from 'react';\r\n\r\nimport ComponentLibrary from './ComponentLibrary'\r\nimport ComponentSearch from './ComponentSearch'\r\nimport GraphComponentExporter from './GraphComponentExporter'\r\nimport GoogleCloudSubmitter from './GoogleCloud'\r\nimport VertexAiExporter from './VertexAiExporter'\r\nimport { ComponentSpec } from '../componentSpec';\r\nimport { loadComponentFromUrl, XGBOOST_PIPELINE_URL, PYTORCH_PIPELINE_URL, TFX_PIPELINE_URL, DATA_PASSING_PIPELINE_URL } from './samplePipelines';\r\nimport GraphComponentLink from './GraphComponentLink';\r\nimport KubeflowPipelinesSubmitter from \"./KubeflowPipelines\";\r\nimport UserComponentLibrary from \"./UserComponentLibrary\";\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData('application/reactflow', JSON.stringify(nodeData));\r\n  event.dataTransfer.setData(\r\n    \"DragStart.offset\",\r\n    JSON.stringify({\r\n      offsetX: event.nativeEvent.offsetX,\r\n      offsetY: event.nativeEvent.offsetY,\r\n    })\r\n  );\r\n  event.dataTransfer.effectAllowed = 'move';\r\n};\r\n\r\nconst COMPONENT_LIBRARY = [\r\n  {\r\n    category: \"Quick start\",\r\n    componentUrls: [\r\n      // 'https://raw.githubusercontent.com/Ark-kun/pipelines/60a2612541ec08c6a85c237d2ec7525b12543a43/components/datasets/Chicago_Taxi_Trips/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/2463ecda532517462590d75e6e14a8af6b55869a/components/datasets/Chicago_Taxi_Trips/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/567c04c51ff00a1ee525b3458425b17adbe3df61/components/XGBoost/Train/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/567c04c51ff00a1ee525b3458425b17adbe3df61/components/XGBoost/Predict/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"Datasets\", componentUrls: [\r\n      // 'https://raw.githubusercontent.com/Ark-kun/pipelines/60a2612541ec08c6a85c237d2ec7525b12543a43/components/datasets/Chicago_Taxi_Trips/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/2463ecda532517462590d75e6e14a8af6b55869a/components/datasets/Chicago_Taxi_Trips/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"Data manipulation\",\r\n    componentUrls: [\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/6162d55998b176b50267d351241100bb0ee715bc/components/pandas/Transform_DataFrame/in_CSV_format/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"Upload/Download\",\r\n    componentUrls: [\r\n    'https://raw.githubusercontent.com/Ark-kun/pipelines/54ac9a6a7173aecbbb30a043b2077e790cac6953/components/web/Download/component.yaml',\r\n    'https://raw.githubusercontent.com/Ark-kun/pipelines/2dac60c400ad8767b452649d08f328dfaf230f96/components/google-cloud/storage/download/component.yaml',\r\n    'https://raw.githubusercontent.com/Ark-kun/pipelines/2dac60c400ad8767b452649d08f328dfaf230f96/components/google-cloud/storage/upload_to_unique_uri/component.yaml',\r\n    'https://raw.githubusercontent.com/Ark-kun/pipelines/2dac60c400ad8767b452649d08f328dfaf230f96/components/google-cloud/storage/upload_to_explicit_uri/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"XGBoost\",\r\n    componentUrls: [\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/567c04c51ff00a1ee525b3458425b17adbe3df61/components/XGBoost/Train/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/567c04c51ff00a1ee525b3458425b17adbe3df61/components/XGBoost/Predict/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"PyTorch\",\r\n    componentUrls: [\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/4e1facea1a270535b515a9e8cc59422d1ad76a9e/components/PyTorch/Create_fully_connected_network/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/603342c4b88fe2d69ff07682f702cd3601e883bb/components/PyTorch/Train_PyTorch_model/from_CSV/component.yaml',\r\n      'https://raw.githubusercontent.com/Ark-kun/pipelines/e011e4affa85542ef2b24d63fdac27f8d939bbee/components/PyTorch/Convert_to_OnnxModel_from_PyTorchScriptModule/component.yaml',\r\n    ]\r\n  },\r\n  {\r\n    category: \"TFX\",\r\n    componentUrls: [\r\n      'https://raw.githubusercontent.com/kubeflow/pipelines/9b0d47a226c61f96e1ebe7a8ba427df38f8734e1/components/deprecated/tfx/ExampleGen/CsvExampleGen/component.yaml',\r\n      'https://raw.githubusercontent.com/kubeflow/pipelines/9b0d47a226c61f96e1ebe7a8ba427df38f8734e1/components/deprecated/tfx/StatisticsGen/component.yaml',\r\n      'https://raw.githubusercontent.com/kubeflow/pipelines/9b0d47a226c61f96e1ebe7a8ba427df38f8734e1/components/deprecated/tfx/SchemaGen/component.yaml',\r\n      'https://raw.githubusercontent.com/kubeflow/pipelines/9b0d47a226c61f96e1ebe7a8ba427df38f8734e1/components/deprecated/tfx/ExampleValidator/component.yaml',\r\n      'https://raw.githubusercontent.com/kubeflow/pipelines/9b0d47a226c61f96e1ebe7a8ba427df38f8734e1/components/deprecated/tfx/Transform/component.yaml',\r\n      'https://raw.githubusercontent.com/kubeflow/pipelines/9b0d47a226c61f96e1ebe7a8ba427df38f8734e1/components/deprecated/tfx/Trainer/component.yaml',\r\n      'https://raw.githubusercontent.com/kubeflow/pipelines/9b0d47a226c61f96e1ebe7a8ba427df38f8734e1/components/deprecated/tfx/Evaluator/component.yaml',\r\n    ]\r\n  },\r\n];\r\n\r\ninterface SidebarProps {\r\n  componentSpec?: ComponentSpec,\r\n  setComponentSpec?: (componentSpec: ComponentSpec) => void,\r\n}\r\n\r\nconst Sidebar = ({\r\n  componentSpec,\r\n  setComponentSpec\r\n}: SidebarProps) => {\r\n  return (\r\n    <aside className=\"nodeList\">\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Save/Load pipeline</summary>\r\n        <button\r\n          type=\"button\"\r\n          onClick={(e) => {\r\n            loadComponentFromUrl(TFX_PIPELINE_URL).then(setComponentSpec)\r\n          }}\r\n        >\r\n          Load TFX pipeline\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          onClick={(e) => {\r\n            loadComponentFromUrl(XGBOOST_PIPELINE_URL).then(setComponentSpec)\r\n          }}\r\n        >\r\n          Load XGBoost pipeline\r\n        </button>\r\n        <button\r\n          type=\"button\"\r\n          onClick={(e) => {\r\n            loadComponentFromUrl(PYTORCH_PIPELINE_URL).then(setComponentSpec)\r\n          }}\r\n        >\r\n          Load PyTorch pipeline\r\n        </button>\r\n        <div>\r\n          Save as {componentSpec && <GraphComponentLink componentSpec={componentSpec}/>}\r\n        </div>\r\n      </details>\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Submit to Google Cloud</summary>\r\n        <GoogleCloudSubmitter componentSpec={componentSpec}/>\r\n      </details>\r\n      <h3>Drag components to the canvas:</h3>\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary><strong>Special</strong></summary>\r\n        <div className=\"react-flow__node react-flow__node-input\" onDragStart={(event: DragEvent) => onDragStart(event, { input: { label: \"Input\" } })} draggable>\r\n          Input\r\n        </div>\r\n        <div className=\"react-flow__node react-flow__node-output\" onDragStart={(event: DragEvent) => onDragStart(event, { output: { label: \"Output\" } })} draggable>\r\n          Output\r\n        </div>\r\n      </details>\r\n      <ComponentLibrary componentGroups={COMPONENT_LIBRARY}/>\r\n      <details style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>User components</summary>\r\n        <UserComponentLibrary/>\r\n      </details>\r\n      <details open style={{ border: \"1px solid #aaa\", borderRadius: \"4px\", padding: \"4px\" }}>\r\n        <summary style={{ borderWidth: \"1px\", padding: \"4px\", fontWeight: \"bold\" }}>Component search</summary>\r\n        <ComponentSearch />\r\n      </details>\r\n      <details>\r\n        <summary>Debug</summary>\r\n        {componentSpec && <GraphComponentExporter componentSpec={componentSpec}/>}\r\n        {componentSpec && <VertexAiExporter componentSpec={componentSpec}/>}\r\n        <button\r\n          type=\"button\"\r\n          onClick={(e) => {\r\n            loadComponentFromUrl(DATA_PASSING_PIPELINE_URL).then(setComponentSpec);\r\n          }}\r\n        >\r\n          Load Data Passing pipeline\r\n        </button>\r\n        {process?.env?.NODE_ENV === \"development\" ? (\r\n          <>\r\n            <UserComponentLibrary/>\r\n            <KubeflowPipelinesSubmitter componentSpec={componentSpec}/>\r\n          </>\r\n        ) : undefined}\r\n      </details>\r\n    </aside>\r\n  );\r\n};\r\n\r\nexport default Sidebar;\r\n","import { DragEvent, useEffect, useState } from 'react';\r\n\r\nimport {downloadComponentDataWithCache} from '../github'\r\nimport {ComponentSpec, TaskSpec} from '../componentSpec'\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData('application/reactflow', JSON.stringify(nodeData));\r\n  event.dataTransfer.setData(\r\n    \"DragStart.offset\",\r\n    JSON.stringify({\r\n      offsetX: event.nativeEvent.offsetX,\r\n      offsetY: event.nativeEvent.offsetY,\r\n    })\r\n  );\r\n  event.dataTransfer.effectAllowed = 'move';\r\n};\r\n\r\ntype ComponentGroup = {\r\n  category: string;\r\n  componentUrls: string[];\r\n};\r\n\r\nconst DraggableComponentRow = ({componentUrl}: {componentUrl: string}) => {\r\n  const [componentSpec, setComponentSpec] = useState<ComponentSpec | undefined>(undefined);\r\n  useEffect(() => {\r\n    downloadComponentDataWithCache(componentUrl).then(setComponentSpec);\r\n  }, [componentUrl]);\r\n\r\n  if (componentSpec === undefined) {\r\n    return <span>Loading...</span>\r\n  } else {\r\n    return (\r\n      <div\r\n        className=\"react-flow__node react-flow__node-task\"\r\n        draggable\r\n        onDragStart={(event: DragEvent) => {\r\n          const taskSpec: TaskSpec = {\r\n            componentRef: {\r\n              url: componentUrl,\r\n              spec: componentSpec,\r\n            },\r\n          };\r\n          return onDragStart(event, { task: taskSpec });\r\n        }}\r\n      >\r\n        {componentSpec.name}\r\n      </div>\r\n    );\r\n  }\r\n};\r\n\r\nconst ComponentGroupList = ({ componentGroups }: { componentGroups: ComponentGroup[] }) => {\r\n  return (\r\n    <>\r\n      {Array.from(componentGroups).map(\r\n        ({ category, componentUrls }, index) => (\r\n          <details key={category} open={index === 0} style={{ border: \"1px solid #aaa\", borderRadius: \"4px\" }}>\r\n            <summary style={{ borderWidth: \"1px\", padding: \"8px\" }}>\r\n              <strong>{category}</strong>\r\n            </summary>\r\n            {componentUrls.map((componentUrl) => (\r\n              <DraggableComponentRow key={componentUrl} componentUrl={componentUrl} />\r\n            ))}\r\n          </details>\r\n        )\r\n      )}\r\n    </>\r\n  );\r\n};\r\n\r\nconst ComponentLibrary = ({ componentGroups }: { componentGroups: ComponentGroup[] }) => {\r\n  return (\r\n    <details open>\r\n      <summary style={{ border: \"1px solid #aaa\", padding: \"4px\", borderRadius: \"4px\" }}>\r\n        <strong>Component library</strong>\r\n      </summary>\r\n      <div style={{ paddingLeft: \"10px\" }}>\r\n        <ComponentGroupList componentGroups={componentGroups}/>\r\n      </div>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default ComponentLibrary;\r\n","import React, { DragEvent } from \"react\";\r\nimport { useState } from \"react\";\r\nimport { ComponentReference, TaskSpec } from \"../componentSpec\";\r\nimport { searchComponentsByName } from \"../github\";\r\n\r\nconst onDragStart = (event: DragEvent, nodeData: object) => {\r\n  event.dataTransfer.setData(\"application/reactflow\", JSON.stringify(nodeData));\r\n  event.dataTransfer.effectAllowed = \"move\";\r\n};\r\n\r\nconst COMPONENT_ORGS = [\"kubeflow\", \"Ark-kun\"];\r\n\r\nconst SearchPanel = (props: any) => {\r\n  const [error, setError] = useState<string | undefined>(undefined);\r\n  const [firstTime, setFirstTime] = useState(true);\r\n  const [isLoaded, setIsLoaded] = useState(false);\r\n  const [query, setQuery] = useState(\"\");\r\n  const [items, setItems] = useState<ComponentReference[]>([]);\r\n\r\n  const onQueryChange = (e: any) => {\r\n    setQuery(e.target.value);\r\n  };\r\n\r\n  async function fetchData(query: string) {\r\n    searchComponentsByName(query, COMPONENT_ORGS).then(\r\n      (componentRefs) => {\r\n        setIsLoaded(true);\r\n        setItems(componentRefs);\r\n      },\r\n      (error) => {\r\n        setIsLoaded(true);\r\n        setError(error.message);\r\n      }\r\n    );\r\n  }\r\n\r\n  const onSubmit = (e: React.FormEvent<HTMLFormElement>) => {\r\n    e.preventDefault();\r\n    if (query !== \"\") {\r\n      setFirstTime(false);\r\n      fetchData(query);\r\n    }\r\n  };\r\n\r\n  let results = <span></span>;\r\n  if (firstTime) {\r\n    results = <div>Enter search query</div>;\r\n  } else if (error !== undefined) {\r\n    results = <div>Error: {error}</div>;\r\n  } else if (!firstTime && !isLoaded) {\r\n    results = <div>Searching...</div>;\r\n  } else if (items !== undefined) {\r\n    const componentElements = items.map((item) => (\r\n      <div\r\n        key={item.url}\r\n        title={item.url}\r\n        className=\"react-flow__node react-flow__node-task\"\r\n        draggable\r\n        onDragStart={(event: DragEvent) => {\r\n          const taskSpec: TaskSpec = {\r\n            componentRef: item,\r\n          };\r\n          return onDragStart(event, { task: taskSpec });\r\n        }}\r\n      >\r\n        {item.spec?.name}\r\n      </div>\r\n    ));\r\n    results = <>{componentElements}</>;\r\n  }\r\n  return (\r\n    <div className=\"nodeList\">\r\n      <form onSubmit={onSubmit}>\r\n        <input type=\"search\" placeholder=\"XGBoost\" onChange={onQueryChange} />\r\n        <input type=\"submit\" />\r\n      </form>\r\n      <div>{results}</div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SearchPanel;\r\n","import {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\nimport yaml from \"js-yaml\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { augmentComponentSpec } from './GraphComponentSpecFlow'\r\n\r\ninterface GraphComponentExporterProps {\r\n  componentSpec: ComponentSpec,\r\n}\r\n\r\nconst GraphComponentExporter = ({\r\n  componentSpec,\r\n}: GraphComponentExporterProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  let componentText = \"\";\r\n  try {\r\n    const graphComponent = augmentComponentSpec(componentSpec, nodes, false, true);\r\n    componentText = yaml.dump(graphComponent, { lineWidth: 10000 });\r\n  } catch(err) {\r\n    componentText = String(err);\r\n  }\r\n\r\n  const componentTextBlob = new Blob([componentText], { type: \"text/yaml\" }); // Or application/x-yaml (which leads to downloading)\r\n  const downloadLink = <a href={URL.createObjectURL(componentTextBlob)} download={\"component.yaml\"}>component.yaml</a>\r\n\r\n  return (\r\n    <details>\r\n      <summary>Graph {downloadLink}</summary>\r\n      <pre style={{overflow: \"auto\"}}>{componentText}</pre>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default GraphComponentExporter;\r\n","/* global gapi */\r\n\r\nimport { useState } from 'react';\r\n\r\nimport { ComponentSpec } from '../componentSpec';\r\nimport {generateVertexPipelineJobFromGraphComponent} from './vertexAiCompiler'\r\n\r\nconst LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY = \"GoogleCloudSubmitter/gcsOutputDirectory\";\r\nconst LOCAL_STORAGE_PROJECT_ID_KEY = \"GoogleCloudSubmitter/projectId\";\r\nconst LOCAL_STORAGE_REGION_KEY = \"GoogleCloudSubmitter/region\";\r\nconst LOCAL_STORAGE_PROJECT_IDS_KEY = \"GoogleCloudSubmitter/projectIds\";\r\n\r\nvar CLIENT_ID = '640001104961-2m8hs192tmd9f9nssbr5thr5o3uhmita.apps.googleusercontent.com';\r\nvar API_KEY = 'AIzaSyCDPTffgYGXoit-jKsj1_1WWbSxvU7aEdQ';\r\n     \r\nconst VERTEX_AI_PIPELINES_REGIONS = [\r\n  'us-central1',\r\n  'europe-west4',\r\n  'asia-east1',\r\n];\r\n\r\nconst VERTEX_AI_PIPELINES_DEFAULT_REGION = 'us-central1';\r\n\r\nconst authorizeGoogleCloudClient = async (\r\n  scopes: string[],\r\n  immediate = false, // Setting immediate to true prevents auth window showing every time. But it needs to be false the first time (when cookies are not set).\r\n  apiKey: string = API_KEY,\r\n  clientId: string = CLIENT_ID,\r\n) => {\r\n  return new Promise<GoogleApiOAuth2TokenObject>(\r\n    (resolve, reject) => {\r\n      gapi.client.setApiKey(apiKey);\r\n      gapi.auth.authorize(\r\n        {\r\n          client_id: clientId,\r\n          scope: scopes,\r\n          immediate: immediate,\r\n        },\r\n        (authResult) => {\r\n          // console.debug(\"authorizeGoogleCloudClient: called back\");\r\n          if (authResult === undefined) {\r\n            console.error(\"authorizeGoogleCloudClient failed\");\r\n            reject(\"gapi.auth.authorize result is undefined\");\r\n          } else if (authResult.error) {\r\n            console.error(\r\n              \"authorizeGoogleCloudClient failed\",\r\n              authResult.error\r\n            );\r\n            reject(authResult.error);\r\n          } else {\r\n            // console.debug(\"authorizeGoogleCloudClient: Success\");\r\n            // Working around the Google Auth bug: The request succeeds, but the returned token does not have the requested scopes.\r\n            // See https://github.com/google/google-api-javascript-client/issues/743\r\n            const receivedScopesString = (authResult as any).scope as string | undefined;\r\n            const receivedScopes = receivedScopesString?.split(\" \");\r\n            if (receivedScopes === undefined || !scopes.every((scope) => receivedScopes.includes(scope))) {\r\n              const errorMessage = `Authorization call succeeded, but the returned scopes are ${receivedScopesString}`;\r\n              console.error(errorMessage);\r\n              reject(errorMessage);\r\n            } else {\r\n              resolve(authResult);\r\n            }\r\n          }\r\n        }\r\n      );\r\n    }\r\n  );\r\n};\r\n\r\nconst ensureGoogleCloudAuthorizesScopes = async (scopes: string[]) => {\r\n  try {\r\n    // console.debug('Before ensureGoogleCloudAuthorizesScopes(immediate=true)');\r\n    await authorizeGoogleCloudClient(scopes, true);\r\n    // console.debug('After ensureGoogleCloudAuthorizesScopes(immediate=true)');\r\n  } catch (err) {\r\n    // console.error('ensureGoogleCloudAuthorizesScopes(immediate=true)', err);\r\n    try {\r\n      await authorizeGoogleCloudClient(scopes, false);\r\n    } catch (err) {\r\n      // console.error('ensureGoogleCloudAuthorizesScopes(immediate=false)', err);\r\n    }\r\n  }\r\n};\r\n\r\nconst cloudresourcemanagerListProjects = async (isAuthenticated = false) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: \"https://cloudresourcemanager.googleapis.com/v1/projects/\",\r\n  });\r\n  return response.result;\r\n}\r\n\r\nconst aiplatformCreatePipelineJob = async (projetId: string, region='us-central1', pipelineJob: Record<string, any>) => {\r\n  await ensureGoogleCloudAuthorizesScopes(\r\n    [\"https://www.googleapis.com/auth/cloud-platform\"]\r\n  );\r\n  const response = await gapi.client.request({\r\n    path: `https://${region}-aiplatform.googleapis.com/v1beta1/projects/${projetId}/locations/${region}/pipelineJobs`,\r\n    method: \"POST\",\r\n    body: JSON.stringify(pipelineJob),\r\n  });\r\n  return response.result;\r\n}\r\n\r\ninterface GoogleCloudSubmitterProps {\r\n  componentSpec?: ComponentSpec,\r\n};\r\n\r\nconst GoogleCloudSubmitter = ({\r\n  componentSpec,\r\n}: GoogleCloudSubmitterProps) => {\r\n  const [projects, setProjects] = useState<string[]>(\r\n    () => JSON.parse(window.localStorage?.getItem(LOCAL_STORAGE_PROJECT_IDS_KEY) ?? \"[]\")\r\n  );\r\n  const [project, setProject] = useState<string>(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_PROJECT_ID_KEY) ?? \"\"\r\n  ); // undefined causes error: https://reactjs.org/docs/forms.html#controlled-components https://stackoverflow.com/a/47012342\r\n  const [region, setRegion] = useState(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_REGION_KEY) ?? VERTEX_AI_PIPELINES_DEFAULT_REGION\r\n  );\r\n  const [error, setError] = useState(\"\");\r\n  const [gcsOutputDirectory, setGcsOutputDirectory] = useState(\r\n    () => window.localStorage?.getItem(LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY) ?? \"\"\r\n  );\r\n  const [pipelineJobWebUrl, setPipelineJobWebUrl] = useState(\"\");\r\n  const [compilationError, setCompilationError] = useState(\"\");\r\n\r\n  let vertexPipelineJobJson: string | undefined = undefined;\r\n  let vertexPipelineJob: Record<string, any> | undefined = undefined;\r\n\r\n  //useEffect(() => {\r\n  if (componentSpec !== undefined) {\r\n    try {\r\n      const defaultInputValues = new Map<string, string>(\r\n        (componentSpec.inputs ?? [])\r\n          .filter((inputSpec) => inputSpec.default !== undefined)\r\n          .map((inputSpec) => [inputSpec.name, inputSpec.default as string])\r\n      );\r\n      vertexPipelineJob = generateVertexPipelineJobFromGraphComponent(\r\n        componentSpec,\r\n        gcsOutputDirectory,\r\n        defaultInputValues\r\n      );\r\n      vertexPipelineJobJson = JSON.stringify(vertexPipelineJob, undefined, 2);\r\n      // Prevent inifinite re-renders\r\n      if (compilationError !== \"\") {\r\n        setCompilationError(\"\");\r\n      }\r\n    } catch (err) {\r\n      const errorMessage = err.toString();\r\n      // Prevent inifinite re-renders\r\n      if (errorMessage !== compilationError) {\r\n        setCompilationError(err.toString());\r\n      }\r\n    }\r\n  }\r\n  //}, [componentSpec, gcsOutputDirectory]);\r\n\r\n  const vertexPipelineJobUrl = vertexPipelineJobJson && URL.createObjectURL(\r\n    new Blob([vertexPipelineJobJson], { type: \"application/json\" })\r\n  );\r\n\r\n  const readyToSubmit =\r\n    project !== \"\" && region !== \"\" && vertexPipelineJob !== undefined;\r\n\r\n  return (\r\n    <form\r\n      onSubmit={async (e) => {\r\n        e.preventDefault();\r\n        if (vertexPipelineJob === undefined) {\r\n          return;\r\n        }\r\n        setPipelineJobWebUrl(\"\");\r\n        try {\r\n          // setItem might throw exception on iOS in incognito mode\r\n          try {\r\n            window.localStorage?.setItem(LOCAL_STORAGE_GCS_OUTPUT_DIRECTORY_KEY, gcsOutputDirectory);\r\n            window.localStorage?.setItem(LOCAL_STORAGE_PROJECT_ID_KEY, project);\r\n            window.localStorage?.setItem(LOCAL_STORAGE_REGION_KEY, region);\r\n          } catch(err) {\r\n            console.error(\"GoogleCloudSubmitter: Error writing properties to the localStorage\", err);\r\n          }\r\n          const result = await aiplatformCreatePipelineJob(project, region, vertexPipelineJob);\r\n          const pipelineJobName: string = result.name;\r\n          const pipelineJobId = pipelineJobName.split('/').slice(-1)[0];\r\n          const pipelineJobWebUrl = `https://console.cloud.google.com/vertex-ai/locations/${region}/pipelines/runs/${pipelineJobId}?project=${project}`;\r\n          setPipelineJobWebUrl(pipelineJobWebUrl);\r\n          setError(\"\");\r\n        } catch (err) {\r\n          console.error(err);\r\n          setError(err?.result?.error?.message ?? \"Error\");\r\n        }\r\n      }}\r\n    >\r\n      <div style={{ whiteSpace: \"nowrap\" }}>\r\n        <label htmlFor=\"project\">Project: </label>\r\n        <input\r\n          id=\"project\"\r\n          required\r\n          type=\"text\"\r\n          list=\"projects\"\r\n          placeholder=\"<my-project-id>\"\r\n          value={project}\r\n          onChange={(e) => setProject(e.target.value)}\r\n        />\r\n        <datalist id=\"projects\">\r\n          {projects.map((projectId) => (\r\n            <option key={projectId} value={projectId} />\r\n          ))}\r\n        </datalist>\r\n        <button\r\n          type=\"button\" // The default button type is \"submit\", not \"button\". WTF!?\r\n          onClick={async (e) => {\r\n            try {\r\n              const result = await cloudresourcemanagerListProjects();\r\n              const projectIds = (result.projects as any[]).map<string>(\r\n                (projectInfo) => projectInfo.projectId\r\n              );\r\n              setProjects(projectIds);\r\n              setError(\"\");\r\n              try {\r\n                window.localStorage?.setItem(LOCAL_STORAGE_PROJECT_IDS_KEY, JSON.stringify(projectIds));\r\n              } catch(err) {\r\n                console.error(\"GoogleCloudSubmitter: Error writing properties to the localStorage\", err);\r\n              }\r\n            } catch (err) {\r\n              setError(err?.result?.error?.message ?? \"Error\");\r\n            }\r\n          }}\r\n        >\r\n          {/*        */}\r\n        </button>\r\n      </div>\r\n      <div>\r\n        <label htmlFor=\"region\">Region: </label>\r\n        <input\r\n          id=\"region\"\r\n          required\r\n          type=\"text\"\r\n          list=\"regions\"\r\n          value={region}\r\n          onChange={(e) => setRegion(e.target.value)}\r\n        />\r\n        <datalist id=\"regions\">\r\n          {VERTEX_AI_PIPELINES_REGIONS.map((region) => (\r\n            <option key={region} value={region} />\r\n          ))}\r\n        </datalist>\r\n      </div>\r\n      <div>\r\n        <label htmlFor=\"region\">GCS dir: </label>\r\n        <input\r\n          id=\"gcsOutputDirectory\"\r\n          required\r\n          type=\"text\"\r\n          value={gcsOutputDirectory}\r\n          onChange={(e) => setGcsOutputDirectory(e.target.value)}\r\n        />\r\n      </div>\r\n      <input\r\n        type=\"submit\"\r\n        disabled={!readyToSubmit}\r\n        value=\"Submit pipeline job\"\r\n      />\r\n      {pipelineJobWebUrl !== \"\" && <div><a href={pipelineJobWebUrl} target=\"_blank\" rel=\"noreferrer\">Job</a></div>}\r\n      {vertexPipelineJobUrl !== undefined && (\r\n        <div>\r\n          Download <a\r\n            href={vertexPipelineJobUrl}\r\n            download={\"vertex_pipeline_job.json\"}\r\n          >\r\n            vertex_pipeline_job.json\r\n          </a>\r\n        </div>\r\n      )}\r\n      {compilationError !== \"\" && <div>{compilationError}</div>}\r\n      {error !== \"\" && <div>Error: {error}</div>}\r\n    </form>\r\n  );\r\n};\r\n\r\nexport default GoogleCloudSubmitter;\r\n","import {\r\n  useStoreState,\r\n} from \"react-flow-renderer\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\nimport {graphComponentSpecToVertexPipelineSpec} from './vertexAiCompiler'\r\n\r\ninterface VertexAiExporterProps {\r\n  componentSpec: ComponentSpec;\r\n}\r\n\r\nconst VertexAiExporter = ({componentSpec}: VertexAiExporterProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  let vertexPipelineSpecText = \"\";\r\n  try {\r\n    // Augmenting the componentSpec might be useless right now, but it can stabilize the output (e.g. ordering).\r\n    // Also, in the future, the original spec might be included in the vertexPipelineSpec\r\n    componentSpec = augmentComponentSpec(componentSpec, nodes, true, true);\r\n    const vertexPipelineSpec = graphComponentSpecToVertexPipelineSpec(componentSpec);\r\n    vertexPipelineSpecText = JSON.stringify(vertexPipelineSpec, undefined, 2);\r\n  } catch(err) {\r\n    vertexPipelineSpecText = String(err);\r\n  }\r\n\r\n  const vertexPipelineSpecTextBlob = new Blob([vertexPipelineSpecText], { type: \"application/json\" }); // Or application/x-yaml (which leads to downloading)\r\n  // TODO: Call vertexPipelineSpecTextBlobUrl.revokeObjectURL in the future\r\n  const vertexPipelineSpecTextBlobUrl = URL.createObjectURL(vertexPipelineSpecTextBlob);\r\n\r\n  return (\r\n    <details>\r\n      <summary>\r\n        Cloud IR <a\r\n          href={vertexPipelineSpecTextBlobUrl}\r\n          download={\"vertex_pipeline_spec.json\"}\r\n        >\r\n          vertex_pipeline_spec.json\r\n        </a>\r\n      </summary>\r\n      <pre style={{ overflow: \"auto\" }}>{vertexPipelineSpecText}</pre>\r\n    </details>\r\n  );\r\n};\r\n\r\nexport default VertexAiExporter;\r\n","import { useStoreState } from \"react-flow-renderer\";\r\nimport yaml from \"js-yaml\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\nimport { augmentComponentSpec } from \"./GraphComponentSpecFlow\";\r\n\r\ninterface GraphComponentLinkProps {\r\n  componentSpec: ComponentSpec;\r\n  downloadFileName?: string;\r\n  linkText?: string;\r\n}\r\n\r\nconst GraphComponentLink = ({\r\n  componentSpec,\r\n  downloadFileName = \"component.yaml\",\r\n  linkText = \"component.yaml\",\r\n}: GraphComponentLinkProps) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n\r\n  let componentText = \"\";\r\n  try {\r\n    componentSpec = augmentComponentSpec(componentSpec, nodes, false, true);\r\n    componentText = yaml.dump(componentSpec, { lineWidth: 10000 });\r\n  } catch (err) {\r\n    return <>err.toString()</>;\r\n  }\r\n\r\n  const componentTextBlob = new Blob([componentText], { type: \"text/yaml\" }); // Or application/x-yaml (which leads to downloading)\r\n  return (\r\n    <a\r\n      href={URL.createObjectURL(componentTextBlob)}\r\n      download={downloadFileName}\r\n    >\r\n      {linkText}\r\n    </a>\r\n  );\r\n};\r\n\r\nexport default GraphComponentLink;\r\n","import { useState } from \"react\";\r\n\r\nimport { ComponentSpec } from \"../componentSpec\";\r\n\r\ninterface KubeflowPipelinesSubmitterProps {\r\n  componentSpec?: ComponentSpec;\r\n}\r\n\r\nconst KubeflowPipelinesSubmitter = ({\r\n  componentSpec,\r\n}: KubeflowPipelinesSubmitterProps) => {\r\n  const [message, setMessage] = useState(\"\");\r\n  return (\r\n    <div>\r\n      <button\r\n        onClick={async (e) => {\r\n          const response = await fetch(\r\n            \"https://704a448c0a693194-dot-us-central2.pipelines.googleusercontent.com/apis/v1beta1/runs\",\r\n            {\r\n              headers: new Headers({\r\n              }),\r\n            }\r\n          );\r\n          const responseText = await response.text();\r\n          setMessage(responseText);\r\n        }}\r\n      >\r\n        List KFP runs\r\n      </button>\r\n      <span>{message}</span>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default KubeflowPipelinesSubmitter;\r\n","import { useState } from 'react';\r\nimport {\r\n  ReactFlowProvider,\r\n  Controls,\r\n  Background,\r\n  MiniMap,\r\n  Node,\r\n  useStoreState,\r\n} from 'react-flow-renderer';\r\nimport yaml from \"js-yaml\";\r\n\r\nimport { ComponentSpec } from '../componentSpec';\r\nimport GraphComponentSpecFlow, { augmentComponentSpec } from './GraphComponentSpecFlow';\r\nimport Sidebar from './Sidebar';\r\nimport { loadComponentFromUrl, XGBOOST_PIPELINE_URL } from \"./samplePipelines\";\r\n\r\nimport './dnd.css';\r\n\r\nconst GRID_SIZE = 10;\r\nconst SAVED_COMPONENT_SPEC_KEY = \"autosaved.component.yaml\";\r\n\r\nconst saveComponentSpec = (componentSpec: ComponentSpec, nodes?: Node[]) => {\r\n  try {\r\n    if (nodes !== undefined) {\r\n      if (nodes.length === 0) {\r\n        console.warn(\"saveComponentSpec: nodes.length === 0\");\r\n      }\r\n      componentSpec = augmentComponentSpec(componentSpec, nodes, true, true);\r\n    }\r\n    const componentText = yaml.dump(componentSpec, { lineWidth: 10000 });\r\n    window.sessionStorage.setItem(SAVED_COMPONENT_SPEC_KEY, componentText);\r\n  } catch(err) {\r\n    console.error(err);\r\n  }\r\n}\r\n\r\nconst loadComponentSpec = () => {\r\n  try {\r\n    const componentText = window.sessionStorage.getItem(SAVED_COMPONENT_SPEC_KEY);\r\n    if (componentText !== null) {\r\n      const loadedYaml = yaml.load(componentText);\r\n      if (loadedYaml !== null && typeof loadedYaml === \"object\") {\r\n        //TODO: Validate that the spec is valid\r\n        const savedComponentSpec = loadedYaml as ComponentSpec;\r\n        return savedComponentSpec;\r\n      }\r\n    }\r\n  } catch(err) {\r\n    console.error(err);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n// Auto-saver is extracted to its own child component since useStoreState in the parent causes inifinite re-rendering\r\n// (each render of GraphComponentSpecFlow seems to change the Redux store).\r\n// This component seems to be triggered for every node movement, so even pure layout changes are saved.\r\nconst ComponentSpecAutoSaver = ({\r\n  componentSpec,\r\n}: {\r\n  componentSpec: ComponentSpec;\r\n}) => {\r\n  const nodes = useStoreState((store) => store.nodes);\r\n  // Fixing issue where a React error would cause all node positions to be recorded as undefined (`!<tag:yaml.org,2002:js/undefined>`)\r\n  // nodes should never be undefined in normal situation.\r\n  if (nodes !== undefined && nodes.length > 0) {\r\n    saveComponentSpec(componentSpec, nodes);\r\n  }\r\n  return null;\r\n};\r\n\r\nconst DnDFlow = () => {\r\n  const [componentSpec, setComponentSpec] = useState<ComponentSpec | undefined>();\r\n\r\n  if (componentSpec === undefined) {\r\n    const restoredComponentSpec = loadComponentSpec();\r\n    if (restoredComponentSpec === undefined) {\r\n      loadComponentFromUrl(XGBOOST_PIPELINE_URL).then(setComponentSpec);\r\n    } else {\r\n      setComponentSpec(restoredComponentSpec);\r\n    }\r\n  };\r\n\r\n  if (componentSpec === undefined) {\r\n    return (<></>);\r\n  }\r\n\r\n  return (\r\n    <div className=\"dndflow\">\r\n      <ReactFlowProvider>\r\n        <div className=\"reactflow-wrapper\">\r\n          <GraphComponentSpecFlow\r\n            componentSpec={componentSpec}\r\n            setComponentSpec={setComponentSpec}\r\n            deleteKeyCode='Delete'\r\n            multiSelectionKeyCode='Control'\r\n            snapToGrid={true}\r\n            snapGrid={[GRID_SIZE, GRID_SIZE]}\r\n          >\r\n            <MiniMap/>\r\n            <Controls />\r\n            <Background gap={GRID_SIZE}/>\r\n          </GraphComponentSpecFlow>\r\n        </div>\r\n        <Sidebar\r\n          componentSpec={componentSpec}\r\n          setComponentSpec={setComponentSpec}\r\n        />\r\n        <ComponentSpecAutoSaver componentSpec={componentSpec}/>\r\n      </ReactFlowProvider>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default DnDFlow;\r\n","import './App.css';\r\nimport DnDFlow from './DragNDrop/index';\r\n\r\nfunction App() {\r\n  return (\r\n    <div className=\"App\" style={{width: \"100%\", height: \"100%\"}}>\r\n      <DnDFlow/>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://cra.link/PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\r\n);\r\n\r\ntype Config = {\r\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\r\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\r\n};\r\n\r\nexport function register(config?: Config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://cra.link/PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl: string, config?: Config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then((registration) => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://cra.link/PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch((error) => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then((response) => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then((registration) => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log('No internet connection found. App is running in offline mode.');\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then((registration) => {\r\n        registration.unregister();\r\n      })\r\n      .catch((error) => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  // Strict mode causes every component to be rendered twice in dev environment\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.register();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}